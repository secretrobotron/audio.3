<!DOCTYPE html>
<html>
	<head>
    <base target="_blank">
    <style type="text/css">
      body {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        overflow: hidden;
        background: #000000;
      }

      .data-image {
        display: none;
      }
    </style>
		<script type="text/javascript">
var channelCountByIdentifier = {
	'TDZ1': 1, '1CHN': 1, 'TDZ2': 2, '2CHN': 2, 'TDZ3': 3, '3CHN': 3,
	'M.K.': 4, 'FLT4': 4, 'M!K!': 4, '4CHN': 4, 'TDZ4': 4, '5CHN': 5, 'TDZ5': 5,
	'6CHN': 6, 'TDZ6': 6, '7CHN': 7, 'TDZ7': 7, '8CHN': 8, 'TDZ8': 8, 'OCTA': 8, 'CD81': 8,
	'9CHN': 9, 'TDZ9': 9,
	'10CH': 10, '11CH': 11, '12CH': 12, '13CH': 13, '14CH': 14, '15CH': 15, '16CH': 16, '17CH': 17,
	'18CH': 18, '19CH': 19, '20CH': 20, '21CH': 21, '22CH': 22, '23CH': 23, '24CH': 24, '25CH': 25,
	'26CH': 26, '27CH': 27, '28CH': 28, '29CH': 29, '30CH': 30, '31CH': 31, '32CH': 32
}

function ModFile(mod) {
	function trimNulls(str) {
		return str.replace(/\x00+$/, '');
	}
	function getWord(str, pos) {
		return (str.charCodeAt(pos) << 8) + str.charCodeAt(pos+1)
	}

	this.data = mod;
	this.samples = [];
	this.sampleData = [];
	this.positions = [];
	this.patternCount = 0;
	this.patterns = [];
	
	this.title = trimNulls(mod.substr(0, 20))

	this.sampleCount = 31;

	for (var i = 0; i < this.sampleCount; i++) {
		var sampleInfo = mod.substr(20 + i*30, 30);
		var sampleName = trimNulls(sampleInfo.substr(0, 22));
		this.samples[i] = {
			length: getWord(sampleInfo, 22) * 2,
			finetune: sampleInfo.charCodeAt(24),
			volume: sampleInfo.charCodeAt(25),
			repeatOffset: getWord(sampleInfo, 26) * 2,
			repeatLength: getWord(sampleInfo, 28) * 2,
		}
	}
	
	this.positionCount = mod.charCodeAt(950);
	this.positionLoopPoint = mod.charCodeAt(951);
	for (var i = 0; i < 128; i++) {
		this.positions[i] = mod.charCodeAt(952+i);
		if (this.positions[i] >= this.patternCount) {
			this.patternCount = this.positions[i]+1;
		}
	}
	
	var identifier = mod.substr(1080, 4);
	
	this.channelCount = channelCountByIdentifier[identifier];
	if (!this.channelCount) {
		this.channelCount = 4;
	}
	
	var patternOffset = 1084;
	for (var pat = 0; pat < this.patternCount; pat++) {
		this.patterns[pat] = [];
		for (var row = 0; row < 64; row++) {
			this.patterns[pat][row] = [];
			for (var chan = 0; chan < this.channelCount; chan++) {
				b0 = mod.charCodeAt(patternOffset);
				b1 = mod.charCodeAt(patternOffset + 1);
				b2 = mod.charCodeAt(patternOffset + 2);
				b3 = mod.charCodeAt(patternOffset + 3);
				var eff = b2 & 0x0f;
				this.patterns[pat][row][chan] = {
					sample: (b0 & 0xf0) | (b2 >> 4),
					period: ((b0 & 0x0f) << 8) | b1,
					effect: eff,
					effectParameter: b3
				};
				if (eff == 0x0E) {
					this.patterns[pat][row][chan].extEffect = (b3 & 0xF0) >> 4;
					this.patterns[pat][row][chan].extEffectParameter = (b3 & 0x0F);
				}
				patternOffset += 4;
			}
		}
	}
	
	var sampleOffset = patternOffset;
	for (var s = 0; s < this.sampleCount; s++) {
		this.samples[s].startOffset = sampleOffset;
		this.sampleData[s] = TypedArray(this.samples[s].length, "uint8");
		var i = 0;
		for (var o = sampleOffset, e = sampleOffset + this.samples[s].length; o < e; o++) {
			this.sampleData[s][i] = mod.charCodeAt(o);
			i++;
		}
		sampleOffset += this.samples[s].length;
	}
	
}

</script>
		<script type="text/javascript">
/*
	http://www.fileformat.info/format/xm/corion.htm
	
	Sample data is stored "Delta compressed like protracker"
		algorithm: http://www.fileformat.info/format/protracker/corion-algorithm.htm
*/
function XMFile(mod) {
	function trimNulls(str) {
		return str.replace(/\x00+$/, '');
	}
	function getWord(str, pos) {
		//little-endian this time
		return (str.charCodeAt(pos)) + (str.charCodeAt(pos+1) << 8)
	}
	function getDword(str, pos) {
		var value =
			(str.charCodeAt(pos+3) << 24) +
			(str.charCodeAt(pos+2) << 16) +
			(str.charCodeAt(pos+1) << 8) +
			str.charCodeAt(pos);
		return value;
	}
	function getBytes(str, pos, len) {
		return (str.substr(pos, len));
	}
	function getString(str, pos, len) {
		return trimNulls(getBytes(str, pos, len));
	}
	function getArray(str, pos, len) {
		var s = getBytes(str, pos, len);
		var arr = Array(s.length);
		for (var i = 0; i < s.length; i++) {
			arr[i] = s.charCodeAt(i);
		}
		return arr;
	}

	//this.data = mod;
	this.samples = [];
	this.positions = [];
	this.patternCount = 0;
	this.patterns = [];
	this.instruments = [];
	this.speed = 6;
	this.bpm = 125;
	
	this.title = getString(mod, 0x11, 20);				//0x11		Song name
	this.positionCount = getWord(mod, 0x40);			//0x40		Song length in patterns
	this.positionLoopPoint = getWord(mod, 0x42);		//0x42		Restart position
	this.channelCount = getWord(mod, 0x44);				//0x44		Number of channels
	this.patternCount = getWord(mod, 0x46);				//0x46		Number of patterns (0 - 255)
	this.instrumentCount = getWord(mod, 0x48);			//0x48		Number of instruments (0 - 127)
	this.speed = getWord(mod, 0x4C);					//0x4C		Default ticks/row
	this.bpm = getWord(mod, 0x4E);						//0x4E		Default bpm
	
	//0x50 - pattern order table
	for (var i = 0; i < 256; i++) {
		this.positions[i] = mod.charCodeAt(0x50+i);
	}
	
	var patternOffset = 0x50 + 256;
	var track, packBit, rowCount, dataSize;
	for (var pat = 0; pat < 1; pat++) {
		var headerLength = getDword(mod, patternOffset);	//Why? Isn't it always 9?
		rowCount = getWord(mod, patternOffset + 5);
		dataSize = getWord(mod, patternOffset + 7);
		this.patterns[pat] = {
			rowCount: rowCount,
		}
		
		//move pointer to first track of row then loop over each one
		patternOffset += 9;
		for (var row = 0; row < this.patterns[pat].rowCount; row++) {
			this.patterns[pat][row] = [];
			for (var chan = 0; chan < this.channelCount; chan++) {
				track = getArray(mod, patternOffset, 5);
				//console.log(track[0].toString(2), track);
				
				//If the most significant bit of a note is NOT set, then read data like normal
				//If it IS set, check the other bits and see what kind of data comes next
				//These are bitflags so 1 to 5 bytes may follow depending on how many are set
				//		bit 0 set: Note byte follows
				//		bit 1 set: Instrument byte follows
				//		bit 2 set: Volume column byte follows
				// 		bit 3 set: Effect byte follows
				//		bit 4 set: Effect data byte follows
				var packBit = track[0] & 0x80;
				var packFlags = track[0] & 0x1F; 	//00011111b
				var noteByte = 0, instrByte = 0, volByte = 0, effByte = 0, effParamByte = 0;
				
				if (packBit) {
					var o = 1; //offset
					//check each bit in order. If set, read byte and increment pointer
					if (packFlags & 0x01) { noteByte = track[o]; o++; }			
					if (packFlags & 0x02) { instrByte = track[o]; o++; }			
					if (packFlags & 0x04) { volByte = track[o]; o++; }
					if (packFlags & 0x08) { effByte = track[o]; o++; }
					if (packFlags & 0x10) { effParamByte = track[o]; o++; }
					patternOffset += o;
				} else {
					//no compression
					noteByte = track[0];
					instrByte = track[1];
					volByte = track[2];
					effByte = track[3];
					effParamByte = track[4];
					patternOffset += 5;
				}
				
				this.patterns[pat][row][chan] = {
					note: noteByte,
					instrument: instrByte,
					volume: volByte,
					effect: effByte,
					effectParameter: effParamByte
				}
			}
		}
	}





	
}
</script>
		<script type="text/javascript">
/*
	Useful docs
		Explains effect calculations: http://www.mediatel.lu/workshop/audio/fileformat/h_mod.html

*/

/*
ModPeriodTable[ft][n] = the period to use for note number n at finetune value ft.
Finetune values are in twos-complement, i.e. [0,1,2,3,4,5,6,7,-8,-7,-6,-5,-4,-3,-2,-1]
The first table is used to generate a reverse lookup table, to find out the note number
for a period given in the MOD file.
*/
var ModPeriodTable = [
	[1712, 1616, 1524, 1440, 1356, 1280, 1208, 1140, 1076, 1016, 960 , 906,
	 856 , 808 , 762 , 720 , 678 , 640 , 604 , 570 , 538 , 508 , 480 , 453,
	 428 , 404 , 381 , 360 , 339 , 320 , 302 , 285 , 269 , 254 , 240 , 226,
	 214 , 202 , 190 , 180 , 170 , 160 , 151 , 143 , 135 , 127 , 120 , 113,
	 107 , 101 , 95  , 90  , 85  , 80  , 75  , 71  , 67  , 63  , 60  , 56 ],
	[1700, 1604, 1514, 1430, 1348, 1274, 1202, 1134, 1070, 1010, 954 , 900,
	 850 , 802 , 757 , 715 , 674 , 637 , 601 , 567 , 535 , 505 , 477 , 450,
	 425 , 401 , 379 , 357 , 337 , 318 , 300 , 284 , 268 , 253 , 239 , 225,
	 213 , 201 , 189 , 179 , 169 , 159 , 150 , 142 , 134 , 126 , 119 , 113,
	 106 , 100 , 94  , 89  , 84  , 79  , 75  , 71  , 67  , 63  , 59  , 56 ],
	[1688, 1592, 1504, 1418, 1340, 1264, 1194, 1126, 1064, 1004, 948 , 894,
	 844 , 796 , 752 , 709 , 670 , 632 , 597 , 563 , 532 , 502 , 474 , 447,
	 422 , 398 , 376 , 355 , 335 , 316 , 298 , 282 , 266 , 251 , 237 , 224,
	 211 , 199 , 188 , 177 , 167 , 158 , 149 , 141 , 133 , 125 , 118 , 112,
	 105 , 99  , 94  , 88  , 83  , 79  , 74  , 70  , 66  , 62  , 59  , 56 ],
	[1676, 1582, 1492, 1408, 1330, 1256, 1184, 1118, 1056, 996 , 940 , 888,
	 838 , 791 , 746 , 704 , 665 , 628 , 592 , 559 , 528 , 498 , 470 , 444,
	 419 , 395 , 373 , 352 , 332 , 314 , 296 , 280 , 264 , 249 , 235 , 222,
	 209 , 198 , 187 , 176 , 166 , 157 , 148 , 140 , 132 , 125 , 118 , 111,
	 104 , 99  , 93  , 88  , 83  , 78  , 74  , 70  , 66  , 62  , 59  , 55 ],
	[1664, 1570, 1482, 1398, 1320, 1246, 1176, 1110, 1048, 990 , 934 , 882,
	 832 , 785 , 741 , 699 , 660 , 623 , 588 , 555 , 524 , 495 , 467 , 441,
	 416 , 392 , 370 , 350 , 330 , 312 , 294 , 278 , 262 , 247 , 233 , 220,
	 208 , 196 , 185 , 175 , 165 , 156 , 147 , 139 , 131 , 124 , 117 , 110,
	 104 , 98  , 92  , 87  , 82  , 78  , 73  , 69  , 65  , 62  , 58  , 55 ],
	[1652, 1558, 1472, 1388, 1310, 1238, 1168, 1102, 1040, 982 , 926 , 874,
	 826 , 779 , 736 , 694 , 655 , 619 , 584 , 551 , 520 , 491 , 463 , 437,
	 413 , 390 , 368 , 347 , 328 , 309 , 292 , 276 , 260 , 245 , 232 , 219,
	 206 , 195 , 184 , 174 , 164 , 155 , 146 , 138 , 130 , 123 , 116 , 109,
	 103 , 97  , 92  , 87  , 82  , 77  , 73  , 69  , 65  , 61  , 58  , 54 ],
	[1640, 1548, 1460, 1378, 1302, 1228, 1160, 1094, 1032, 974 , 920 , 868,
	 820 , 774 , 730 , 689 , 651 , 614 , 580 , 547 , 516 , 487 , 460 , 434,
	 410 , 387 , 365 , 345 , 325 , 307 , 290 , 274 , 258 , 244 , 230 , 217,
	 205 , 193 , 183 , 172 , 163 , 154 , 145 , 137 , 129 , 122 , 115 , 109,
	 102 , 96  , 91  , 86  , 81  , 77  , 72  , 68  , 64  , 61  , 57  , 54 ],
	[1628, 1536, 1450, 1368, 1292, 1220, 1150, 1086, 1026, 968 , 914 , 862,
	 814 , 768 , 725 , 684 , 646 , 610 , 575 , 543 , 513 , 484 , 457 , 431,
	 407 , 384 , 363 , 342 , 323 , 305 , 288 , 272 , 256 , 242 , 228 , 216,
	 204 , 192 , 181 , 171 , 161 , 152 , 144 , 136 , 128 , 121 , 114 , 108,
	 102 , 96  , 90  , 85  , 80  , 76  , 72  , 68  , 64  , 60  , 57  , 54 ],
	[1814, 1712, 1616, 1524, 1440, 1356, 1280, 1208, 1140, 1076, 1016, 960,
	 907 , 856 , 808 , 762 , 720 , 678 , 640 , 604 , 570 , 538 , 508 , 480,
	 453 , 428 , 404 , 381 , 360 , 339 , 320 , 302 , 285 , 269 , 254 , 240,
	 226 , 214 , 202 , 190 , 180 , 170 , 160 , 151 , 143 , 135 , 127 , 120,
	 113 , 107 , 101 , 95  , 90  , 85  , 80  , 75  , 71  , 67  , 63  , 60 ],
	[1800, 1700, 1604, 1514, 1430, 1350, 1272, 1202, 1134, 1070, 1010, 954,
	 900 , 850 , 802 , 757 , 715 , 675 , 636 , 601 , 567 , 535 , 505 , 477,
	 450 , 425 , 401 , 379 , 357 , 337 , 318 , 300 , 284 , 268 , 253 , 238,
	 225 , 212 , 200 , 189 , 179 , 169 , 159 , 150 , 142 , 134 , 126 , 119,
	 112 , 106 , 100 , 94  , 89  , 84  , 79  , 75  , 71  , 67  , 63  , 59 ],
	[1788, 1688, 1592, 1504, 1418, 1340, 1264, 1194, 1126, 1064, 1004, 948,
	 894 , 844 , 796 , 752 , 709 , 670 , 632 , 597 , 563 , 532 , 502 , 474,
	 447 , 422 , 398 , 376 , 355 , 335 , 316 , 298 , 282 , 266 , 251 , 237,
	 223 , 211 , 199 , 188 , 177 , 167 , 158 , 149 , 141 , 133 , 125 , 118,
	 111 , 105 , 99  , 94  , 88  , 83  , 79  , 74  , 70  , 66  , 62  , 59 ],
	[1774, 1676, 1582, 1492, 1408, 1330, 1256, 1184, 1118, 1056, 996 , 940,
	 887 , 838 , 791 , 746 , 704 , 665 , 628 , 592 , 559 , 528 , 498 , 470,
	 444 , 419 , 395 , 373 , 352 , 332 , 314 , 296 , 280 , 264 , 249 , 235,
	 222 , 209 , 198 , 187 , 176 , 166 , 157 , 148 , 140 , 132 , 125 , 118,
	 111 , 104 , 99  , 93  , 88  , 83  , 78  , 74  , 70  , 66  , 62  , 59 ],
	[1762, 1664, 1570, 1482, 1398, 1320, 1246, 1176, 1110, 1048, 988 , 934,
	 881 , 832 , 785 , 741 , 699 , 660 , 623 , 588 , 555 , 524 , 494 , 467,
	 441 , 416 , 392 , 370 , 350 , 330 , 312 , 294 , 278 , 262 , 247 , 233,
	 220 , 208 , 196 , 185 , 175 , 165 , 156 , 147 , 139 , 131 , 123 , 117,
	 110 , 104 , 98  , 92  , 87  , 82  , 78  , 73  , 69  , 65  , 61  , 58 ],
	[1750, 1652, 1558, 1472, 1388, 1310, 1238, 1168, 1102, 1040, 982 , 926,
	 875 , 826 , 779 , 736 , 694 , 655 , 619 , 584 , 551 , 520 , 491 , 463,
	 437 , 413 , 390 , 368 , 347 , 328 , 309 , 292 , 276 , 260 , 245 , 232,
	 219 , 206 , 195 , 184 , 174 , 164 , 155 , 146 , 138 , 130 , 123 , 116,
	 109 , 103 , 97  , 92  , 87  , 82  , 77  , 73  , 69  , 65  , 61  , 58 ],
	[1736, 1640, 1548, 1460, 1378, 1302, 1228, 1160, 1094, 1032, 974 , 920,
	 868 , 820 , 774 , 730 , 689 , 651 , 614 , 580 , 547 , 516 , 487 , 460,
	 434 , 410 , 387 , 365 , 345 , 325 , 307 , 290 , 274 , 258 , 244 , 230,
	 217 , 205 , 193 , 183 , 172 , 163 , 154 , 145 , 137 , 129 , 122 , 115,
	 108 , 102 , 96  , 91  , 86  , 81  , 77  , 72  , 68  , 64  , 61  , 57 ],
	[1724, 1628, 1536, 1450, 1368, 1292, 1220, 1150, 1086, 1026, 968 , 914,
	 862 , 814 , 768 , 725 , 684 , 646 , 610 , 575 , 543 , 513 , 484 , 457,
	 431 , 407 , 384 , 363 , 342 , 323 , 305 , 288 , 272 , 256 , 242 , 228,
	 216 , 203 , 192 , 181 , 171 , 161 , 152 , 144 , 136 , 128 , 121 , 114,
	 108 , 101 , 96  , 90  , 85  , 80  , 76  , 72  , 68  , 64  , 60  , 57 ]];
	 
var SineTable = [
	0,24,49,74,97,120,141,161,180,197,212,224,235,244,250,253,
	255,253,250,244,235,224,212,197,180,161,141,120,97,74,49,
	24,0,-24,-49,-74,-97,-120,-141,-161,-180,-197,-212,-224,
	-235,-244,-250,-253,-255,-253,-250,-244,-235,-224,-212,-197,
	-180,-161,-141,-120,-97,-74,-49,-24
];

var ModPeriodToNoteNumber = {};
for (var i = 0; i < ModPeriodTable[0].length; i++) {
	ModPeriodToNoteNumber[ModPeriodTable[0][i]] = i;
}

function ModPlayer(mod, rate) {
	/* timing calculations */
	var ticksPerSecond = 7093789.2; /* PAL frequency */
	var ticksPerFrame; /* calculated by setBpm */
	var ticksPerOutputSample = Math.round(ticksPerSecond / rate);
	var ticksSinceStartOfFrame = 0;
	
	function setBpm(bpm) {
		/* x beats per minute => x*4 rows per minute */
		ticksPerFrame = Math.round(ticksPerSecond * 2.5/bpm);
	}
	setBpm(125);
	
	/* initial player state */
	var framesPerRow = 6;
	var currentFrame = 0;
	var currentPattern;
	var currentPosition;
	var currentRow;
	var exLoop = false;		//whether E6x looping is currently set
	var exLoopStart = 0;	//loop point set up by E60
	var exLoopEnd = 0;		//end of loop (where we hit a E6x cmd) for accurate counting
	var exLoopCount = 0;	//loops remaining
	var doBreak = false;	//Bxx, Dxx - jump to order and pattern break
	var	breakPos = 0;
	var	breakRow = 0;
	var delayRows = false; //EEx pattern delay.
	
	var channels = [];
	for (var chan = 0; chan < mod.channelCount; chan++) {
		channels[chan] = {
			playing: false,
			sample: mod.samples[0],
			finetune: 0,
			volume: 0,
			pan: 0x7F,	//unimplemented
			volumeDelta: 0,
			periodDelta: 0,
			fineVolumeDelta: 0,
			finePeriodDelta: 0,
			tonePortaTarget: 0, //target for 3xx, 5xy as period value
			tonePortaDelta: 0,
			tonePortaVolStep: 0, //remember pitch slide step for when 5xx is used
			tonePortaActive: false,
			cut: false,			//tick to cut at, or false if no cut
			delay: false,		//tick to delay note until, or false if no delay
			arpeggioActive: false
		};
	}
	
	function loadRow(rowNumber) {
		currentRow = rowNumber;
		currentFrame = 0;
		doBreak = false;
		breakPos = 0;
		breakRow = 0;

		for (var chan = 0; chan < mod.channelCount; chan++) {
			var channel = channels[chan];
			var prevNote = channel.prevNote;
			var note = currentPattern[currentRow][chan];
			if (channel.sampleNum == undefined) {
					channel.sampleNum = 0;
			}
			if (note.period != 0 || note.sample != 0) {
				channel.playing = true;
				channel.samplePosition = 0;
				channel.ticksSinceStartOfSample = 0; /* that's 'sample' as in 'individual volume reading' */
				if (note.sample != 0) {
					channel.sample = mod.samples[note.sample - 1];
					channel.sampleNum = note.sample - 1;
					channel.volume = channel.sample.volume;
					channel.finetune = channel.sample.finetune;
				}
				if (note.period != 0) { // && note.effect != 0x03
					//the note specified in a tone porta command is not actually played
					if (note.effect != 0x03) {
						channel.noteNumber = ModPeriodToNoteNumber[note.period];
						channel.ticksPerSample = ModPeriodTable[channel.finetune][channel.noteNumber] * 2;
					} else {
						channel.noteNumber = ModPeriodToNoteNumber[prevNote.period]
						channel.ticksPerSample = ModPeriodTable[channel.finetune][channel.noteNumber] * 2;
					}
				}
			}
			channel.finePeriodDelta = 0;
			channel.fineVolumeDelta = 0;
			channel.cut = false;
			channel.delay = false;
			channel.retrigger = false;
			channel.tonePortaActive = false;
			if (note.effect != 0 || note.effectParameter != 0) {
				channel.volumeDelta = 0; /* new effects cancel volumeDelta */
				channel.periodDelta = 0; /* new effects cancel periodDelta */
				channel.arpeggioActive = false;
				switch (note.effect) {
					case 0x00: /* arpeggio: 0xy */
						channel.arpeggioActive = true;
						channel.arpeggioNotes = [
							channel.noteNumber,
							channel.noteNumber + (note.effectParameter >> 4),
							channel.noteNumber + (note.effectParameter & 0x0f)
						]
						channel.arpeggioCounter = 0;
						break;
					case 0x01: /* pitch slide up - 1xx */
						channel.periodDelta = -note.effectParameter;
						break;
					case 0x02: /* pitch slide down - 2xx */
						channel.periodDelta = note.effectParameter;
						break;
					case 0x03: /* slide to note 3xy - */
						channel.tonePortaActive = true;
						channel.tonePortaTarget = (note.period != 0) ? note.period : channel.tonePortaTarget;
						var dir = (channel.tonePortaTarget < prevNote.period) ? -1 : 1;
						channel.tonePortaDelta = (note.effectParameter * dir);
						channel.tonePortaVolStep = (note.effectParameter * dir);
						channel.tonePortaDir = dir;
						break;
					case 0x05: /* portamento to note with volume slide 5xy */
						channel.tonePortaActive = true;
						if (note.effectParameter & 0xf0) {
							channel.volumeDelta = note.effectParameter >> 4;
						} else {
							channel.volumeDelta = -note.effectParameter;
						}
						channel.tonePortaDelta = channel.tonePortaVolStep;
						break;
					case 0x09: /* sample offset - 9xx */
						channel.samplePosition = 256 * note.effectParameter;
						break;
					case 0x0A: /* volume slide - Axy */
						if (note.effectParameter & 0xf0) {
							/* volume increase by x */
							channel.volumeDelta = note.effectParameter >> 4;
						} else {
							/* volume decrease by y */
							channel.volumeDelta = -note.effectParameter;
						}
						break;
					case 0x0B: /* jump to order */
						doBreak = true;
						breakPos = note.effectParameter;
						breakRow = 0;
						break;
					case 0x0C: /* volume */
						if (note.effectParameter > 64) {
							channel.volume = 64;
						} else {
							channel.volume = note.effectParameter;
						}
						break;
					case 0x0D: /* pattern break; jump to next pattern at specified row */
						doBreak = true;
						breakPos = currentPosition + 1;
						//Row is written as DECIMAL so grab the high part as a single digit and do some math
						breakRow = ((note.effectParameter & 0xF0) >> 4) * 10 + (note.effectParameter & 0x0F);
						break;
						
					case 0x0E:
						switch (note.extEffect) {	//yes we're doing nested switch
							case 0x01: /* fine pitch slide up - E1x */
								channel.finePeriodDelta = -note.extEffectParameter;
								break;
							case 0x02: /* fine pitch slide down - E2x */
								channel.finePeriodDelta = note.extEffectParameter;
								break;
							case 0x05: /* set finetune - E5x */
								channel.finetune = note.extEffectParameter;
								break;
							case 0x09: /* retrigger sample - E9x */
								channel.retrigger = note.extEffectParameter;
								break;
							case 0x0A: /* fine volume slide up - EAx */
								channel.fineVolumeDelta = note.extEffectParameter;
								break;
							case 0x0B: /* fine volume slide down - EBx */
								channel.fineVolumeDelta = -note.extEffectParameter;
								break;
							case 0x0C: /* note cute - ECx */
								channel.cut = note.extEffectParameter;
								break;
							case 0x0D: /* note delay - EDx */
								channel.delay = note.extEffectParameter;
								break;
							case 0x0E: /* pattern delay EEx */
								delayRows = note.extEffectParameter;
								break;
							case 0x06:
								//set loop start with E60
								if (note.extEffectParameter == 0) {
									exLoopStart = currentRow;
								} else {
									//set loop end with E6x
									exLoopEnd = currentRow;
									//activate the loop only if it's new
									if (!exLoop) {
										exLoop = true;
										exLoopCount = note.extEffectParameter;
									}
								}
								break;
						}
						
						break;
						
					case 0x0F: /* tempo change. <=32 sets ticks/row, greater sets beats/min instead */
						var newSpeed = (note.effectParameter == 0) ? 1 : note.effectParameter; /* 0 is treated as 1 */
						if (newSpeed <= 32) { 
							framesPerRow = newSpeed;
						} else {
							setBpm(newSpeed);
						}
						break;
				}
			}
			
			//for figuring out tone portamento effect
			if (note.period != 0) { channel.prevNote = note; }
			
			if (channel.tonePortaActive == false) {
				channel.tonePortaDelta = 0;
				channel.tonePortaTarget = 0;
				channel.tonePortaVolStep = 0;
			}
		}
		
	}
	
	function loadPattern(patternNumber) {
		var row = doBreak ? breakRow : 0;
		currentPattern = mod.patterns[patternNumber];
		loadRow(row);
	}
	
	function loadPosition(positionNumber) {
		//Handle invalid position numbers that may be passed by invalid loop points
		positionNumber = (positionNumber > mod.positionCount - 1) ? 0 : positionNumber;	
		currentPosition = positionNumber;
		loadPattern(mod.positions[currentPosition]);
	}
	
	loadPosition(0);
	
	function getNextPosition() {
		if (currentPosition + 1 >= mod.positionCount) {
			loadPosition(mod.positionLoopPoint);
		} else {
			loadPosition(currentPosition + 1);
		}
	}
	
	function getNextRow() {
		/*
			Determine where we're gonna go based on active effect.
			Either:
				break (jump to new pattern),
				do extended loop,
				advance normally
		*/
		if (doBreak) {
			//Dxx commands at the end of modules are fairly common for some reason
			//so make sure jumping past the end loops back to the start
			breakPos = (breakPos >= mod.positionCount) ? mod.positionLoopPoint : breakPos;
			loadPosition(breakPos);
		} else if (exLoop && currentRow == exLoopEnd && exLoopCount > 0) {
			//count down the loop and jump back
			loadRow(exLoopStart);
			exLoopCount--;
		} else {
			if (currentRow == 63) {
				getNextPosition();
			} else {
				loadRow(currentRow + 1);
			}
		}
		
		if (exLoopCount < 0) { exLoop = false; }
	}

	function doFrame() {
		/* apply volume/pitch slide before fetching row, because the first frame of a row does NOT
		have the slide applied */

		for (var chan = 0; chan < mod.channelCount; chan++) {
			var channel = channels[chan];
			var finetune = channel.finetune;
			if (currentFrame == 0) { /* apply fine slides only once */
				channel.ticksPerSample += channel.finePeriodDelta * 2;
				channel.volume += channel.fineVolumeDelta;
			}
			channel.volume += channel.volumeDelta;
			if (channel.volume > 64) {
				channel.volume = 64;
			} else if (channel.volume < 0) {
				channel.volume = 0;
			}
			if (channel.cut !== false && currentFrame >= channel.cut) {
				channel.volume = 0;
			}
			if (channel.delay !== false && currentFrame <= channel.delay) {
				channel.volume = 0;
			}
			if (channel.retrigger !== false) {
				//short-circuit prevents x mod 0
				if (channel.retrigger == 0 || currentFrame % channel.retrigger == 0) { 
					channel.samplePosition = 0;
				}
			}
			channel.ticksPerSample += channel.periodDelta * 2;
			if (channel.tonePortaActive) {
				channel.ticksPerSample += channel.tonePortaDelta * 2;
				//don't slide below or above allowed note, depending on slide direction
				if (channel.tonePortaDir == 1 && channel.ticksPerSample > channel.tonePortaTarget * 2) {
					channel.ticksPerSample = channel.tonePortaTarget * 2;
				} else if (channel.tonePortaDir == -1 && channel.ticksPerSample < channel.tonePortaTarget * 2)  {
					channel.ticksPerSample = channel.tonePortaTarget * 2;
				}
			}
			
			if (channel.ticksPerSample > 4096) {
				channel.ticksPerSample = 4096;
			} else if (channel.ticksPerSample < 96) { /* equivalent to period 48, a bit higher than the highest note */
				channel.ticksPerSample = 96;
			}
			if (channel.arpeggioActive) {
				channel.arpeggioCounter++;
				var noteNumber = channel.arpeggioNotes[channel.arpeggioCounter % 3];
				channel.ticksPerSample = ModPeriodTable[finetune][noteNumber] * 2;
			}
		}

		currentFrame++;
		if (currentFrame == framesPerRow) {
			currentFrame = 0;
			//Don't advance to reading more rows if pattern delay effect is active
			if (delayRows !== false) {
				delayRows--;
				if (delayRows < 0) { delayRows = false; }
			} else {
				getNextRow();
			}
		}


	}
	
	this.getSamples = function(sampleCount) {
		samples = [];
		var i = 0;
		while (i < sampleCount) {
			ticksSinceStartOfFrame += ticksPerOutputSample;
			while (ticksSinceStartOfFrame >= ticksPerFrame) {
				doFrame();
				ticksSinceStartOfFrame -= ticksPerFrame;
			}
			
			leftOutputLevel = 0;
			rightOutputLevel = 0;
			for (var chan = 0; chan < mod.channelCount; chan++) {
				var channel = channels[chan];
				if (channel.playing) {
					channel.ticksSinceStartOfSample += ticksPerOutputSample;
					while (channel.ticksSinceStartOfSample >= channel.ticksPerSample) {
						channel.samplePosition++;
						if (channel.sample.repeatLength > 2 && channel.samplePosition >= channel.sample.repeatOffset + channel.sample.repeatLength) {
							channel.samplePosition = channel.sample.repeatOffset;
						} else if (channel.samplePosition >= channel.sample.length) {
							channel.playing = false;
							break;
						} else 
						channel.ticksSinceStartOfSample -= channel.ticksPerSample;
					}
					if (channel.playing) {
						
						var rawVol = mod.sampleData[channel.sampleNum][channel.samplePosition];
						var vol = (((rawVol + 128) & 0xff) - 128) * channel.volume; /* range (-128*64)..(127*64) */
						if (chan & 3 == 0 || chan & 3 == 3) { /* hard panning(?): left, right, right, left */
							leftOutputLevel += (vol + channel.pan) * 3;
							rightOutputLevel += (vol + 0xFF - channel.pan);
						} else {
							leftOutputLevel += (vol + 0xFF - channel.pan)
							rightOutputLevel += (vol + channel.pan) * 3;
						}
						/* range of outputlevels is 128*64*2*channelCount */
						/* (well, it could be more for odd channel counts) */
					}
				}
			}
			
			samples[i] = leftOutputLevel / (128 * 128 * mod.channelCount);
			samples[i+1] = rightOutputLevel / (128 * 128 * mod.channelCount);
			i += 2;
		}
		
		return samples;
	}
}

</script>
		<script type="text/javascript">
//Various helper functions


/*
	Creates a typed array (a view into an ArrayBuffer)
		Size is number of entries, not bytes
		Type is the kind of view
			can be "int8", "uint8", "int16", or "uint16"
			
	If unsupported (Opera) then it simply creates a normal array
*/

function TypedArray(size, type) {
	var multable = {int8: 1, uint8: 1, int16: 2, uint16: 2}
	var view;
	var supported = 
		(typeof ArrayBuffer !== "undefined") &&
		(typeof Int8Array !== "undefined") &&
		(typeof Int16Array !== "undefined") &&
		(typeof Uint8Array !== "undefined") &&
		(typeof Uint16Array !== "undefined");
		
	if (supported) {
		var buffer = new ArrayBuffer(size * multable[type]);
		switch (type) {
			case "int8": return new Int8Array(buffer); break;
			case "int16": return new Int16Array(buffer); break;
			case "uint8": return new Uint8Array(buffer); break;
			case "uint16": return new Uint16Array(buffer); break;
		}
	} else {
		return new Array(size);
	}

	return
	
}


</script>
		<script type="text/javascript">
/*
  Javascript port of CubicVR 3D engine for WebGL
  by Charles J. Cliffe
  http://www.cubicvr.org/

  May be used under the terms of the MIT license.
  http://www.opensource.org/licenses/mit-license.php
*/

/*globals alert: false */

(function(window, document, Math, nop, undef) {

  /** Global Constants **/
  var M_PI = Math.PI;
  var M_TWO_PI = 2.0 * Math.PI;
  var M_HALF_PI = Math.PI / 2.0;

  var SCRIPT_LOCATION = "";

  try {
    var scriptNodes = document.querySelectorAll("script");
    for (var i = 0, iMax = scriptNodes.length; i<iMax; i++) {
      var pos = scriptNodes[i].src.lastIndexOf('/CubicVR.js');
      if (pos > -1) {
        SCRIPT_LOCATION = scriptNodes[i].src.substr(0, pos) + "/";
      } //if
    }
  }
  catch(e) {
    // likely that 'document' is not defined (doesn't really matter)
  } //try

  var CubicVR = window['CubicVR'] = {};

  var GLCore = {
    canvas: null,
    width: null,
    height: null,
    fixed_aspect: 0.0,
    fixed_size: null,
    depth_alpha: false,
    default_filter: 1, // LINEAR_MIP
    mainloop: null,
    shadow_near: 0.1,
    shadow_far: 100,
    soft_shadow: false,
    resize_active: false,
    resizeList: []
  };
  var Materials = [];
  var Material_ref = [];
  var Textures = [];
  var Textures_obj = [];
  var Texture_ref = [];
  var Images = [];
  var ShaderPool = [];
  var MeshPool = [];

  var CoreShader_vs = null;
  var CoreShader_fs = null;

  var log;
  try {
    log = (console !== undefined && console.log) ?
      function(msg) { console.log("CubicVR Log: " + msg); } :
      function() {};
  }
  catch(e) {
    log = function() {};
  } //try

  var enums = {
    // Math
    math: {},

    frustum: {
      plane: {
        LEFT: 0,
        RIGHT: 1,
        TOP: 2,
        BOTTOM: 3,
        NEAR: 4,
        FAR: 5
      }
    },

    octree: {
      TOP_NW: 0,
      TOP_NE: 1,
      TOP_SE: 2,
      TOP_SW: 3,
      BOTTOM_NW: 4,
      BOTTOM_NE: 5,
      BOTTOM_SE: 6,
      BOTTOM_SW: 7
    },


    // Light Types
    light: {
      type: {
        NULL: 0,
        POINT: 1,
        DIRECTIONAL: 2,
        SPOT: 3,
        AREA: 4,
        DEPTH_PACK: 5,  // this lets us pass the shadow stage in as a light definition
        SPOT_SHADOW: 6,
        MAX: 7
      },
      method: {
        GLOBAL: 0,
        STATIC: 1,
        DYNAMIC: 2
      }
    },

    // Texture Types
    texture: {
      map: {
        COLOR: 0,
        ENVSPHERE: 1,
        NORMAL: 2,
        BUMP: 3,
        REFLECT: 4,
        SPECULAR: 5,
        AMBIENT: 6,
        ALPHA: 7,
        MAX: 8
      },
      filter: {
        LINEAR: 0,
        LINEAR_MIP: 1,
        NEAREST: 2,
        NEAREST_MIP: 3
      }
    },

    uv: {
      /* UV Axis enums */
      axis: {
        X: 0,
        Y: 1,
        Z: 2
      },

      /* UV Projection enums */
      projection: {
        UV: 0,
        PLANAR: 1,
        CYLINDRICAL: 2,
        SPHERICAL: 3,
        CUBIC: 4,
        SKY: 5
      }
    },

    // Shader Map Inputs (binary hash index)
    shader: {
      map: {
        COLOR: 1,
        SPECULAR: 2,
        NORMAL: 4,
        BUMP: 8,
        REFLECT: 16,
        ENVSPHERE: 32,
        AMBIENT: 64,
        ALPHA: 128
      },

      /* Uniform types */
      uniform: {
        MATRIX: 0,
        VECTOR: 1,
        FLOAT: 2,
        ARRAY_VERTEX: 3,
        ARRAY_UV: 4,
        ARRAY_FLOAT: 5,
        INT: 6
      }

    },

    motion: {
      POS: 0,
      ROT: 1,
      SCL: 2,
      FOV: 3,
      LENS: 4,
      NEARCLIP: 5,
      FARCLIP: 6,
      INTENSITY: 7,
      X: 0,
      Y: 1,
      Z: 2,
      V: 3
    },

    envelope: {
      shape: {
        TCB: 0,
        HERM: 1,
        BEZI: 2,
        LINE: 3,
        STEP: 4,
        BEZ2: 5
      },
      behavior: {
        RESET: 0,
        CONSTANT: 1,
        REPEAT: 2,
        OSCILLATE: 3,
        OFFSET: 4,
        LINEAR: 5
      }
    },

    /* Post Processing */
    post: {
      output: {
        REPLACE: 0,
        BLEND: 1,
        ADD: 2,
        ALPHACUT: 3
      }
    }
  };

  var cubicvr_identity = [1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0];

  /* Base functions */
  var vec2 = {
    equal: function(a, b) {
      var epsilon = 0.00000001;

      if ((a === undef) && (b === undef)) {
        return true;
      }
      if ((a === undef) || (b === undef)) {
        return false;
      }

      return (Math.abs(a[0] - b[0]) < epsilon && Math.abs(a[1] - b[1]) < epsilon);
    }
  };

  var vec3 = {
    length: function(pt) {
      return Math.sqrt(pt[0] * pt[0] + pt[1] * pt[1] + pt[2] * pt[2]);
    },
    normalize: function(pt) {
      var d = Math.sqrt((pt[0] * pt[0]) + (pt[1] * pt[1]) + (pt[2] * pt[2]));
      if (d === 0) {
        return [0, 0, 0];
      }
      return [pt[0] / d, pt[1] / d, pt[2] / d];
    },
    dot: function(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    },
    angle: function(v1, v2) {
      var a = Math.acos((v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]) / (Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]) * Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2])));

      return a;
    },
    cross: function(vectA, vectB) {
      return [
      vectA[1] * vectB[2] - vectB[1] * vectA[2], vectA[2] * vectB[0] - vectB[2] * vectA[0], vectA[0] * vectB[1] - vectB[0] * vectA[1]];
    },
    multiply: function(vectA, constB) {
      return [vectA[0] * constB, vectA[1] * constB, vectA[2] * constB];
    },
    add: function(vectA, vectB) {
      return [vectA[0] + vectB[0], vectA[1] + vectB[1], vectA[2] + vectB[2]];
    },
    subtract: function(vectA, vectB) {
      return [vectA[0] - vectB[0], vectA[1] - vectB[1], vectA[2] - vectB[2]];
    },
    equal: function(a, b) {
      var epsilon = 0.0000001;

      if ((a === undef) && (b === undef)) {
        return true;
      }
      if ((a === undef) || (b === undef)) {
        return false;
      }

      return (Math.abs(a[0] - b[0]) < epsilon && Math.abs(a[1] - b[1]) < epsilon && Math.abs(a[2] - b[2]) < epsilon);
    },
    moveViewRelative: function(position, target, xdelta, zdelta, alt_source) {
      var ang = Math.atan2(zdelta, xdelta);
      var cam_ang = Math.atan2(target[2] - position[2], target[0] - position[0]);
      var mag = Math.sqrt(xdelta * xdelta + zdelta * zdelta);

      var move_ang = cam_ang + ang + M_HALF_PI;

      if (typeof(alt_source) === 'object') {
        return [alt_source[0] + mag * Math.cos(move_ang), alt_source[1], alt_source[2] + mag * Math.sin(move_ang)];
      }

      return [position[0] + mag * Math.cos(move_ang), position[1], position[2] + mag * Math.sin(move_ang)];
    },
    trackTarget: function(position, target, trackingSpeed, safeDistance) {
      var camv = vec3.subtract(target, position);
      var dist = camv;
      var fdist = vec3.length(dist);
      var motionv = camv;

      motionv = vec3.normalize(motionv);
      motionv = vec3.multiply(motionv, trackingSpeed * (1.0 / (1.0 / (fdist - safeDistance))));

      var ret_pos;

      if (fdist > safeDistance) {
        ret_pos = vec3.add(position, motionv);
      } else if (fdist < safeDistance) {
        motionv = camv;
        motionv = vec3.normalize(motionv);
        motionv = vec3.multiply(motionv, trackingSpeed * (1.0 / (1.0 / (Math.abs(fdist - safeDistance)))));
        ret_pos = vec3.subtract(position, motionv);
      } else {
        ret_pos = [position[0], position[1] + motionv[2], position[2]];
      }

      return ret_pos;
    },
    get_closest_to: function(ptA, ptB, ptTest) {
      var S, T, U;

      S = vec3.subtract(ptB, ptA);
      T = vec3.subtract(ptTest, ptA);
      U = vec3.add(vec3.multiply(S, vec3.dot(S, T) / vec3.dot(S, S)), ptA);

      return U;
    }
  };

  var triangle = {
    normal: function(pt1, pt2, pt3) {
      
      var v10 = pt1[0] - pt2[0];
      var v11 = pt1[1] - pt2[1];
      var v12 = pt1[2] - pt2[2];
      var v20 = pt2[0] - pt3[0];
      var v21 = pt2[1] - pt3[1];
      var v22 = pt2[2] - pt3[2];
      
      return [v11 * v22 - v12 * v21, v12 * v20 - v10 * v22, v10 * v21 - v11 * v20];
    }
  };
  
  
  var mat3 = {
    transpose_inline: function(mat) {
        var a01 = mat[1], a02 = mat[2], a12 = mat[5];

        mat[1] = mat[3];
        mat[2] = mat[6];
        mat[3] = a01;
        mat[5] = mat[7];
        mat[6] = a02;
        mat[7] = a12;
    },
    vec3_multiply: function (m1, m2) {
        var mOut = [];


        mOut[0] = m2[0] * m1[0] + m2[3] * m1[1] + m2[6] * m1[2] ;
        mOut[1] = m2[1] * m1[0] + m2[4] * m1[1] + m2[7] * m1[2] ;
        mOut[2] = m2[2] * m1[0] + m2[5] * m1[1] + m2[8] * m1[2];

        return mOut;
    }
  }

  var mat4 = {
      lookat: function(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz) {
          var forward = [], side = [], up = [];
          var m = [];

          forward[0] = centerx - eyex;
          forward[1] = centery - eyey;
          forward[2] = centerz - eyez;

          up[0] = upx;
          up[1] = upy;
          up[2] = upz;

          forward = vec3.normalize(forward);

          /* Side = forward x up */
          var side = vec3.cross(forward, up);
          side = vec3.normalize(side);

          /* Recompute up as: up = side x forward */
          up = vec3.cross(side, forward);

          var m = [ side[0], up[0], -forward[0], 0, side[1], up[1], -forward[1], 0, side[2], up[2], -forward[2], 0, 0, 0, 0, 1];

          var t = new Transform(m);
          t.translate([-eyex,-eyey,-eyez]);

          return t.getResult();
      },
      multiply: function (m1, m2) {
          var mOut = [];

          mOut[0] = m2[0] * m1[0] + m2[4] * m1[1] + m2[8] * m1[2] + m2[12] * m1[3];
          mOut[1] = m2[1] * m1[0] + m2[5] * m1[1] + m2[9] * m1[2] + m2[13] * m1[3];
          mOut[2] = m2[2] * m1[0] + m2[6] * m1[1] + m2[10] * m1[2] + m2[14] * m1[3];
          mOut[3] = m2[3] * m1[0] + m2[7] * m1[1] + m2[11] * m1[2] + m2[15] * m1[3];
          mOut[4] = m2[0] * m1[4] + m2[4] * m1[5] + m2[8] * m1[6] + m2[12] * m1[7];
          mOut[5] = m2[1] * m1[4] + m2[5] * m1[5] + m2[9] * m1[6] + m2[13] * m1[7];
          mOut[6] = m2[2] * m1[4] + m2[6] * m1[5] + m2[10] * m1[6] + m2[14] * m1[7];
          mOut[7] = m2[3] * m1[4] + m2[7] * m1[5] + m2[11] * m1[6] + m2[15] * m1[7];
          mOut[8] = m2[0] * m1[8] + m2[4] * m1[9] + m2[8] * m1[10] + m2[12] * m1[11];
          mOut[9] = m2[1] * m1[8] + m2[5] * m1[9] + m2[9] * m1[10] + m2[13] * m1[11];
          mOut[10] = m2[2] * m1[8] + m2[6] * m1[9] + m2[10] * m1[10] + m2[14] * m1[11];
          mOut[11] = m2[3] * m1[8] + m2[7] * m1[9] + m2[11] * m1[10] + m2[15] * m1[11];
          mOut[12] = m2[0] * m1[12] + m2[4] * m1[13] + m2[8] * m1[14] + m2[12] * m1[15];
          mOut[13] = m2[1] * m1[12] + m2[5] * m1[13] + m2[9] * m1[14] + m2[13] * m1[15];
          mOut[14] = m2[2] * m1[12] + m2[6] * m1[13] + m2[10] * m1[14] + m2[14] * m1[15];
          mOut[15] = m2[3] * m1[12] + m2[7] * m1[13] + m2[11] * m1[14] + m2[15] * m1[15];

          return mOut;
      },
      vec4_multiply: function (m1, m2) {
          var mOut = [];

          mOut[0] = m2[0] * m1[0] + m2[4] * m1[1] + m2[8] * m1[2] + m2[12] * m1[3];
          mOut[1] = m2[1] * m1[0] + m2[5] * m1[1] + m2[9] * m1[2] + m2[13] * m1[3];
          mOut[2] = m2[2] * m1[0] + m2[6] * m1[1] + m2[10] * m1[2] + m2[14] * m1[3];
          mOut[3] = m2[3] * m1[0] + m2[7] * m1[1] + m2[11] * m1[2] + m2[15] * m1[3];

          return mOut;
      },
      vec3_multiply: function (m1, m2) {
          var mOut = [];

          mOut[0] = m2[0] * m1[0] + m2[4] * m1[1] + m2[8] * m1[2] + m2[12];
          mOut[1] = m2[1] * m1[0] + m2[5] * m1[1] + m2[9] * m1[2] + m2[13];
          mOut[2] = m2[2] * m1[0] + m2[6] * m1[1] + m2[10] * m1[2] + m2[14];

          return mOut;
      },
      perspective: function (fovy, aspect, near, far) {
          var yFac = Math.tan(fovy * M_PI / 360.0);
          var xFac = yFac * aspect;

          return [
          1.0 / xFac, 0, 0, 0, 0, 1.0 / yFac, 0, 0, 0, 0, -(far + near) / (far - near), -1, 0, 0, -(2.0 * far * near) / (far - near), 0];
      },
      ortho: function(left,right,bottom,top,near,far) {
        return [2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, -2 / (far - near), 0, -(left + right) / (right - left), -(top + bottom) / (top - bottom), -(far + near) / (far - near), 1];
      },
      determinant: function (m) {

          var a0 = m[0] * m[5] - m[1] * m[4];
          var a1 = m[0] * m[6] - m[2] * m[4];
          var a2 = m[0] * m[7] - m[3] * m[4];
          var a3 = m[1] * m[6] - m[2] * m[5];
          var a4 = m[1] * m[7] - m[3] * m[5];
          var a5 = m[2] * m[7] - m[3] * m[6];
          var b0 = m[8] * m[13] - m[9] * m[12];
          var b1 = m[8] * m[14] - m[10] * m[12];
          var b2 = m[8] * m[15] - m[11] * m[12];
          var b3 = m[9] * m[14] - m[10] * m[13];
          var b4 = m[9] * m[15] - m[11] * m[13];
          var b5 = m[10] * m[15] - m[11] * m[14];

          var det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

          return det;
      },
      coFactor: function (m, n, out) {
        // .. todo..
      },

      transpose: function (m) {
          return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
      },

      inverse_mat3: function(mat) {
          var dest = [];

          var a00 = mat[0], a01 = mat[1], a02 = mat[2],
          a10 = mat[4], a11 = mat[5], a12 = mat[6],
          a20 = mat[8], a21 = mat[9], a22 = mat[10];

          var b01 = a22*a11-a12*a21,
          b11 = -a22*a10+a12*a20,
          b21 = a21*a10-a11*a20;

          var d = a00*b01 + a01*b11 + a02*b21;
          if (!d) { return null; }
          var id = 1/d;

          dest[0] = b01*id;
          dest[1] = (-a22*a01 + a02*a21)*id;
          dest[2] = (a12*a01 - a02*a11)*id;
          dest[3] = b11*id;
          dest[4] = (a22*a00 - a02*a20)*id;
          dest[5] = (-a12*a00 + a02*a10)*id;
          dest[6] = b21*id;
          dest[7] = (-a21*a00 + a01*a20)*id;
          dest[8] = (a11*a00 - a01*a10)*id;

          return dest;
      },

      // not sure which is faster yet..
      
      inverse$1: function (m) {
          var tmp = [];
          var src = [];
          var dst = [];  

          // Transpose matrix
          for (var i = 0; i < 4; i++) {
            src[i +  0] = m[i*4 + 0];
            src[i +  4] = m[i*4 + 1];
            src[i +  8] = m[i*4 + 2];
            src[i + 12] = m[i*4 + 3];
          }

          // Calculate pairs for first 8 elements (cofactors) 
          tmp[0] = src[10] * src[15];
          tmp[1] = src[11] * src[14];
          tmp[2] = src[9]  * src[15];
          tmp[3] = src[11] * src[13];
          tmp[4] = src[9]  * src[14];
          tmp[5] = src[10] * src[13];
          tmp[6] = src[8]  * src[15];
          tmp[7] = src[11] * src[12];
          tmp[8] = src[8]  * src[14];
          tmp[9] = src[10] * src[12];
          tmp[10] = src[8] * src[13];
          tmp[11] = src[9] * src[12];

          // Calculate first 8 elements (cofactors)
          dst[0]  = tmp[0]*src[5] + tmp[3]*src[6] + tmp[4]*src[7];
          dst[0] -= tmp[1]*src[5] + tmp[2]*src[6] + tmp[5]*src[7];
          dst[1]  = tmp[1]*src[4] + tmp[6]*src[6] + tmp[9]*src[7];
          dst[1] -= tmp[0]*src[4] + tmp[7]*src[6] + tmp[8]*src[7];
          dst[2]  = tmp[2]*src[4] + tmp[7]*src[5] + tmp[10]*src[7];
          dst[2] -= tmp[3]*src[4] + tmp[6]*src[5] + tmp[11]*src[7];
          dst[3]  = tmp[5]*src[4] + tmp[8]*src[5] + tmp[11]*src[6];
          dst[3] -= tmp[4]*src[4] + tmp[9]*src[5] + tmp[10]*src[6];
          dst[4]  = tmp[1]*src[1] + tmp[2]*src[2] + tmp[5]*src[3];
          dst[4] -= tmp[0]*src[1] + tmp[3]*src[2] + tmp[4]*src[3];
          dst[5]  = tmp[0]*src[0] + tmp[7]*src[2] + tmp[8]*src[3];
          dst[5] -= tmp[1]*src[0] + tmp[6]*src[2] + tmp[9]*src[3];
          dst[6]  = tmp[3]*src[0] + tmp[6]*src[1] + tmp[11]*src[3];
          dst[6] -= tmp[2]*src[0] + tmp[7]*src[1] + tmp[10]*src[3];
          dst[7]  = tmp[4]*src[0] + tmp[9]*src[1] + tmp[10]*src[2];
          dst[7] -= tmp[5]*src[0] + tmp[8]*src[1] + tmp[11]*src[2];

          // Calculate pairs for second 8 elements (cofactors)
          tmp[0]  = src[2]*src[7];
          tmp[1]  = src[3]*src[6];
          tmp[2]  = src[1]*src[7];
          tmp[3]  = src[3]*src[5];
          tmp[4]  = src[1]*src[6];
          tmp[5]  = src[2]*src[5];
          tmp[6]  = src[0]*src[7];
          tmp[7]  = src[3]*src[4];
          tmp[8]  = src[0]*src[6];
          tmp[9]  = src[2]*src[4];
          tmp[10] = src[0]*src[5];
          tmp[11] = src[1]*src[4];

          // Calculate second 8 elements (cofactors)
          dst[8]   = tmp[0] * src[13]  + tmp[3] * src[14]  + tmp[4] * src[15];
          dst[8]  -= tmp[1] * src[13]  + tmp[2] * src[14]  + tmp[5] * src[15];
          dst[9]   = tmp[1] * src[12]  + tmp[6] * src[14]  + tmp[9] * src[15];
          dst[9]  -= tmp[0] * src[12]  + tmp[7] * src[14]  + tmp[8] * src[15];
          dst[10]  = tmp[2] * src[12]  + tmp[7] * src[13]  + tmp[10]* src[15];
          dst[10] -= tmp[3] * src[12]  + tmp[6] * src[13]  + tmp[11]* src[15];
          dst[11]  = tmp[5] * src[12]  + tmp[8] * src[13]  + tmp[11]* src[14];
          dst[11] -= tmp[4] * src[12]  + tmp[9] * src[13]  + tmp[10]* src[14];
          dst[12]  = tmp[2] * src[10]  + tmp[5] * src[11]  + tmp[1] * src[9];
          dst[12] -= tmp[4] * src[11]  + tmp[0] * src[9]   + tmp[3] * src[10];
          dst[13]  = tmp[8] * src[11]  + tmp[0] * src[8]   + tmp[7] * src[10];
          dst[13] -= tmp[6] * src[10]  + tmp[9] * src[11]  + tmp[1] * src[8];
          dst[14]  = tmp[6] * src[9]   + tmp[11]* src[11]  + tmp[3] * src[8];
          dst[14] -= tmp[10]* src[11 ] + tmp[2] * src[8]   + tmp[7] * src[9];
          dst[15]  = tmp[10]* src[10]  + tmp[4] * src[8]   + tmp[9] * src[9];
          dst[15] -= tmp[8] * src[9]   + tmp[11]* src[10]  + tmp[5] * src[8];

          // Calculate determinant
          var det = src[0]*dst[0] + src[1]*dst[1] + src[2]*dst[2] + src[3]*dst[3];
          
          var ret = [];

          // Calculate matrix inverse
          det = 1.0 / det;
          for (var i = 0; i < 16; i++) {
            ret[i] = dst[i] * det;
          }
            
            return ret;
      },

      inverse$2: function (m) {
        var inv = [];

        inv[0] =   m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15]
        + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10];
        inv[4] =  -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15]
        - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10];
        inv[8] =   m[4]*m[9]*m[15] - m[4]*m[11]*m[13] - m[8]*m[5]*m[15]
        + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9];
        inv[12] = -m[4]*m[9]*m[14] + m[4]*m[10]*m[13] + m[8]*m[5]*m[14]
        - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9];
        inv[1] =  -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15]
        - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10];
        inv[5] =   m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15]
        + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10];
        inv[9] =  -m[0]*m[9]*m[15] + m[0]*m[11]*m[13] + m[8]*m[1]*m[15]
        - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9];
        inv[13] =  m[0]*m[9]*m[14] - m[0]*m[10]*m[13] - m[8]*m[1]*m[14]
        + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9];
        inv[2] =   m[1]*m[6]*m[15] - m[1]*m[7]*m[14] - m[5]*m[2]*m[15]
        + m[5]*m[3]*m[14] + m[13]*m[2]*m[7] - m[13]*m[3]*m[6];
        inv[6] =  -m[0]*m[6]*m[15] + m[0]*m[7]*m[14] + m[4]*m[2]*m[15]
        - m[4]*m[3]*m[14] - m[12]*m[2]*m[7] + m[12]*m[3]*m[6];
        inv[10] =  m[0]*m[5]*m[15] - m[0]*m[7]*m[13] - m[4]*m[1]*m[15]
        + m[4]*m[3]*m[13] + m[12]*m[1]*m[7] - m[12]*m[3]*m[5];
        inv[14] = -m[0]*m[5]*m[14] + m[0]*m[6]*m[13] + m[4]*m[1]*m[14]
        - m[4]*m[2]*m[13] - m[12]*m[1]*m[6] + m[12]*m[2]*m[5];
        inv[3] =  -m[1]*m[6]*m[11] + m[1]*m[7]*m[10] + m[5]*m[2]*m[11]
        - m[5]*m[3]*m[10] - m[9]*m[2]*m[7] + m[9]*m[3]*m[6];
        inv[7] =   m[0]*m[6]*m[11] - m[0]*m[7]*m[10] - m[4]*m[2]*m[11]
        + m[4]*m[3]*m[10] + m[8]*m[2]*m[7] - m[8]*m[3]*m[6];
        inv[11] = -m[0]*m[5]*m[11] + m[0]*m[7]*m[9] + m[4]*m[1]*m[11]
        - m[4]*m[3]*m[9] - m[8]*m[1]*m[7] + m[8]*m[3]*m[5];
        inv[15] =  m[0]*m[5]*m[10] - m[0]*m[6]*m[9] - m[4]*m[1]*m[10]
        + m[4]*m[2]*m[9] + m[8]*m[1]*m[6] - m[8]*m[2]*m[5];

        det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];

        if (det == 0) return null;

        inverse_det = 1.0 / det;

        inv[0] *= inverse_det;
        inv[1] *= inverse_det;
        inv[2] *= inverse_det;
        inv[3] *= inverse_det;
        inv[4] *= inverse_det;
        inv[5] *= inverse_det;
        inv[6] *= inverse_det;
        inv[7] *= inverse_det;
        inv[8] *= inverse_det;
        inv[9] *= inverse_det;
        inv[10] *= inverse_det;
        inv[11] *= inverse_det;
        inv[12] *= inverse_det;
        inv[13] *= inverse_det;
        inv[14] *= inverse_det;
        inv[15] *= inverse_det;

        return inv;
      },
      
      inverse: function (m) {
          var a0 = m[0] * m[5] - m[1] * m[4];
          var a1 = m[0] * m[6] - m[2] * m[4];
          var a2 = m[0] * m[7] - m[3] * m[4];
          var a3 = m[1] * m[6] - m[2] * m[5];
          var a4 = m[1] * m[7] - m[3] * m[5];
          var a5 = m[2] * m[7] - m[3] * m[6];
          var b0 = m[8] * m[13] - m[9] * m[12];
          var b1 = m[8] * m[14] - m[10] * m[12];
          var b2 = m[8] * m[15] - m[11] * m[12];
          var b3 = m[9] * m[14] - m[10] * m[13];
          var b4 = m[9] * m[15] - m[11] * m[13];
          var b5 = m[10] * m[15] - m[11] * m[14];

          var determinant = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

          if (determinant != 0) {
              var m_inv = [];
              m_inv[0] = 0 + m[5] * b5 - m[6] * b4 + m[7] * b3;
              m_inv[4] = 0 - m[4] * b5 + m[6] * b2 - m[7] * b1;
              m_inv[8] = 0 + m[4] * b4 - m[5] * b2 + m[7] * b0;
              m_inv[12] = 0 - m[4] * b3 + m[5] * b1 - m[6] * b0;
              m_inv[1] = 0 - m[1] * b5 + m[2] * b4 - m[3] * b3;
              m_inv[5] = 0 + m[0] * b5 - m[2] * b2 + m[3] * b1;
              m_inv[9] = 0 - m[0] * b4 + m[1] * b2 - m[3] * b0;
              m_inv[13] = 0 + m[0] * b3 - m[1] * b1 + m[2] * b0;
              m_inv[2] = 0 + m[13] * a5 - m[14] * a4 + m[15] * a3;
              m_inv[6] = 0 - m[12] * a5 + m[14] * a2 - m[15] * a1;
              m_inv[10] = 0 + m[12] * a4 - m[13] * a2 + m[15] * a0;
              m_inv[14] = 0 - m[12] * a3 + m[13] * a1 - m[14] * a0;
              m_inv[3] = 0 - m[9] * a5 + m[10] * a4 - m[11] * a3;
              m_inv[7] = 0 + m[8] * a5 - m[10] * a2 + m[11] * a1;
              m_inv[11] = 0 - m[8] * a4 + m[9] * a2 - m[11] * a0;
              m_inv[15] = 0 + m[8] * a3 - m[9] * a1 + m[10] * a0;

              var inverse_det = 1.0 / determinant;

              m_inv[0] *= inverse_det;
              m_inv[1] *= inverse_det;
              m_inv[2] *= inverse_det;
              m_inv[3] *= inverse_det;
              m_inv[4] *= inverse_det;
              m_inv[5] *= inverse_det;
              m_inv[6] *= inverse_det;
              m_inv[7] *= inverse_det;
              m_inv[8] *= inverse_det;
              m_inv[9] *= inverse_det;
              m_inv[10] *= inverse_det;
              m_inv[11] *= inverse_det;
              m_inv[12] *= inverse_det;
              m_inv[13] *= inverse_det;
              m_inv[14] *= inverse_det;
              m_inv[15] *= inverse_det;

              return m_inv;
          }

          return null; 
      }
  };
  
  var util = {
    getScriptContents: function(id) {
      var shaderScript = document.getElementById(id);

      var str = "";
      var srcUrl = "";

      if (!shaderScript) {
        srcUrl = id;
      } else {
        if (shaderScript.src !== "" || shaderScript.attributes['srcUrl'] !== undef) {
          srcUrl = (shaderScript.src !== '') ? shaderScript.src : (shaderScript.attributes['srcUrl'].value);
        }
      }

      if (srcUrl.length !== 0) {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open('GET', srcUrl, false);
        xmlHttp.send(null);

        if (xmlHttp.status === 200 || xmlHttp.status === 0) {
          str = xmlHttp.responseText;
        }
      } else {
        var k = shaderScript.firstChild;
        while (k) {
          if (k.nodeType === 3) {
            str += k.textContent;
          }
          k = k.nextSibling;
        }
      }

      return str;
    },
    getURL: function(srcUrl) {
      try {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open('GET', srcUrl, false);
        xmlHttp.send(null);

        if (xmlHttp.status === 200 || xmlHttp.status === 0) {
          if (xmlHttp.responseText.length) {
            return xmlHttp.responseText;
          } else if (xmlHttp.responseXML) {
            return xmlHttp.responseXML;
          }
        }
      }
      catch(e) {
        alert(srcUrl + " failed to load.");
      }


      return null;
    },
    getXML: function(srcUrl) {
      try {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open('GET', srcUrl, false);
        xmlHttp.overrideMimeType("application/xml");
        xmlHttp.send(null);

        if (xmlHttp.status === 200 || xmlHttp.status === 0) {
          return xmlHttp.responseXML;
        }
      }
      catch(e) {
        try {
          alert(srcUrl + " failed to load.");
        }
        catch (ex) {
          throw(e);
        }
      }


      return null;
    },
    repackArray: function(data, stride, count) {
      if (data.length !== parseInt(stride, 10) * parseInt(count, 10)) {
        log("array repack error, data size !== stride*count: data.length=" +
            data.length + " stride=" + stride + " count=" + count);
      }

      var returnData = [];

      var c = 0;
      for (var i = 0, iMax = data.length; i < iMax; i++) {
        var ims = i % stride;

        if (ims === 0) {
          returnData[c] = [];
        }

        returnData[c][ims] = data[i];

        if (ims === stride - 1) {
          c++;
        }
      }

      return returnData;
    },
    collectTextNode: function(tn) {
      if (!tn) {
        return "";
      }

      var s = "";
      var textNodeChildren = tn.childNodes;
      for (var i = 0, tnl = textNodeChildren.length; i < tnl; i++) {
        s += textNodeChildren[i].nodeValue;
      }
      return s;
    },
    floatDelimArray: function(float_str, delim) {
//      if (!float_str) return [];
      var fa = float_str.split(delim ? delim : ",");
      for (var i = 0, imax = fa.length; i < imax; i++) {
        fa[i] = parseFloat(fa[i]);
      }
      if (fa[fa.length - 1] !== fa[fa.length - 1]) {
        fa.pop();
      }
      return fa;
    },
    intDelimArray: function(float_str, delim) {
//      if (!float_str) return [];
      var fa = float_str.split(delim ? delim : ",");
      for (var i = 0, imax = fa.length; i < imax; i++) {
        fa[i] = parseInt(fa[i], 10);
      }
      if (fa[fa.length - 1] !== fa[fa.length - 1]) {
        fa.pop();
      }
      return fa;
    },
    textDelimArray: function(text_str, delim) {
//      if (!text_str) return "";
      var fa = text_str.split(delim ? delim : ",");
      for (var i = 0, imax = fa.length; i < imax; i++) {
        fa[i] = fa[i];
      }
      return fa;
    }
  };


  var MAX_LIGHTS=6;


  /* Core Init, single context only at the moment */
  GLCore.init = function(gl_in, vs_in, fs_in) {
    var gl;

    if (vs_in && fs_in) {
      vs_in = util.getScriptContents(vs_in);
      fs_in = util.getScriptContents(fs_in);
    } else {  // default shader handler if no custom override specified
      // See if they have been embeded in js
      if (CubicVR.CubicVRCoreVS && CubicVR.CubicVRCoreFS) {
        vs_in = CubicVR.CubicVRCoreVS;
        fs_in = CubicVR.CubicVRCoreFS;
      } else {
        vs_in = util.getScriptContents(SCRIPT_LOCATION + "CubicVR_Core.vs");
        fs_in = util.getScriptContents(SCRIPT_LOCATION + "CubicVR_Core.fs");
      }
    }

    if (gl_in === undef) {  // no canvas? no problem!
      gl_in = document.createElement("canvas");
      if (!gl) gl = gl_in.getContext("experimental-webgl");
      GLCore.gl = gl;
      
      if (GLCore.fixed_size !== null) {
        GLCore.width = GLCore.fixed_size[0];
        GLCore.height = GLCore.fixed_size[1];
        GLCore.resizeElement(gl_in,GLCore.width,GLCore.height);
      } else {
        gl_in.style.position = "absolute";        
        // document.body.style.margin = "0px";        
        // document.body.style.padding = "0px";        
        GLCore.addResizeable(gl_in);
        GLCore.resizeElement(gl_in,window.innerWidth,window.innerHeight);
      }
      
      document.body.appendChild(gl_in);
    }
    
    if (gl_in.getContext !== undef && gl_in.width !== undef && gl_in.height !== undef)
    {
      try {
            if (!gl) gl = gl_in.getContext("experimental-webgl");
            gl.viewport(0, 0, gl_in.width, gl_in.height);
            GLCore.canvas = gl_in;
            GLCore.width = gl_in.width;
            GLCore.height = gl_in.height;
            
            // set these default, can always be easily over-ridden
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);            
      } catch (e) {}
      
      if (!gl) {
//         alert("Could not initialise WebGL, sorry :-(");
         return null;
      }
    }
    else
    {
      gl = gl_in;      
    }

    GLCore.gl = gl;
    GLCore.CoreShader_vs = vs_in;
    GLCore.CoreShader_fs = fs_in;

    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);

    for (var i = enums.light.type.NULL; i < enums.light.type.MAX; i++) {
      ShaderPool[i] = [];
    }

    var dummyTex = new CubicVR.Texture();
    var lightTest = new CubicVR.Material();

    for (var i = 0; i < enums.texture.map.MAX; i++) {
      if (i===enums.texture.map.BUMP) continue; // fix for crashy fglrx driver, todo: check it against newer revisions.
      lightTest.setTexture(dummyTex,i);
    }
    lightTest.opacity = 0.5;

    var lc = 1;
    
    try {
      while (1) {
        lightTest.use(enums.light.type.POINT,lc);
        if (lc === 8) {
          MAX_LIGHTS=lc;      
          break;
        }
        lc++;
      }
    } catch (e) {
      MAX_LIGHTS=lc;      
      // console.log(e);
    }

    log("Calibrated maximum lights per pass to: "+lc);
    

    for (var i = enums.light.type.NULL; i < enums.light.type.MAX; i++) {
      ShaderPool[i] = [];
    }
    
    if (GLCore.resizeList.length) {
      window.addEventListener('resize',  function()  { CubicVR.GLCore.onResize(); }, false);
      GLCore.resize_active = true;
    }
    
    return gl;
  };
  
  GLCore.addResizeable = function(e) {
    CubicVR.GLCore.resizeList.push(e);
  }
  
  GLCore.onResize = function() {
    var w = window.innerWidth;
    var h = window.innerHeight; 
    
    if (GLCore.fixed_size !== null) {
      w = CubicVR.GLCore.fixed_size[0];
      h = CubicVR.GLCore.fixed_size[1];
    }
    
    for (var i = 0, iMax = CubicVR.GLCore.resizeList.length; i < iMax; i++) {
      GLCore.resizeElement(CubicVR.GLCore.resizeList[i],w,h);
    }    
  }
  
  GLCore.setFixedAspect = function(fa_in) {
    CubicVR.GLCore.fixed_aspect = fa_in;
  }
  
  GLCore.setFixedSize = function(fs_width, fs_height) {
    CubicVR.GLCore.fixed_size = [fs_width,fs_height];
  }
  
  GLCore.getCanvas = function() {
    return CubicVR.GLCore.canvas;
  }

  GLCore.resizeElement = function(e,width,height) {
    var gl = GLCore.gl;

    if (GLCore.fixed_aspect !== 0.0) {
  		var aspect_height = width*(1.0/CubicVR.GLCore.fixed_aspect);
  		if (aspect_height > height) { 
  		  aspect_height = height;
  		  width = height*CubicVR.GLCore.fixed_aspect;
		  }
		  height = aspect_height;
    }
    
    if (e.getContext !== undef) {
      e.width = width;
      e.height = height;
      
      if (!CubicVR.GLCore.fixed_size) {
        e.style.left = parseInt(window.innerWidth/2.0-width/2.0)+"px";
        e.style.top = parseInt(window.innerHeight/2.0-height/2.0)+"px";
      } 
            
      gl.viewport(0, 0, width, height);          
    } else {
      e.resize(width,height);
    }
  }

  GLCore.setDepthAlpha = function(da, near, far) {
    GLCore.depth_alpha = da;
    GLCore.depth_alpha_near = near;
    GLCore.depth_alpha_far = far;
  };

  GLCore.setDefaultFilter = function(filterType) {
    GLCore.default_filter = filterType;
  };

  GLCore.setSoftShadows = function(bSoft) {
    GLCore.soft_shadow = bSoft;
  }
  

  var cubicvr_compileShader = function(gl, str, type) {
    var shader;

    if (type === "x-shader/x-fragment") {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (type === "x-shader/x-vertex") {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      log(gl.getShaderInfoLog(shader));
      return null;
    }

    return shader;
  };

  var cubicvr_getShader = function(gl, id) {
    var shaderScript = document.getElementById(id);

    if (!shaderScript) {
      return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
      if (k.nodeType === 3) {
        str += k.textContent;
      }
      k = k.nextSibling;
    }

    var shader;

    if (shaderScript.type === "x-shader/x-fragment") {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type === "x-shader/x-vertex") {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      log(gl.getShaderInfoLog(shader));
//      return null;
    }

    return shader;
  };

  /*****************************************************************************
   * Workers
   *****************************************************************************/

  function CubicVR_Worker(settings) {
    this.worker = new Worker(SCRIPT_LOCATION + "CubicVR.js");
    this.message = settings.message;
    this.error = settings.error;
    this.type = settings.type;
    var that = this;
    this.worker.onmessage = function(e) {
      if (that.message) {
        that.message(e.data);
      } //if
    };
    this.worker.onerror = function(e) {
      if (that.error) {
        that.error(e);
      } else {
        log("Error: " + e.message + ": " + e.lineno);
      } //if
    }; //onerror
    this.fn = function(fn, options) {
      that.worker.postMessage({
        message: "function",
        data: fn,
        options: options
      });
    };
    this.start = function(options) {
      that.worker.postMessage({
        message: "start",
        data: that.type,
        options: options
      });
    };
    this.init = function(data) {
      that.send({message:'init', data:data});
    };
    this.stop = function() {
      that.worker.postMessage({
        message: "stop",
        data: null
      });
    };
    this.send = function(message) {
      that.worker.postMessage({
        message: "data",
        data: message
      });
    };
  }; //CubicVR_Worker::Constructor 

  function CubicVR_TestWorker() {
    var that = this;
    this.onmessage = function(message) {
      if (message.test) {
        setTimeout(function(){postMessage(message.test);}, 1000);
      }
      else {
        setTimeout(function(){throw new Error(message);}, 1000);
      } //if
    }; //onmessage
  }; //CubicVR_TestWorker

  function CubicVR_ColladaLoadWorker() {
    var that = this;
    this.onmessage = function(message) {
    }; //onmessage
  }; //CubicVR_ColladaLoadWorker

  function CubicVR_WorkerConnection() {
    this.listener = null;
  } //CubicVR_WorkerConnection
  var WorkerConnection = new CubicVR_WorkerConnection();

  if (1) {
    self.addEventListener('message', function(e) {
      var message = e.data.message;
      var type = e.data.data;
      if (message === "start") {
        if (type === "test") {
          WorkerConnection.listener = new CubicVR_TestWorker();
        }
        else if (type === "load_collada") {
          WorkerConnection.listener = new CubicVR_ColladaLoadWorker();
        }
        else if (type === "octree") {
          WorkerConnection.listener = new CubicVR_OctreeWorker();
        } //if
      }
      else if (message === "function") {
        var data = e.data.data;
        var options = e.data.options;
        var parts = data.split('(');
        if (parts.length > 1 && parts[1].indexOf(')') > -1) {
          var prefix = parts[0];
          var suffix = parts[1].substr(0,parts[1].length-1);
          var args = options || suffix.split(',');
          var chain = prefix.split('.');
          var fn = CubicVR;
          for (var i=0; i<chain.length; ++i) {
            fn = fn[chain[i]];
          } //for
          if (fn && typeof fn === 'function') {
            var ret = fn.apply(fn, args);
            postMessage(ret);
          } //if
        }
        else {
          throw new Error('Worker command not formatted properly.');
        } //if
      }
      else if (message === "data") {
        if (WorkerConnection.listener !== null) {
          var data = e.data ? e.data.data : null;
          WorkerConnection.listener.onmessage(e.data.data);
        } //if
      }
      else if (message === "stop") {
        if (WorkerConnection.listener !== null && WorkerConnection.listener.stop) {
          WorkerConnection.listener.stop();
        } //if
      } //if
    }, false);
  } //if

  /* Timer */

  function Timer() {
      this.time_elapsed = 0;
      this.system_milliseconds = 0;
      this.start_time = 0;
      this.end_time = 0;
      this.last_update = 0;
      this.paused_time = 0;
      this.offset = 0;
      this.paused_state = 0;
  }


  Timer.prototype.start = function () {
      this.update();
      this.num_updates = 0;
      this.start_time = this.system_milliseconds;
      this.last_update = this.start_time;
      this.paused_state = false;
      this.lock_state = false;
      this.lock_rate = 0;
      this.paused_time = 0;
      this.offset = 0;
  }


  Timer.prototype.stop = function () {
      this.end_time = this.system_milliseconds;
  }


  Timer.prototype.reset = function () {
      this.start();
  }


  Timer.prototype.lockFramerate = function (f_rate) {
      this.lock_rate = 1.0 / this.f_rate;
      this.lock_state = true;
  }


  Timer.prototype.unlock = function () {
      var msec_tmp = this.system_milliseconds;
      this.lock_state = false;
      this.update();
      this.last_update = this.system_milliseconds - this.lock_rate;
      this.offset += msec_tmp - this.system_milliseconds;
      this.lock_rate = 0;
  }

  Timer.prototype.locked = function () {
      return this.lock_state;
  }

  Timer.prototype.update = function () {
      this.num_updates++;
      this.last_update = this.system_milliseconds;

      if (this.lock_state) {
          this.system_milliseconds += parseInt(lock_rate * 1000);
      } else {
          this.system_milliseconds = (new Date()).getTime();
      }


      if (this.paused_state) this.paused_time += this.system_milliseconds - this.last_update;

      this.time_elapsed = this.system_milliseconds - this.start_time - this.paused_time + this.offset;
  }


  Timer.prototype.getMilliseconds = function () {
      return this.time_elapsed;
  }



  Timer.prototype.getSeconds = function () {
      return this.getMilliseconds() / 1000.0;
  }


  Timer.prototype.setMilliseconds = function (milliseconds_in) {
      this.offset -= (this.system_milliseconds - this.start_time - this.paused_time + this.offset) - milliseconds_in;
  }



  Timer.prototype.setSeconds = function (seconds_in) {
      this.setMilliseconds(parseInt(seconds_in * 1000.0));
  }


  Timer.prototype.getLastUpdateSeconds = function () {
      return this.getLastUpdateMilliseconds() / 1000.0;
  }


  Timer.prototype.getLastUpdateMilliseconds = function () {
      return this.system_milliseconds - this.last_update;
  }

  Timer.prototype.getTotalMilliseconds = function () {
      return this.system_milliseconds - this.start_time;
  }


  Timer.prototype.getTotalSeconds = function () {
      return this.getTotalMilliseconds() / 1000.0;
  }


  Timer.prototype.getNumUpdates = function () {
      return this.num_updates;
  }


  Timer.prototype.setPaused = function (pause_in) {
      this.paused_state = pause_in;
  }

  Timer.prototype.getPaused = function () {
      return this.paused_state;
  }
  
  
  /* Run-Loop Controller */
   
  function MainLoopRequest()
  {
 
    var gl = GLCore.gl;

    if (CubicVR.GLCore.mainloop === null) return;
    
    if (window.requestAnimationFrame) {
      window.requestAnimationFrame(MainLoopRequest);
    }

    CubicVR.GLCore.mainloop.interval();
  }

  function setMainLoop(ml)
  {
    CubicVR.GLCore.mainloop=ml;
  }
  
  function MainLoop(mlfunc,doclear)
  {
    if (window.requestAnimationFrame === undef) {      
      window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || null;
    }
    
    if (CubicVR.GLCore.mainloop !== null)
    {
      // kill old mainloop
      
      if (!(window.requestAnimationFrame) && CubicVR.GLCore.mainloop)
      {
        clearInterval(CubicVR.GLCore.mainloop.interval);
      }
      
      CubicVR.GLCore.mainloop = null;
    }
    
    if (mlfunc === null)
    {
      CubicVR.GLCore.mainloop = null;
      return;
    }
    
    var timer = new Timer();
    timer.start();

    this.timer = timer;
    this.func = mlfunc;
    this.doclear = (doclear!==undef)?doclear:true;
    CubicVR.GLCore.mainloop = this;
    
    if (GLCore.resizeList.length && !CubicVR.GLCore.resize_active) {
      window.addEventListener('resize',  function()  { CubicVR.GLCore.onResize(); }, false);
      CubicVR.GLCore.resize_active = true;
    }
    
    var loopFunc = function() { return function() { 
      var gl = CubicVR.GLCore.gl;
      timer.update(); 
      if (CubicVR.GLCore.mainloop.doclear) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      mlfunc(timer,CubicVR.GLCore.gl); 
    }; }();
  
    if (window.requestAnimationFrame) {
          loopFunc();
          this.interval = loopFunc;
          window.requestAnimationFrame(MainLoopRequest);
      } else { 
        this.interval = setInterval(loopFunc, 20);
      }    
  }

  MainLoop.prototype.setPaused = function(state) {
    this.timer.setPaused(state);
  };

  MainLoop.prototype.getPaused = function() {
    return this.timer.getPaused();
  };

  MainLoop.prototype.setTimerSeconds = function(time_in) {
    this.timer.setSeconds(time_in);
  };


  MainLoop.prototype.getTimerSeconds = function() {
    return this.timer.getSeconds();
  };
  

  MainLoop.prototype.resetTimer = function() {
    this.timer.reset();
  };
  
  
  /* Simple Orbital View Controller */
  function MouseViewController(canvas,cam_in)
  {    
    this.canvas = canvas;
    this.camera = cam_in;    
    this.mpos = [0,0]
    this.mdown = false;
        
    var ctx = this;    
                
    this.onMouseDown = function () { return function (ev)
    {
      ctx.mdown = true;
      ctx.mpos = [ev.pageX-ev.target.offsetLeft,ev.pageY-ev.target.offsetTop];
    } }();

    this.onMouseUp = function () { return function (ev)
    {
      ctx.mdown = false;
      ctx.mpos = [ev.pageX-ev.target.offsetLeft,ev.pageY-ev.target.offsetTop];
    }  }();

    this.onMouseMove = function () { return function (ev)
    {
      var mdelta = [];

      var npos = [ev.pageX-ev.target.offsetLeft,ev.pageY-ev.target.offsetTop];

      mdelta[0] = ctx.mpos[0]-npos[0];
      mdelta[1] = ctx.mpos[1]-npos[1];

      ctx.mpos = npos;
//      ctx.mpos = [ev.clientX,ev.clientY];
      if (!ctx.mdown) return;

      var dv = vec3.subtract(ctx.camera.target,ctx.camera.position);
      var dist = vec3.length(dv);

      ctx.camera.position = vec3.moveViewRelative(ctx.camera.position,ctx.camera.target,dist*mdelta[0]/300.0,0);
      ctx.camera.position[1] -= dist*mdelta[1]/300.0;
      
      ctx.camera.position = vec3.add(ctx.camera.target,vec3.multiply(vec3.normalize(vec3.subtract(ctx.camera.position,ctx.camera.target)),dist));
    } }();

    this.onMouseWheel = function() { return function (ev)
    {
      var delta = ev.wheelDelta?ev.wheelDelta:(-ev.detail*10.0);

      var dv = vec3.subtract(ctx.camera.target,ctx.camera.position);
      var dist = vec3.length(dv);

      dist -= delta/1000.0;
      
      if (dist < 0.1) dist = 0.1;
      if (dist > 1000) dist = 1000;
      // if (camDist > 20.0) camDist = 20.0;

      ctx.camera.position = vec3.add(ctx.camera.target,vec3.multiply(vec3.normalize(vec3.subtract(ctx.camera.position,ctx.camera.target)),dist));
    } }();
    
    this.bind();
  }  
  
  MouseViewController.prototype.bind = function() {
    this.canvas.addEventListener('mousemove', this.onMouseMove, false);
    this.canvas.addEventListener('mousedown', this.onMouseDown, false);
    this.canvas.addEventListener('mouseup', this.onMouseUp, false);
    this.canvas.addEventListener('mousewheel', this.onMouseWheel, false);
    this.canvas.addEventListener('DOMMouseScroll', this.onMouseWheel, false);    
  };

  MouseViewController.prototype.unbind = function() {
    this.canvas.removeEventListener('mousemove', this.onMouseMove, false);
    this.canvas.removeEventListener('mousedown', this.onMouseDown, false);
    this.canvas.removeEventListener('mouseup', this.onMouseUp, false);
    this.canvas.removeEventListener('mousewheel', this.onMouseWheel, false);
    this.canvas.removeEventListener('DOMMouseScroll', this.onMouseWheel, false);    
  };

  MouseViewController.prototype.setCamera = function(cam_in) {
    this.camera = cam_in;
  }

  MouseViewController.prototype.getMousePosition = function() {
    return this.mpos;
  }


  /* Transform Controller */

  function Transform(init_mat) {
    return this.clearStack(init_mat);
  }

  Transform.prototype.setIdentity = function() {
    this.m_stack[this.c_stack] = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];
    if (this.valid === this.c_stack && this.c_stack) {
      this.valid--;
    }
    return this;
  };


  Transform.prototype.getIdentity = function() {
    return [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];
  };

  Transform.prototype.invalidate = function() {
    this.valid = 0;
    this.result = null;
    return this;
  };

  
  Transform.prototype.getResult = function() {
    if (!this.c_stack) {
      return this.m_stack[0];
    }
    
    var m = cubicvr_identity;
    
    if (this.valid > this.c_stack-1) this.valid = this.c_stack-1;
                
    for (var i = this.valid; i < this.c_stack+1; i++) {
      m = mat4.multiply(this.m_stack[i],m);
      this.m_cache[i] = m;
    }
      
    this.valid = this.c_stack-1;
      
    this.result = this.m_cache[this.c_stack];
    
    return this.result;
  };
  
  Transform.prototype.pushMatrix = function(m) {
    this.c_stack++;
    this.m_stack[this.c_stack] = (m ? m : cubicvr_identity);
    return this;
  };

  Transform.prototype.popMatrix = function() {
    if (this.c_stack === 0) {
      return;
    }
    this.c_stack--;
    return this;
  };

  Transform.prototype.clearStack = function(init_mat) {
    this.m_stack = [];
    this.m_cache = [];
    this.c_stack = 0;
    this.valid = 0;
    this.result = null;

    if (init_mat !== undef) {
      this.m_stack[0] = init_mat;
    } else {
      this.setIdentity();
    }

    return this;
  };

  Transform.prototype.translate = function(x, y, z) {
    if (typeof(x) === 'object') {
      return this.translate(x[0], x[1], x[2]);
    }

    var m = this.getIdentity();

    m[12] = x;
    m[13] = y;
    m[14] = z;

    this.m_stack[this.c_stack] = mat4.multiply(m,this.m_stack[this.c_stack]);
    if (this.valid === this.c_stack && this.c_stack) {
      this.valid--;
    }

    return this;
  };


  Transform.prototype.scale = function(x, y, z) {
    if (typeof(x) === 'object') {
      return this.scale(x[0], x[1], x[2]);
    }


    var m = this.getIdentity();

    m[0] = x;
    m[5] = y;
    m[10] = z;

    this.m_stack[this.c_stack] = mat4.multiply(m,this.m_stack[this.c_stack]);
    if (this.valid === this.c_stack && this.c_stack) {
      this.valid--;
    }

    return this;
  };


  Transform.prototype.rotate = function(ang, x, y, z) {
    if (typeof(ang) === 'object') {
      this.rotate(ang[0], 1, 0, 0);
      this.rotate(ang[1], 0, 1, 0);
      this.rotate(ang[2], 0, 0, 1);
      return this;
    }

    var sAng, cAng;

    if (x || y || z) {
      sAng = Math.sin(-ang * (M_PI / 180.0));
      cAng = Math.cos(-ang * (M_PI / 180.0));
    }

    if (z) {
      var Z_ROT = this.getIdentity();

      Z_ROT[0] = cAng * z;
      Z_ROT[4] = sAng * z;
      Z_ROT[1] = -sAng * z;
      Z_ROT[5] = cAng * z;

      this.m_stack[this.c_stack] = mat4.multiply(this.m_stack[this.c_stack],Z_ROT);
    }

    if (y) {
      var Y_ROT = this.getIdentity();

      Y_ROT[0] = cAng * y;
      Y_ROT[8] = -sAng * y;
      Y_ROT[2] = sAng * y;
      Y_ROT[10] = cAng * y;

      this.m_stack[this.c_stack] = mat4.multiply(this.m_stack[this.c_stack],Y_ROT);
    }


    if (x) {
      var X_ROT = this.getIdentity();

      X_ROT[5] = cAng * x;
      X_ROT[9] = sAng * x;
      X_ROT[6] = -sAng * x;
      X_ROT[10] = cAng * x;

      this.m_stack[this.c_stack] = mat4.multiply(this.m_stack[this.c_stack],X_ROT);
    }

    if (this.valid === this.c_stack && this.c_stack) {
      this.valid--;
    }

    return this;
  };

  /* Quaternions */

  function Quaternion() {
    if (arguments.length === 1) {
      this.x = arguments[0][0];
      this.y = arguments[0][1];
      this.z = arguments[0][2];
      this.w = arguments[0][3];
    }
    if (arguments.length === 4) {
      this.x = arguments[0];
      this.y = arguments[1];
      this.z = arguments[2];
      this.w = arguments[3];
    }
  }

  Quaternion.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  };

  Quaternion.prototype.normalize = function() {
    var n = Math.sqrt(this.length());
    this.x /= n;
    this.y /= n;
    this.z /= n;
    this.w /= n;
  };

  Quaternion.prototype.fromEuler = function(bank, heading, pitch) // x,y,z
  {
    var c1 = Math.cos((M_PI / 180.0) * heading / 2.0);
    var s1 = Math.sin((M_PI / 180.0) * heading / 2.0);
    var c2 = Math.cos((M_PI / 180.0) * pitch / 2.0);
    var s2 = Math.sin((M_PI / 180.0) * pitch / 2.0);
    var c3 = Math.cos((M_PI / 180.0) * bank / 2.0);
    var s3 = Math.sin((M_PI / 180.0) * bank / 2.0);
    var c1c2 = c1 * c2;
    var s1s2 = s1 * s2;

    this.w = c1c2 * c3 - s1s2 * s3;
    this.x = c1c2 * s3 + s1s2 * c3;
    this.y = s1 * c2 * c3 + c1 * s2 * s3;
    this.z = c1 * s2 * c3 - s1 * c2 * s3;
  };


  Quaternion.prototype.toEuler = function() {
    var sqw = this.w * this.w;
    var sqx = this.x * this.x;
    var sqy = this.y * this.y;
    var sqz = this.z * this.z;

    var x = (180 / M_PI) * ((Math.atan2(2.0 * (this.y * this.z + this.x * this.w), (-sqx - sqy + sqz + sqw))));
    var y = (180 / M_PI) * ((Math.asin(-2.0 * (this.x * this.z - this.y * this.w))));
    var z = (180 / M_PI) * ((Math.atan2(2.0 * (this.x * this.y + this.z * this.w), (sqx - sqy - sqz + sqw))));

    return [x, y, z];
  };

  Quaternion.prototype.multiply = function(q1, q2) {
    var selfSet = false;

    if (q2 === undef) {
      q2 = q1;
      q1 = this;
    }

    var x = q1.x * q2.w + q1.w * q2.x + q1.y * q2.z - q1.z * q2.y;
    var y = q1.y * q2.w + q1.w * q2.y + q1.z * q2.x - q1.x * q2.z;
    var z = q1.z * q2.w + q1.w * q2.z + q1.x * q2.y - q1.y * q2.x;
    var w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;

    if (selfSet) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    } else {
      return new Quaternion(x, y, z, w);
    }
  };


  /* Faces */

  function Face() {
    this.points = [];
    this.point_normals = [];
    this.uvs = [];
    this.normal = [0, 0, 0];
    this.material = 0;
    this.segment = 0;
  }

  Face.prototype.setUV = function(uvs, point_num) {
    if (this.uvs === undef) {
      this.uvs = [];
    }

    if (point_num !== undef) {
      this.uvs[point_num] = uvs;
    } else {
      if (uvs.length !== 2) {
        this.uvs = uvs;
      } else {
        this.uvs.push(uvs);
      }
    }
  };

  Face.prototype.flip = function() {
    for (var i = 0, iMax = this.point_normals.length; i < iMax; i++) {
      this.point_normals[i] = [-this.point_normals[i][0], -this.point_normals[i][1], -this.point_normals[i][2]];
    }

    this.points.reverse();
    this.point_normals.reverse();
    this.uvs.reverse();
    this.normal = [-this.normal[0], -this.normal[1], -this.normal[2]];
  };

  function Mesh(objName) {
    this.points = []; // point list
    this.faces = []; // faces with point references
    this.currentFace = -1; // start with no faces
    this.currentMaterial = 0; // null material
    this.currentSegment = 0; // default segment
    this.compiled = null; // VBO data
    this.bb = null;
    this.name = objName ? objName : null;
    this.hasUV = false;
    this.hasNorm = false;
  }

  Mesh.prototype.showAllSegments = function() {
    for (var i in this.segment_state) {
      if (this.segment_state.hasOwnProperty(i)) {
        this.segment_state[i] = true;
      }
    }
  };

  Mesh.prototype.hideAllSegments = function() {
    for (var i in this.segment_state) {
      if (this.segment_state.hasOwnProperty(i)) {
        this.segment_state[i] = false;
      }
    }
  };

  Mesh.prototype.setSegment = function(i, val) {
    if (val !== undef) {
      this.segment_state[i] = val;
    } else {
      this.currentSegment = i;
    }
  };

  Mesh.prototype.addPoint = function(p) {
    if (p.length !== 3 || typeof(p[0]) === 'object') {
      for (var i = 0, iMax = p.length; i < iMax; i++) {
        this.points.push(p[i]);
      }
    } else {
      this.points.push(p);
    }

    return this.points.length - 1;
  };

  Mesh.prototype.setFaceMaterial = function(mat,facenum) {
    var mat_id = (typeof(mat) === 'object') ? mat.material_id : mat;
    
    if (facenum !== undef) {
      if (this.faces[facenum] !== undef) {
        this.faces[facenum].material = mat_id;
      }
    } else {
      this.currentMaterial = mat_id;
    }
  };

  Mesh.prototype.addFace = function(p_list, face_num, face_mat, face_seg) {
    if (typeof(p_list[0]) !== 'number') {
      for (var i = 0, iMax = p_list.length; i < iMax; i++) {
        if (!p_list.hasOwnProperty(i)) {
          continue;
        }

        this.addFace(p_list[i]);
      }

      return;
    }

    if (face_num === undef) {
      this.currentFace = this.faces.length;
      this.faces.push(new Face());
    } else {
      if (this.faces[face_num] === undef) {
        this.faces[face_num] = new Face();
      }

      this.currentFace = face_num;
    }

    if (typeof(p_list) === 'object') {
      this.faces[this.currentFace].points = p_list;
    }

    if (face_mat !== undef) {
      this.faces[this.currentFace].material = (typeof(face_mat) === 'object') ? face_mat.material_id : face_mat;
    } else {
      this.faces[this.currentFace].material = this.currentMaterial;
    }

    if (face_seg !== undef) {
      this.faces[this.currentFace].segment = face_seg;
    } else {
      this.faces[this.currentFace].segment = this.currentSegment;
    }


    return this.currentFace;
  };

  Mesh.prototype.flipFaces = function() {
     for (var i = 0, iMax = this.faces.length; i < iMax; i++) {
       this.faces[i].flip();
     }
  }

  Mesh.prototype.triangulateQuads = function() {
    for (var i = 0, iMax = this.faces.length; i < iMax; i++) {
      if (this.faces[i].points.length === 4) {
        var p = this.faces.length;

        this.addFace([this.faces[i].points[2], this.faces[i].points[3], this.faces[i].points[0]], this.faces.length, this.faces[i].material, this.faces[i].segment);
        this.faces[i].points.pop();
        this.faces[p].normal = this.faces[i].normal;

        if (this.faces[i].uvs !== undef) {
          if (this.faces[i].uvs.length === 4) {
            this.faces[p].setUV(this.faces[i].uvs[2], 0);
            this.faces[p].setUV(this.faces[i].uvs[3], 1);
            this.faces[p].setUV(this.faces[i].uvs[0], 2);

            this.faces[i].uvs.pop();
          }
        }

        if (this.faces[i].point_normals.length === 4) {
          this.faces[p].point_normals[0] = this.faces[i].point_normals[2];
          this.faces[p].point_normals[1] = this.faces[i].point_normals[3];
          this.faces[p].point_normals[2] = this.faces[i].point_normals[0];

          this.faces[i].point_normals.pop();
        }

      }
    }
    
    return this;
  };


  Mesh.prototype.booleanAdd = function(objAdd, transform) {
    var pofs = this.points.length;
    var fofs = this.faces.length;

    var i, j, iMax, jMax;

    if (transform !== undef) {
      var m = transform.getResult();
      for (i = 0, iMax = objAdd.points.length; i < iMax; i++) {
        this.addPoint(mat4.vec3_multiply(objAdd.points[i], m));
      }
    } else {
      for (i = 0, iMax = objAdd.points.length; i < iMax; i++) {
        this.addPoint([objAdd.points[i][0], objAdd.points[i][1], objAdd.points[i][2]]);
      }
    }

    for (i = 0, iMax = objAdd.faces.length; i < iMax; i++) {
      var newFace = [];

      for (j = 0, jMax = objAdd.faces[i].points.length; j < jMax; j++) {
        newFace.push(objAdd.faces[i].points[j] + pofs);
      }

      var nFaceNum = this.addFace(newFace);
      var nFace = this.faces[nFaceNum];

     nFace.segment = objAdd.faces[i].segment;
     nFace.material = objAdd.faces[i].material;

      for (j = 0, jMax = objAdd.faces[i].uvs.length; j < jMax; j++) {
        nFace.uvs[j] = [objAdd.faces[i].uvs[j][0], objAdd.faces[i].uvs[j][1]];
      }

      for (j = 0, jMax = objAdd.faces[i].point_normals.length; j < jMax; j++) {
        nFace.point_normals[j] = [objAdd.faces[i].point_normals[j][0], objAdd.faces[i].point_normals[j][1], objAdd.faces[i].point_normals[j][2]];
      }
    }
    
    return this;
  };

  Mesh.prototype.calcFaceNormals = function() {
    for (var i = 0, iMax = this.faces.length; i < iMax; i++) {
      if (this.faces[i].points.length < 3) {
        this.faces[i].normal = [0, 0, 0];
        continue;
      }

      this.faces[i].normal = vec3.normalize(triangle.normal(this.points[this.faces[i].points[0]], this.points[this.faces[i].points[1]], this.points[this.faces[i].points[2]]));
    }
    
    return this;
  };


  Mesh.prototype.getMaterial = function(m_name) {
    
    if (this.compiled !== null)
    {
      for (var i in this.compiled.elements) {
        if (this.compiled.elements.hasOwnProperty(i)) {
          if (Materials[i].name === m_name) { 
            return Materials[i];
          }
        }
      }
    }
    else
    {
      var matVisit = [];
      
      for (var j = 0, jMax = this.faces.length;  j < jMax; j++)
      {
        var matId = this.faces[j].material;
        
        if (matVisit.indexOf(matId)===-1)
        {
          if (Materials[matId].name === m_name)
          {
            return Materials[matId];
          }
          matVisit.push(matId);
        }
      }
    }
    

    return null;
  };


  Mesh.prototype.calcNormals = function() {
    this.calcFaceNormals();

    var i, j, k, iMax;

    var point_smoothRef = new Array(this.points.length);
    for (i = 0, iMax = point_smoothRef.length; i < iMax; i++) {
      point_smoothRef[i] = [];
    }

    var numFaces = this.faces.length;

    // build a quick list of point/face sharing
    for (i = 0; i < numFaces; i++) {
      var numFacePoints = this.faces[i].points.length;

      for (j = 0; j < numFacePoints; j++) {
        var idx = this.faces[i].points[j];

        //      if (point_smoothRef[idx] === undef) point_smoothRef[idx] = [];
        point_smoothRef[idx].push([i, j]);
      }
    }


    // step through smoothing references and compute normals
    for (i = 0, iMax = this.points.length; i < iMax; i++) {
      //    if(!point_smoothRef.hasOwnProperty(i)) { continue; }
      //    if (typeof(point_smoothRef[i]) === undef) { continue; }
      var numPts = point_smoothRef[i].length;

      for (j = 0; j < numPts; j++) {
        var ptCount = 1;
        var faceNum = point_smoothRef[i][j][0];
        var pointNum = point_smoothRef[i][j][1];
        var max_smooth = Materials[this.faces[faceNum].material].max_smooth;
        var thisFace = this.faces[faceNum];

        // set point to it's face's normal
        var tmpNorm = new Array(3);

        tmpNorm[0] = thisFace.normal[0];
        tmpNorm[1] = thisFace.normal[1];
        tmpNorm[2] = thisFace.normal[2];

        // step through all other faces which share this point
        if (max_smooth !== 0) {
          for (k = 0; k < numPts; k++) {
            if (j === k) {
              continue;
            }
            var faceRefNum = point_smoothRef[i][k][0];
            var thisFaceRef = this.faces[faceRefNum];

            var ang = vec3.angle(thisFaceRef.normal, thisFace.normal);

            if ((ang !== ang) || ((ang * (180.0 / M_PI)) <= max_smooth)) {
              tmpNorm[0] += thisFaceRef.normal[0];
              tmpNorm[1] += thisFaceRef.normal[1];
              tmpNorm[2] += thisFaceRef.normal[2];

              ptCount++;
            }
          }
        }

        tmpNorm[0] /= ptCount;
        tmpNorm[1] /= ptCount;
        tmpNorm[2] /= ptCount;

        this.faces[faceNum].point_normals[pointNum] = vec3.normalize(tmpNorm);
      }
    }
    
    return this;
  };
  
  Mesh.prototype.prepare = function(doClean) {
    if (doClean === undef) {
      doClean = true;
    }
    
    this.triangulateQuads().compile();
    if (doClean) {
      this.clean();
    }
    
    return this;
  }
  
  Mesh.prototype.clean = function() {
    var i,iMax;
    
    
    for (i = 0, iMax=this.points.length; i < iMax; i++)
    {
      delete(this.points[i]);
      this.points[i]=null;
    }
    this.points = [];
    
    for (i = 0, iMax=this.faces.length; i < iMax; i++)
    {
      delete(this.faces[i].points);
      delete(this.faces[i].point_normals);
      delete(this.faces[i].uvs);
      delete(this.faces[i].normal);
      delete(this.faces[i]);      
      this.faces[i]=null;
    }
    this.faces = [];

    
    return this;
  }

  Mesh.prototype.compile = function() {
    this.compiled = {};

    this.bb = [];

    var compileRef = [];

    var i, j, k, x, y, iMax, kMax, yMax;

    for (i = 0, iMax = this.faces.length; i < iMax; i++) {
      if (this.faces[i].points.length === 3) {
        var matId = this.faces[i].material;
        var segId = this.faces[i].segment;

        if (compileRef[matId] === undef) {
          compileRef[matId] = [];
        }
        if (compileRef[matId][segId] === undef) {
          compileRef[matId][segId] = [];
        }

        compileRef[matId][segId].push(i);
      }
    }

    var vtxRef = [];

    this.compiled.vbo_normals = [];
    this.compiled.vbo_points = [];
    this.compiled.vbo_uvs = [];

    var idxCount = 0;
    var hasUV = false;
    var hasNorm = false;
    var faceNum;

    for (i in compileRef) {
      if (compileRef.hasOwnProperty(i)) {
        for (j in compileRef[i]) {
          if (compileRef[i].hasOwnProperty(j)) {
            for (k = 0; k < compileRef[i][j].length; k++) {
              faceNum = compileRef[i][j][k];
              hasUV = hasUV || (this.faces[faceNum].uvs.length !== 0);
              hasNorm = hasNorm || (this.faces[faceNum].point_normals.length !== 0);
            }
          }
        }
      }
    }

    if (hasUV) {
      for (i = 0; i < this.faces.length; i++) {
        if (!this.faces[i].uvs.length) {
          for (j = 0; j < this.faces[i].points.length; j++) {
            this.faces[i].uvs.push([0, 0]);
          }
        }
      }
    }

    if (hasNorm) {
      for (i = 0; i < this.faces.length; i++) {
        if (!this.faces[i].point_normals.length) {
          for (j = 0; j < this.faces[i].points.length; j++) {
            this.faces[i].point_normals.push([0, 0, 0]);
          }
        }
      }
    }

    this.hasUV = hasUV;
    this.hasNorm = hasNorm;

    var pVisitor = [];

    for (i in compileRef) {
      if (compileRef.hasOwnProperty(i)) {
        for (j in compileRef[i]) {
          if (compileRef[i].hasOwnProperty(j)) {
            for (k = 0, kMax = compileRef[i][j].length; k < kMax; k++) {
              faceNum = compileRef[i][j][k];
              var found = false;

              for (x = 0; x < 3; x++) {
                var ptNum = this.faces[faceNum].points[x];

                var foundPt = -1;

                if (vtxRef[ptNum] !== undef) {
                  for (y = 0, yMax = vtxRef[ptNum].length; y < yMax; y++) {
                    // face / point
                    var oFace = vtxRef[ptNum][y][0]; // faceNum
                    var oPoint = vtxRef[ptNum][y][1]; // pointNum
                    var oIndex = vtxRef[ptNum][y][2]; // index
                    foundPt = oIndex;

                    if (hasNorm) {
                      foundPt = (vec3.equal(
                      this.faces[oFace].point_normals[oPoint], this.faces[faceNum].point_normals[x])) ? foundPt : -1;
                    }

                    if (hasUV) {
                      foundPt = (vec2.equal(
                      this.faces[oFace].uvs[oPoint], this.faces[faceNum].uvs[x])) ? foundPt : -1;
                    }
                  }
                }

                if (foundPt !== -1) {
                  if (this.compiled.elements === undef) {
                    this.compiled.elements = [];
                  }
                  if (this.compiled.elements[i] === undef) {
                    this.compiled.elements[i] = [];
                  }
                  if (this.compiled.elements[i][j] === undef) {
                    this.compiled.elements[i][j] = [];
                  }
                  this.compiled.elements[i][j].push(foundPt);
                } else {
                  this.compiled.vbo_points.push(this.points[ptNum][0]);
                  this.compiled.vbo_points.push(this.points[ptNum][1]);
                  this.compiled.vbo_points.push(this.points[ptNum][2]);

                  if (this.bb.length === 0) {
                    this.bb[0] = [this.points[ptNum][0],
                                                          this.points[ptNum][1],
                                                          this.points[ptNum][2]];

                    this.bb[1] = [this.points[ptNum][0],
                                                          this.points[ptNum][1],
                                                          this.points[ptNum][2]];
                  } else {
                    if (this.points[ptNum][0] < this.bb[0][0]) {
                      this.bb[0][0] = this.points[ptNum][0];
                    }
                    if (this.points[ptNum][1] < this.bb[0][1]) {
                      this.bb[0][1] = this.points[ptNum][1];
                    }
                    if (this.points[ptNum][2] < this.bb[0][2]) {
                      this.bb[0][2] = this.points[ptNum][2];
                    }

                    if (this.points[ptNum][0] > this.bb[1][0]) {
                      this.bb[1][0] = this.points[ptNum][0];
                    }
                    if (this.points[ptNum][1] > this.bb[1][1]) {
                      this.bb[1][1] = this.points[ptNum][1];
                    }
                    if (this.points[ptNum][2] > this.bb[1][2]) {
                      this.bb[1][2] = this.points[ptNum][2];
                    }
                  }

                  if (hasNorm) {
                    this.compiled.vbo_normals.push(this.faces[faceNum].point_normals[x][0]);
                    this.compiled.vbo_normals.push(this.faces[faceNum].point_normals[x][1]);
                    this.compiled.vbo_normals.push(this.faces[faceNum].point_normals[x][2]);
                  }

                  if (hasUV) {
                    this.compiled.vbo_uvs.push(this.faces[faceNum].uvs[x][0]);
                    this.compiled.vbo_uvs.push(this.faces[faceNum].uvs[x][1]);
                  }

                  if (this.compiled.elements === undef) {
                    this.compiled.elements = [];
                  }
                  if (this.compiled.elements[i] === undef) {
                    this.compiled.elements[i] = [];
                  }
                  if (this.compiled.elements[i][j] === undef) {
                    this.compiled.elements[i][j] = [];
                  }

                  this.compiled.elements[i][j].push(idxCount);

                  if (vtxRef[ptNum] === undef) {
                    vtxRef[ptNum] = [];
                  }

                  vtxRef[ptNum].push([faceNum, x, idxCount]);
                  idxCount++;
                }
              }
            }
          }
        }
      }
    }

    this.compiled.gl_points = GLCore.gl.createBuffer();
    GLCore.gl.bindBuffer(GLCore.gl.ARRAY_BUFFER, this.compiled.gl_points);
    GLCore.gl.bufferData(GLCore.gl.ARRAY_BUFFER, new Float32Array(this.compiled.vbo_points), GLCore.gl.STATIC_DRAW);

    if (hasNorm) {
      this.compiled.gl_normals = GLCore.gl.createBuffer();
      GLCore.gl.bindBuffer(GLCore.gl.ARRAY_BUFFER, this.compiled.gl_normals);
      GLCore.gl.bufferData(GLCore.gl.ARRAY_BUFFER, new Float32Array(this.compiled.vbo_normals), GLCore.gl.STATIC_DRAW);
    }
    else
    {
      this.compiled.gl_normals = null;
    }

    if (hasUV) {
      this.compiled.gl_uvs = GLCore.gl.createBuffer();
      GLCore.gl.bindBuffer(GLCore.gl.ARRAY_BUFFER, this.compiled.gl_uvs);
      GLCore.gl.bufferData(GLCore.gl.ARRAY_BUFFER, new Float32Array(this.compiled.vbo_uvs), GLCore.gl.STATIC_DRAW);
    }
    else
    {
      this.compiled.gl_uvs = null;
    }

    var gl_elements = [];

    this.segment_state = [];
    this.compiled.elements_ref = [];

    var ictr = 0;

    for (i in this.compiled.elements) {
      if (this.compiled.elements.hasOwnProperty(i)) {
        this.compiled.elements_ref[ictr] = [];

        var jctr = 0;

        for (j in this.compiled.elements[i]) {
          if (this.compiled.elements[i].hasOwnProperty(j)) {
            for (k in this.compiled.elements[i][j]) {
              if (this.compiled.elements[i][j].hasOwnProperty(k)) {
                gl_elements.push(this.compiled.elements[i][j][k]);
              }
            }

            this.segment_state[j] = true;

            this.compiled.elements_ref[ictr][jctr] = [parseInt(i), parseInt(j), parseInt(this.compiled.elements[i][j].length)];

            jctr++;
          }
        }
        ictr++;
      }
    }

    this.compiled.gl_elements = GLCore.gl.createBuffer();
    GLCore.gl.bindBuffer(GLCore.gl.ELEMENT_ARRAY_BUFFER, this.compiled.gl_elements);
    GLCore.gl.bufferData(GLCore.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(gl_elements), GLCore.gl.STATIC_DRAW);

    // dump temporary buffers
    this.compiled.vbo_normals = null;
    this.compiled.vbo_points = null;
    this.compiled.vbo_uvs = null;
    this.compiled.elements = null;

    GLCore.gl.bindBuffer(GLCore.gl.ELEMENT_ARRAY_BUFFER, null);
    
    return this;
  };



  function UVMapper(obj_in) {
    if (obj_in!==undef) {
      this.rotation = (obj_in.rotation===undef)?[0, 0, 0]:obj_in.rotation;
      this.scale = (obj_in.scale===undef)?[1, 1, 1]:obj_in.scale;
      this.center = (obj_in.center===undef)?[0, 0, 0]:obj_in.center;
      this.projection_mode = (obj_in.projectionMode===undef)?enums.uv.projection.PLANAR:obj_in.projectionMode;
      this.projection_axis = (obj_in.projectionAxis===undef)?enums.uv.axis.X:obj_in.projectionAxis;
      this.wrap_w_count = (obj_in.wrapW===undef)?1:obj_in.wrapW;
      this.wrap_h_count = (obj_in.wrapH===undef)?1:obj_in.wrapH;
    } else {
      this.rotation = [0, 0, 0];
      this.scale = [1, 1, 1];
      this.center = [0, 0, 0];
      this.projection_mode = enums.uv.projection.PLANAR;
      this.projection_axis = enums.uv.axis.X;
      this.wrap_w_count = 1;
      this.wrap_h_count = 1;
    }
  }
  
  
  UVMapper.prototype.setRotation = function(rotation) {
    this.rotation = rotation;
  }
  
  UVMapper.prototype.setScale = function(scale) {
    this.scale = scale;
  }
  
  UVMapper.prototype.setCenter = function(center) {
    this.center = center;
  }
  
  UVMapper.prototype.setProjectionAxis = function(projection_axis) {
    this.projection_axis = projection_axis;
  }
  
  UVMapper.prototype.setProjectionMode = function(projection_mode) {
    this.projection_mode = projection_mode;
  }
  
  UVMapper.prototype.setWrapW = function(wrap_w) {
    this.wrap_w_count = wrap_w;
  }

  UVMapper.prototype.setWrapH = function(wrap_h) {
    this.wrap_h_count = wrap_h;
  }


  // convert XYZ space to longitude
  var xyz_to_h = function(x, y, z) {
    var h;

    if (x === 0 && z === 0) {
      h = 0;
    } else {
      if (z === 0) {
        h = (x < 0) ? M_HALF_PI : -M_HALF_PI;
      } else if (z < 0) {
        h = -Math.atan(x / z) + M_PI;
      } else {
        h = -Math.atan(x / z);
      }
    }

    return h;
  };


  // convert XYZ space to latitude and longitude
  var xyz_to_hp = function(x, y, z) {
    var h, p;

    if (x === 0 && z === 0) {
      h = 0;

      if (y !== 0) {
        p = (y < 0) ? -M_HALF_PI : M_HALF_PI;
      } else {
        p = 0;
      }
    } else {
      if (z === 0) {
        h = (x < 0) ? M_HALF_PI : -M_HALF_PI;
      } else if (z < 0) {
        h = -Math.atan(x / z) + M_PI;
      } else {
        h = -Math.atan(x / z);
      }

      x = Math.sqrt(x * x + z * z);

      if (x === 0) {
        p = (y < 0) ? -M_HALF_PI : M_HALF_PI;
      } else {
        p = Math.atan(y / x);
      }
    }

    return [h, p];
  };


  UVMapper.prototype.apply = function(obj, mat_num, seg_num) {
    var u, v, s, t, lat, lon;

    var trans = new Transform();
    var transformed = false;
    var t_result = null;

    if (this.center[0] || this.center[1] || this.center[2]) {
      trans.translate(-this.center[0], -this.center[1], -this.center[2]);
      transformed = true;
    }

    if (this.rotation[0] || this.rotation[1] || this.rotation[2]) {
      if (this.rotation[0]) {
        trans.rotate(this.rotation[2], 0, 0, 1);
      }
      if (this.rotation[1]) {
        trans.rotate(this.rotation[1], 0, 1, 0);
      }
      if (this.rotation[2]) {
        trans.rotate(this.rotation[0], 1, 0, 0);
      }
      transformed = true;
    }

    if (transformed) {
      t_result = trans.getResult();
    }

    if (typeof(mat_num) === 'object') {
      mat_num = mat_num.material_id;
    }

    for (var i = 0, iMax = obj.faces.length; i < iMax; i++) {
      if (obj.faces[i].material !== mat_num) {
        continue;
      }
      if (seg_num !== undef) {
        if (obj.faces[i].segment !== seg_num) {
          continue;
        }
      }

      var nx, ny, nz;

      if (this.projection_mode === enums.uv.projection.CUBIC || this.projection_mode === enums.uv.projection.SKY) {
        nx = Math.abs(obj.faces[i].normal[0]);
        ny = Math.abs(obj.faces[i].normal[1]);
        nz = Math.abs(obj.faces[i].normal[2]);
      }

      for (var j = 0, jMax = obj.faces[i].points.length; j < jMax; j++) {
        var uvpoint = obj.points[obj.faces[i].points[j]];

        if (transformed) {
          uvpoint = mat4.vec3_multiply(uvpoint, t_result);
        }

        /* calculate the uv for the points referenced by this face's pointref vector */
        var p_mode = this.projection_mode;
        //switch (this.projection_mode) {
        if (p_mode === enums.uv.projection.SKY) {
        //case enums.uv.projection.SKY:
          var mapping = obj.sky_mapping;
          /* see enums.uv.projection.CUBIC for normalization reasoning */
          if (nx >= ny && nx >= nz) {
            s = uvpoint[2] / (this.scale[2]) + this.scale[2] / 2;
            t = -uvpoint[1] / (this.scale[1]) + this.scale[1] / 2;
            if (obj.faces[i].normal[0] < 0) {
              //left
              s = (mapping[2][2] - mapping[2][0]) * (1-s);
              t = 1-((mapping[2][3] - mapping[2][1]) * (t));
              s += mapping[2][0];
              t += mapping[2][1];
            }
            else {
              //right
              s = (mapping[3][2] - mapping[3][0]) * (s);
              t = 1-((mapping[3][3] - mapping[3][1]) * (t));
              s += mapping[3][0];
              t += mapping[3][1];
            } //if
          } //if
          if (ny >= nx && ny >= nz) {
            s = uvpoint[0] / (this.scale[0]) + this.scale[0] / 2;
            t = -uvpoint[2] / (this.scale[2]) + this.scale[2] / 2;
            if (obj.faces[i].normal[1] < 0) {
              //down
              s = ((mapping[1][2] - mapping[1][0]) * (s));
              t = 1-((mapping[1][3] - mapping[1][1]) * (t));
              s += mapping[1][0];
              t -= mapping[1][1];
            }
            else {
              //up
              s = ((mapping[0][2] - mapping[0][0]) * (s));
              t = 1-((mapping[0][3] - mapping[0][1]) * (t));
              s += mapping[0][0];
              t -= mapping[0][1];
            } //if
          } //if
          if (nz >= nx && nz >= ny) {
            s = uvpoint[0] / (this.scale[0]) + this.scale[0] / 2;
            t = uvpoint[1] / (this.scale[1]) + this.scale[1] / 2;
            if (obj.faces[i].normal[2] < 0) {
              //front
              s = ((mapping[4][2] - mapping[4][0]) * (s));
              t = 1-((mapping[4][3] - mapping[4][1]) * (1-t));
              s += mapping[4][0];
              t -= mapping[4][1];
            }
            else {
              //back
              s = ((mapping[5][2] - mapping[5][0]) * (1-s));
              t = 1-((mapping[5][3] - mapping[5][1]) * (1-t));
              s += mapping[5][0];
              t += mapping[5][1];
            } //if
          } //if
          obj.faces[i].setUV([s, t], j);
          //break;
        }
        else if (p_mode === enums.uv.projection.CUBIC) {
        //case enums.uv.projection.CUBIC:
          /* cubic projection needs to know the surface normal */
          /* x portion of vector is dominant, we're mapping in the Y/Z plane */
          if (nx >= ny && nx >= nz) {
            /* we use a .5 offset because texture coordinates range from 0->1, so to center it we need to offset by .5 */
            s = uvpoint[2] / this.scale[2] + 0.5;
            /* account for scale here */
            t = uvpoint[1] / this.scale[1] + 0.5;
          }

          /* y portion of vector is dominant, we're mapping in the X/Z plane */
          if (ny >= nx && ny >= nz) {

            s = -uvpoint[0] / this.scale[0] + 0.5;
            t = uvpoint[2] / this.scale[2] + 0.5;
          }

          /* z portion of vector is dominant, we're mapping in the X/Y plane */
          if (nz >= nx && nz >= ny) {
            s = -uvpoint[0] / this.scale[0] + 0.5;
            t = uvpoint[1] / this.scale[1] + 0.5;
          }

          if (obj.faces[i].normal[0] > 0) {
            s = -s;
          }
          if (obj.faces[i].normal[1] < 0) {
            s = -s;
          }
          if (obj.faces[i].normal[2] > 0) {
            s = -s;
          }

          obj.faces[i].setUV([s, t], j);
          //break;
        }
        else if (p_mode === enums.uv.projection.PLANAR) {
        //case enums.uv.projection.PLANAR:
          s = ((this.projection_axis === enums.uv.axis.X) ? uvpoint[2] / this.scale[2] + 0.5 : -uvpoint[0] / this.scale[0] + 0.5);
          t = ((this.projection_axis === enums.uv.axis.Y) ? uvpoint[2] / this.scale[2] + 0.5 : uvpoint[1] / this.scale[1] + 0.5);

          obj.faces[i].setUV([s, t], j);
          //break;
        }
        else if (p_mode === enums.uv.projection.CYLINDRICAL) {
        //case enums.uv.projection.CYLINDRICAL:
          // Cylindrical is a little more tricky, we map based on the degree around the center point
          var p_axis = this.projection_axis;
          //switch (this.projection_axis) {
          if (p_axis === enums.uv.axis.X) {
          //case enums.uv.axis.X:
            // xyz_to_h takes the point and returns a value representing the 'unwrapped' height position of this point
            lon = xyz_to_h(uvpoint[2], uvpoint[0], -uvpoint[1]);
            t = -uvpoint[0] / this.scale[0] + 0.5;
            //break;
          }
          else if (p_axis === enums.uv.axis.Y) {
          //case enums.uv.axis.Y:
            lon = xyz_to_h(-uvpoint[0], uvpoint[1], uvpoint[2]);
            t = -uvpoint[1] / this.scale[1] + 0.5;
            //break;
          }
          else if (p_axis === enums.uv.axis.Z) {
          //case enums.uv.axis.Z:
            lon = xyz_to_h(-uvpoint[0], uvpoint[2], -uvpoint[1]);
            t = -uvpoint[2] / this.scale[2] + 0.5;
            //break;
          } //if

          // convert it from radian space to texture space 0 to 1 * wrap, TWO_PI = 360 degrees
          lon = 1.0 - lon / (M_TWO_PI);

          if (this.wrap_w_count !== 1.0) {
            lon = lon * this.wrap_w_count;
          }

          u = lon;
          v = t;

          obj.faces[i].setUV([u, v], j);
          //break;
        }
        else if (p_mode === enums.uv.projection.SPHERICAL) {
        //case enums.uv.projection.SPHERICAL:
          var latlon;

          // spherical is similar to cylindrical except we also unwrap the 'width'
          var p_axis = this.projection_axis;
          //switch (this.projection_axis) {
          if (p_axis === enums.uv.axis.X) {
          //case enums.uv.axis.X:
            // xyz to hp takes the point value and 'unwraps' the latitude and longitude that projects to that point
            latlon = xyz_to_hp(uvpoint[2], uvpoint[0], -uvpoint[1]);
            //break;
          }
          else if (p_axis === enums.uv.axis.Y) {
          //case enums.uv.axis.Y:
            latlon = xyz_to_hp(uvpoint[0], -uvpoint[1], uvpoint[2]);
            //break;
          }
          else if (p_axis === enums.uv.axis.Z) {
          //case enums.uv.axis.Z:
            latlon = xyz_to_hp(-uvpoint[0], uvpoint[2], -uvpoint[1]);
            //break;
          } //if

          // convert longitude and latitude to texture space coordinates, multiply by wrap height and width
          lon = 1.0 - latlon[0] / M_TWO_PI;
          lat = 0.5 - latlon[1] / M_PI;

          if (this.wrap_w_count !== 1.0) {
            lon = lon * this.wrap_w_count;
          }
          if (this.wrap_h_count !== 1.0) {
            lat = lat * this.wrap_h_count;
          }

          u = lon;
          v = lat;

          obj.faces[i].setUV([u, v], j);
          //break;
        }
        else {

          // case enums.uv.projection.UV:
          //   // not handled here..
          // break;
        //default:
          // else mapping cannot be handled here, this shouldn't have happened :P
          u = 0;
          v = 0;
          obj.faces[i].setUV([u, v], j);
          //break;
        } //if
      } //for
    } //for - faces
    
    return this;
  };

  function AABB_size(aabb) {
    var x = aabb[0][0] < aabb[1][0] ? aabb[1][0] - aabb[0][0] : aabb[0][0] - aabb[1][0];
    var y = aabb[0][1] < aabb[1][1] ? aabb[1][1] - aabb[0][1] : aabb[0][1] - aabb[1][1];
    var z = aabb[0][2] < aabb[1][2] ? aabb[1][2] - aabb[0][2] : aabb[0][2] - aabb[1][2];
    return [x,y,z];
  } //AABB_size
  function AABB_reset(aabb, point) {
    if (point === undefined) {
      point = [0,0,0];
    } //if
    aabb[0][0] = point[0];
    aabb[0][1] = point[1];
    aabb[0][2] = point[2];
    aabb[1][0] = point[0];
    aabb[1][1] = point[1];
    aabb[1][2] = point[2];
  } //AABB_reset
  function AABB_engulf(aabb, point) {
    if (aabb[0][0] > point[0]) {
      aabb[0][0] = point[0];
    }
    if (aabb[0][1] > point[1]) {
      aabb[0][1] = point[1];
    }
    if (aabb[0][2] > point[2]) {
      aabb[0][2] = point[2];
    }
    if (aabb[1][0] < point[0]) {
      aabb[1][0] = point[0];
    }
    if (aabb[1][1] < point[1]) {
      aabb[1][1] = point[1];
    }
    if (aabb[1][2] < point[2]) {
      aabb[1][2] = point[2];
    }
  } //AABB::engulf


/* Lights */

function Light(light_type, lighting_method) {
  if (light_type === undef) {
    light_type = enums.light.type.POINT;
  }
  if (lighting_method === undef) {
    lighting_method = enums.light.method.DYNAMIC;
  }

  if (typeof(light_type)=='object') {
    this.light_type = (light_type.type!==undef)?light_type.type:enums.light.type.POINT;
    this.diffuse = (light_type.diffuse!==undef)?light_type.diffuse:[1, 1, 1];
    this.specular = (light_type.specular!==undef)?light_type.specular:[1.0,1.0,1.0];
    this.intensity = (light_type.intensity!==undef)?light_type.intensity:1.0;
    this.position = (light_type.position!==undef)?light_type.position:[0, 0, 0];
    this.direction = (light_type.direction!==undef)?light_type.direction:[0, 0, 0];
    this.distance = (light_type.distance!==undef)?light_type.distance:((this.light_type===enums.light.type.AREA)?30:10);
    this.cutoff = (light_type.cutoff!==undef)?light_type.cutoff:60;
    this.map_res = (light_type.map_res!==undef)?light_type.map_res:(this.light_type===enums.light.type.AREA)?2048:512;
    this.map_res = (light_type.mapRes!==undef)?light_type.mapRes:this.map_res;
    this.method = (light_type.method!==undef)?light_type.method:lighting_method;
    this.areaCam = (light_type.areaCam!==undef)?light_type.areaCam:null;
    this.areaCeiling = (light_type.areaCeiling!==undef)?light_type.areaCeiling:40;
    this.areaFloor = (light_type.areaFloor!==undef)?light_type.areaFloor:-40;
    this.areaAxis = (light_type.areaAxis!==undef)?light_type.areaAxis:[1,1,0];
  } else {
    this.light_type = light_type;
    this.diffuse = [1, 1, 1];
    this.specular = [1.0,1.0,1.0];
    this.intensity = 1.0;
    this.position = [0, 0, 0];
    this.direction = [0, 0, 0];
    this.distance = ((this.light_type===enums.light.type.AREA)?30:10);
    this.cutoff = 60;
    this.map_res = (this.light_type===enums.light.type.AREA)?2048:512;
    this.method = lighting_method;
    this.areaCam = null;
    this.areaCeiling = 40;
    this.areaFloor = -40;
    this.areaAxis = [1,1,0];
  }
  
  this.trans = new Transform();
  this.lposition = [0, 0, 0];
  this.tMatrix = this.trans.getResult();
  this.dirty = true;
  this.octree_leaves = [];
  this.octree_common_root = null;
  this.octree_aabb = [[0, 0, 0], [0, 0, 0]];
  this.ignore_octree = false;
  this.visible = true;
  this.culled = true;
  this.was_culled = true;
  this.aabb = [[0,0,0],[0,0,0]];
  AABB_reset(this.aabb, this.position);
  this.adjust_octree = SceneObject.prototype.adjust_octree;
  this.motion = null;
  this.rotation = [0,0,0];
  
  if (this.light_type === enums.light.type.SPOT_SHADOW || this.light_type === enums.light.type.AREA) {
    this.setShadow(this.map_res);
  }
  
  // modelview / normalmatrix transform outputs
  this.lDir = [0,0,0];
  this.lPos = [0,0,0];  
}

Light.prototype.setType = function(light_type) {
  this.light_type = type;
}

Light.prototype.setMethod = function(method) {
  this.method = method;
}

Light.prototype.setDiffuse = function(diffuse) {
  this.diffuse = diffuse;
}
Light.prototype.setSpecular = function(specular) {
  this.specular = specular;
}
Light.prototype.setIntensity = function(intensity) {
  this.intensity = intensity;
}
Light.prototype.setPosition = function(position) {
  this.position = position;
}
Light.prototype.setDistance = function(distance) {
  this.distance = distance;
}
Light.prototype.setCutoff = function(cutoff_angle) {
  this.cutoff = cutoff_angle;
}

Light.prototype.prepare = function(camera) {
  var ltype = this.light_type;
  
  if (ltype === enums.light.type.DIRECTIONAL) {
    this.lDir = mat3.vec3_multiply(this.direction,camera.nMatrix);
  } else if (ltype === enums.light.type.SPOT || ltype === enums.light.type.SPOT_SHADOW) {
    this.lDir = mat3.vec3_multiply(this.direction,camera.nMatrix);
    this.lPos = mat4.vec3_multiply(this.position,camera.mvMatrix);
  } else if (ltype === enums.light.type.POINT) {
    this.lPos = mat4.vec3_multiply(this.position,camera.mvMatrix);
  } else if (ltype === enums.light.type.AREA) {
    this.lDir = mat3.vec3_multiply(this.direction,camera.nMatrix);
  }
}
Light.prototype.control = function(controllerId, motionId, value) {
  if (controllerId === enums.motion.POS) {
    this.position[motionId] = value;
    } else if (controllerId === enums.motion.INTENSITY) {
      this.intensity = value;
     }
  
   // else if (controllerId === enums.motion.ROT) {
   //    this.rotation[motionId] = value;
   //  }
}

Light.prototype.doTransform = function(mat) {
  if (!vec3.equal(this.lposition, this.position) || (mat !== undef)) {
    this.trans.clearStack();
    this.trans.translate(this.position);
    if ((mat !== undef)) {
      this.trans.pushMatrix(mat);
    }
    this.tMatrix = this.trans.getResult();
    this.lposition[0] = this.position[0];
    this.lposition[1] = this.position[1];
    this.lposition[2] = this.position[2];
    this.dirty = true;
    this.adjust_octree();
  } //if
} //Light::doTransform

Light.prototype.getAABB = function() {
  var aabb = [[0, 0, 0], [0, 0, 0]];
  AABB_engulf(aabb, [this.distance, this.distance, this.distance]);
  AABB_engulf(aabb, [-this.distance, -this.distance, -this.distance]);
  aabb[0] = vec3.add(aabb[0], this.position);
  aabb[1] = vec3.add(aabb[1], this.position);
  this.aabb = aabb;
  return this.aabb;
};

Light.prototype.setDirection = function(x, y, z) {
  if (typeof(x) === 'object') {
    this.setDirection(x[0], x[1], x[2]);
    return;
  }


  this.direction = vec3.normalize([x, y, z]);
    
    return this;
};

Light.prototype.lookat = function(x, y, z) {
  if (typeof(x) === 'object') {
    this.lookat(x[0], x[1], x[2]);
    return;
  }

  this.direction = vec3.normalize(vec3.subtract([x, y, z],this.position));
    
  return this;
};



Light.prototype.setRotation = function(x, y, z) {
  if (typeof(x) === 'object') {
    this.setRotation(x[0], x[1], x[2]);
    return;
  }

  var t = new Transform();
  t.rotate([-x, -y, -z]);
  t.pushMatrix();

  this.direction = vec3.normalize(mat4.vec3_multiply([1, 0, 0], t.getResult()));
  this.rotation = [x,y,z];
  
  return this;
};


Light.prototype.setupShader = function(lShader,lNum) {
    var gl = GLCore.gl;
    
    var lUniforms = lShader.lights[lNum];
    
    gl.uniform3fv(lUniforms.lDiff, this.diffuse);
    gl.uniform3fv(lUniforms.lSpec, this.specular);
    if (this.lPos) gl.uniform3fv(lUniforms.lPos, this.lPos);
    if (this.lDir) gl.uniform3fv(lUniforms.lDir, this.lDir);

    gl.uniform1f(lUniforms.lInt, this.intensity);
    gl.uniform1f(lUniforms.lDist, this.distance);
    
    if ((this.light_type === enums.light.type.SPOT_SHADOW)||(this.light_type === enums.light.type.SPOT)) {
      gl.uniform1f(lUniforms.lCut, this.cutoff);
    }
    if ((this.light_type === enums.light.type.SPOT_SHADOW)||(this.light_type === enums.light.type.AREA)) {
      this.shadowMapTex.texture.use(GLCore.gl.TEXTURE0+lNum);  // reserved in material for shadow map
      gl.uniform1i(lShader.lDepthTex[lNum], lNum);
      gl.uniform3fv(lShader.lDepth[lNum], [this.dummyCam.nearclip,this.dummyCam.farclip,1.0/this.map_res]);        
      gl.uniformMatrix4fv(lShader.spMatrix[lNum], false, this.spMatrix);
    }
};

Light.prototype.setShadow = function(map_res_in)  // cone_tex
{
  this.map_res = map_res_in;
  this.shadowMapTex = new RenderBuffer(this.map_res, this.map_res, true);
  this.shadowMapTex.texture.setFilter(enums.texture.filter.NEAREST);
  
  this.dummyCam = new Camera(this.map_res,this.map_res,80,0.1,this.distance);
  this.dummyCam.calc_nmatrix = false; // don't need a normal matrix, save some cycles and determinant issues
  this.dummyCam.setTargeted(true);
  // if(!(strncmp(cone_tex.c_str(),"null",4) == 0 || strncmp(cone_tex.c_str(),"Null",4) == 0 || strncmp(cone_tex.c_str(),"NULL",4) == 0))
  // {
  //  coneTex = Texture::create(cone_tex);
  //  has_projector = true;
  // }

  this.has_shadow = true;
};


Light.prototype.hasShadow = function()
{
  return has_shadow;
};


Light.prototype.shadowBegin = function()
{
  var gl = GLCore.gl;  

  this.shadowMapTex.use();

  gl.viewport(0, 0, this.map_res, this.map_res);
    
  gl.clear(gl.DEPTH_BUFFER_BIT|gl.COLOR_BUFFER_BIT);

  if (this.light_type!==enums.light.type.AREA) {
    this.dummyCam.setClip(0.1,this.distance);
    this.dummyCam.setFOV(this.cutoff);
  } else {
    this.dummyCam.calcProjection();
  }

  this.dummyCam.lookat(this.position[0], this.position[1], this.position[2], this.position[0]+this.direction[0]*10.0, this.position[1]+this.direction[1]*10.0, this.position[2]+this.direction[2]*10.0, 0, 1, 0);

  gl.cullFace(gl.FRONT);  
};


Light.prototype.shadowEnd = function()
{
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  
  gl.cullFace(gl.BACK);
  
  this.setupTexGen();
};


Light.prototype.setupTexGen = function()
{
  var biasMatrix = [0.5, 0.0, 0.0, 0.0,
                    0.0, 0.5, 0.0, 0.0,
                    0.0, 0.0, 0.5, 0.0,
                    0.5, 0.5, 0.5, 1.0];

  this.spMatrix = mat4.multiply(biasMatrix,cubicvr_identity);
  this.spMatrix = mat4.multiply(this.dummyCam.pMatrix,this.spMatrix);
  this.spMatrix = mat4.multiply(this.dummyCam.mvMatrix,this.spMatrix);
};


Light.prototype.setAreaAxis = function(degs_in) {
  this.areaAxis = degs_in;
}

Light.prototype.updateAreaLight = function() {
	var areaHeight = this.areaCeiling-this.areaFloor;

  this.dummyCam.ortho = true;
  this.dummyCam.setClip(0.01,1); // set defaults
    
  	var dist = 0.0;
  	var sx = Math.tan((this.areaCam.fov/2.0)*(M_PI/180.0));
//  	var far_clip_range = far_range;

  	var vview = vec3.subtract(this.areaCam.target,this.areaCam.position);
  	vview[1] = 0;
  	vview = vec3.normalize(vview);

  	var vleft = vec3.normalize(vec3.cross(vview,[0,1,0]));

  	var fwd_ang = -Math.atan2(vview[2],vview[0]);

  	dist = ((this.distance/2.0)*Math.abs(sx))-(this.distance/2.0);

  	if (dist < (this.distance/3.0)/2.0) dist = (this.distance/3.0)/2.0;

    vview = vec3.multiply(vview,dist);

    var zang = this.areaAxis[0]*(M_PI/180);
    var xang = this.areaAxis[1]*(M_PI/180);
    
    var tzang = Math.tan(zang);
    var txang = Math.tan(xang);

  	var l_vec = [txang,0.0,tzang];

    fwd_ang -= Math.atan2(l_vec[0],l_vec[2]);

  	this.position = vec3.add(vec3.add(this.areaCam.position,vview),vec3.multiply(l_vec,areaHeight));
  	this.position[1] = this.areaCeiling;
  	this.target = vec3.add(vec3.add(this.areaCam.position,vview),vec3.multiply(l_vec,-areaHeight));
  	this.target[1] = this.areaFloor;
  	this.direction = vec3.normalize(vec3.subtract(this.target,this.position));
  	this.dummyCam.rotation[2] = fwd_ang*(180.0/M_PI);

    var nearclip = this.dummyCam.nearclip;
    var farclip = this.dummyCam.farclip*(Math.abs(this.direction[1])*areaHeight);

    // adjust clipping ranges to fit ortho bounds
     var aabb = this.orthoBounds(this.position, this.distance, this.distance, this.dummyCam.pMatrix, this.dummyCam.mvMatrix, this.dummyCam.nearclip);
         
     if (aabb[0][1] < this.areaCeiling)
     {
       var diff = (this.areaCeiling-aabb[0][1]);
       nearclip-=diff/Math.abs(this.direction[1]);
     }
       
     aabb = this.orthoBounds(this.position, this.distance, this.distance, this.dummyCam.pMatrix, this.dummyCam.mvMatrix, this.dummyCam.farclip);
         
     if (aabb[1][1] > this.areaFloor)
     {
       var diff = (aabb[1][1]-this.areaFloor);
       farclip+=diff/Math.abs(this.direction[1]);
     }

    //if (nearclip < 0.01) 
    nearclip=0.01;
    this.dummyCam.nearclip = nearclip;
    this.dummyCam.farclip = farclip;

    this.dummyCam.setOrtho(-this.distance/2.0, this.distance/2.0, -this.distance/2.0, this.distance/2.0);
}


Light.prototype.orthoBounds = function(position, ortho_width, ortho_height, projMatrix, modelMatrix, clipDist)
{
	var right = vec3.normalize([modelMatrix[0],modelMatrix[4],modelMatrix[8]]);	
	var up = vec3.normalize([modelMatrix[1],modelMatrix[5],modelMatrix[9]]);	
	var forward = vec3.normalize(vec3.cross(up,right));
	
	var hw, hh;
	
	hw = ortho_width/2.0;
	hh = ortho_height/2.0;
	
	var f_bounds = [];

  var rightHW = vec3.multiply(right,hw);
  var upHH = vec3.multiply(up,hh);
  var forwardClip = vec3.multiply(forward,clipDist);
  

  f_bounds[0] = vec3.add     (vec3.subtract(position,rightHW), vec3.add(upHH,forwardClip));
  f_bounds[1] = vec3.add     (     vec3.add(position,rightHW), vec3.add(upHH,forwardClip));
  f_bounds[2] = vec3.subtract(vec3.subtract(position,rightHW), vec3.add(upHH,forwardClip));
  f_bounds[3] = vec3.subtract(     vec3.add(position,rightHW), vec3.add(upHH,forwardClip));	
	
	aabb1 = f_bounds[0];
	aabb2 = f_bounds[0];
	
	for (var i = 1; i < 4; i++)
	{
		if (aabb1[0] > f_bounds[i][0]) aabb1[0] = f_bounds[i][0];
		if (aabb1[1] > f_bounds[i][1]) aabb1[1] = f_bounds[i][1];
		if (aabb1[2] > f_bounds[i][2]) aabb1[2] = f_bounds[i][2];
		
		if (aabb2[0] < f_bounds[i][0]) aabb2[0] = f_bounds[i][0];
		if (aabb2[1] < f_bounds[i][1]) aabb2[1] = f_bounds[i][1];
		if (aabb2[2] < f_bounds[i][2]) aabb2[2] = f_bounds[i][2];
	}
	
	return [aabb1,aabb2];
}



var emptyLight = new Light(enums.light.type.POINT);
emptyLight.diffuse = [0, 0, 0];
emptyLight.specular = [0, 0, 0];
emptyLight.distance = 0;
emptyLight.intensity = 0;
emptyLight.cutoff = 0;

/* Shaders */

function Shader(vs_id, fs_id) {
  var vertexShader;
  var fragmentShader;
  var loadedShader;

  this.uniforms = [];
  this.uniform_type = [];
  this.uniform_typelist = [];

  if (vs_id.indexOf("\n") !== -1) {
    vertexShader = cubicvr_compileShader(GLCore.gl, vs_id, "x-shader/x-vertex");
  } else {
    vertexShader = cubicvr_getShader(GLCore.gl, vs_id);

    if (vertexShader === null) {
      loadedShader = util.getURL(vs_id);

      vertexShader = cubicvr_compileShader(GLCore.gl, loadedShader, "x-shader/x-vertex");
    }
  }

  if (fs_id.indexOf("\n") !== -1) {
    fragmentShader = cubicvr_compileShader(GLCore.gl, fs_id, "x-shader/x-fragment");
  } else {
    fragmentShader = cubicvr_getShader(GLCore.gl, fs_id);

    if (fragmentShader === null) {
      loadedShader = util.getURL(fs_id);

      fragmentShader = cubicvr_compileShader(GLCore.gl, loadedShader, "x-shader/x-fragment");
    }

  }


  this.shader = GLCore.gl.createProgram();
  GLCore.gl.attachShader(this.shader, vertexShader);
  GLCore.gl.attachShader(this.shader, fragmentShader);
  GLCore.gl.linkProgram(this.shader);

  if (!GLCore.gl.getProgramParameter(this.shader, GLCore.gl.LINK_STATUS)) {
    throw new Error("Could not initialise shader vert(" + vs_id + "), frag(" + fs_id + ")");
  }
}


Shader.prototype.bindSelf = function(uniform_id) {  
  var t,k,p,v;
  
  if (uniform_id.indexOf(".")!==-1) {
    if (uniform_id.indexOf("[")!==-1) {
      t = uniform_id.split("[");
      p = t[0];
      t = t[1].split("]");
      k = t[0];
      t = t[1].split(".");
      v = t[1];
      
      if (this[p] === undef) {
        this[p] = [];
      }
      if (this[p][k] === undef) {
        this[p][k] = {};
      }
      
      this[p][k][v] = this.uniforms[uniform_id];

    } else {  // untested
      t = uniform_id.split(".");
      p = t[0];
      v = t[1];

      if (this[p] === undef) {
        this[p] = {};
      }
      
      this[p][v] = this.uniforms[uniform_id];
      
    }
  } else if ( uniform_id.indexOf("[") !== -1){  // untested
    t = uniform_id.split("[");
    p = t[0];
    t = t[1].split("]");
    k = t[0];
    
    if (this[p] === undef) {
      this[p] = [];
    }
    
    this[p][k] = this.uniforms[uniform_id];
  }
  else {
    this[uniform_id] = this.uniforms[uniform_id];
  }
}

Shader.prototype.addMatrix = function(uniform_id, default_val) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getUniformLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.MATRIX;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  if (default_val !== undef) {
    this.setMatrix(uniform_id, default_val);
  }

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addVector = function(uniform_id, default_val) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getUniformLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.VECTOR;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  if (default_val !== undef) {
    this.setVector(uniform_id, default_val);
  }

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addFloat = function(uniform_id, default_val) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getUniformLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.FLOAT;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  if (default_val !== undef) {
    this.setFloat(uniform_id, default_val);
  }

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};


Shader.prototype.addVertexArray = function(uniform_id) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getAttribLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.ARRAY_VERTEX;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addUVArray = function(uniform_id) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getAttribLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.ARRAY_UV;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addFloatArray = function(uniform_id) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getAttribLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.ARRAY_FLOAT;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addInt = function(uniform_id, default_val) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getUniformLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.INT;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  if (default_val !== undef) {
    this.setInt(uniform_id, default_val);
  }

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.use = function() {
  GLCore.gl.useProgram(this.shader);
};

Shader.prototype.setMatrix = function(uniform_id, mat) {
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  var l = mat.length;
  
  if (l===16) {
    GLCore.gl.uniformMatrix4fv(u, false, mat);  
  } else if (l === 9) {
    GLCore.gl.uniformMatrix3fv(u, false, mat);  
  } else if (l === 4) {
    GLCore.gl.uniformMatrix2fv(u, false, mat);  
  }
};

Shader.prototype.setInt = function(uniform_id, val) {
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  GLCore.gl.uniform1i(u, val);
};

Shader.prototype.setFloat = function(uniform_id, val) {
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  GLCore.gl.uniform1f(u, val);
};

Shader.prototype.setVector = function(uniform_id, val) {
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  var l = val.length;
  
  if (l==3) {
    GLCore.gl.uniform3fv(u, val);    
  } else if (l==2) {
    GLCore.gl.uniform2fv(u, val);    
  } else {
    GLCore.gl.uniform4fv(u, val);
  }
};


Shader.prototype.clearArray = function(uniform_id) {
  var gl = GLCore.gl;  
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
    
  gl.disableVertexAttribArray(u);
};

Shader.prototype.bindArray = function(uniform_id, buf) {
  var gl = GLCore.gl;  
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  var t = this.uniform_type[uniform_id];
    
  if (t === enums.shader.uniform.ARRAY_VERTEX) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.vertexAttribPointer(u, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(u);
  } else if (t === enums.shader.uniform.ARRAY_UV) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.vertexAttribPointer(u, 2, gl.FLOAT, false, 0, 0);
  } else if (t === enums.shader.uniform.ARRAY_FLOAT) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.vertexAttribPointer(u, 1, gl.FLOAT, false, 0, 0);
  }
};


/* Materials */

var Material = function(mat_name) {
  this.material_id = -1;

  /*
  if (mat_name !== undef) {
    var old_mat = Material_ref[mat_name];
    if (old_mat) {
      var old_id = old_mat.material_id;
      Materials[old_id] = this;
      old_mat = null;
    } //if
    Material_ref[mat_name] = this;
  }
  */

  //if (this.material_id === -1) {
    this.material_id = Materials.length;
    Materials.push(this);
  //} //if

  this.initialized = false;
  this.textures = [];
  this.shader = [];
  this.customShader = null;

  if (typeof(mat_name)==='object') {
    this.diffuse = (mat_name.diffuse===undef)?[1.0, 1.0, 1.0]:mat_name.diffuse;
    this.specular = (mat_name.specular===undef)?[0.1, 0.1, 0.1]:mat_name.specular;
    this.color = (mat_name.color===undef)?[1, 1, 1]:mat_name.color;
    this.ambient = (mat_name.ambient===undef)?[0, 0, 0]:mat_name.ambient;
    this.opacity = (mat_name.opacity===undef)?1.0:mat_name.opacity;
    this.shininess = (mat_name.shininess===undef)?1.0:mat_name.shininess;
    this.max_smooth = (mat_name.max_smooth===undef)?60.0:mat_name.max_smooth;
    this.env_amount = (mat_name.env_amount===undef)?0.75:mat_name.env_amount;
    this.name = (mat_name.name===undef)?undef:mat_name.name;

    if (typeof(mat_name.textures)==='object') {
      if (mat_name.textures.color!==undef) this.setTexture(mat_name.textures.color,enums.texture.map.COLOR);
      if (mat_name.textures.envsphere!==undef) this.setTexture(mat_name.textures.envsphere,enums.texture.map.ENVSPHERE);
      if (mat_name.textures.normal!==undef) this.setTexture(mat_name.textures.normal,enums.texture.map.NORMAL);
      if (mat_name.textures.bump!==undef) this.setTexture(mat_name.textures.bump,enums.texture.map.BUMP);
      if (mat_name.textures.reflect!==undef) this.setTexture(mat_name.textures.reflect,enums.texture.map.REFLECT);
      if (mat_name.textures.specular!==undef) this.setTexture(mat_name.textures.specular,enums.texture.map.SPECULAR);
      if (mat_name.textures.ambient!==undef) this.setTexture(mat_name.textures.ambient,enums.texture.map.AMBIENT);
      if (mat_name.textures.alpha!==undef) this.setTexture(mat_name.textures.alpha,enums.texture.map.ALPHA);
    }
  } else {
    this.diffuse = [1.0, 1.0, 1.0];
    this.specular = [0.1, 0.1, 0.1];
    this.color = [1, 1, 1];
    this.ambient = [0, 0, 0];
    this.opacity = 1.0;
    this.shininess = 1.0;
    this.max_smooth = 60.0;
    this.name = mat_name;
  }

};

Material.prototype.setTexture = function(tex, tex_type) {
  if (tex_type === undef) {
    tex_type = 0;
  }
  this.textures[tex_type] = tex;
};



Material.prototype.calcShaderMask = function() {
  var shader_mask = 0;

  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.COLOR]) === 'object') ? enums.shader.map.COLOR : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.SPECULAR]) === 'object') ? enums.shader.map.SPECULAR : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.NORMAL]) === 'object') ? enums.shader.map.NORMAL : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.BUMP]) === 'object') ? enums.shader.map.BUMP : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.REFLECT]) === 'object') ? enums.shader.map.REFLECT : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.ENVSPHERE]) === 'object') ? enums.shader.map.ENVSPHERE : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.AMBIENT]) === 'object') ? enums.shader.map.AMBIENT : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.ALPHA]) === 'object') ? enums.shader.map.ALPHA : 0);
  shader_mask = shader_mask + ((this.opacity !== 1.0) ? enums.shader.map.ALPHA : 0);

  return shader_mask;
};


Material.prototype.getShaderHeader = function(light_type,light_count) {
  return ((light_count !== undef) ? ("#define loopCount "+light_count+"\n"):"") +
  "#define hasColorMap " + ((typeof(this.textures[enums.texture.map.COLOR]) === 'object') ? 1 : 0) + 
  "\n#define hasSpecularMap " + ((typeof(this.textures[enums.texture.map.SPECULAR]) === 'object') ? 1 : 0) + 
  "\n#define hasNormalMap " + ((typeof(this.textures[enums.texture.map.NORMAL]) === 'object') ? 1 : 0) + 
  "\n#define hasBumpMap " + ((typeof(this.textures[enums.texture.map.BUMP]) === 'object') ? 1 : 0) + 
  "\n#define hasReflectMap " + ((typeof(this.textures[enums.texture.map.REFLECT]) === 'object') ? 1 : 0) + 
  "\n#define hasEnvSphereMap " + ((typeof(this.textures[enums.texture.map.ENVSPHERE]) === 'object') ? 1 : 0) + 
  "\n#define hasAmbientMap " + ((typeof(this.textures[enums.texture.map.AMBIENT]) === 'object') ? 1 : 0) + 
  "\n#define hasAlphaMap " + ((typeof(this.textures[enums.texture.map.ALPHA]) === 'object') ? 1 : 0) + 
  "\n#define hasAlpha " + ((this.opacity !== 1.0) ? 1 : 0) + 
  "\n#define lightPoint " + ((light_type === enums.light.type.POINT) ? 1 : 0) + 
  "\n#define lightDirectional " + ((light_type === enums.light.type.DIRECTIONAL) ? 1 : 0) + 
  "\n#define lightSpot " + (((light_type === enums.light.type.SPOT)||(light_type === enums.light.type.SPOT_SHADOW)) ? 1 : 0) + 
  "\n#define hasShadow " + (((light_type === enums.light.type.SPOT_SHADOW)||(light_type === enums.light.type.AREA)) ? 1 : 0) + 
  "\n#define softShadow " + (GLCore.soft_shadow?1:0) +
  "\n#define lightArea " + ((light_type === enums.light.type.AREA) ? 1 : 0) + 
  "\n#define depthPack " + ((light_type === enums.light.type.DEPTH_PACK) ? 1 : 0) + 
  "\n#define alphaDepth " + (GLCore.depth_alpha ? 1 : 0) + 
  "\n\n";
};


Material.prototype.bindObject = function(obj_in, light_shader) {
  var gl = GLCore.gl;
  
  var u = light_shader;
  var up = u.aVertexPosition;
  var uv = u.aTextureCoord; 
  var un = u.aNormal; 

  gl.bindBuffer(gl.ARRAY_BUFFER, obj_in.compiled.gl_points);
  gl.vertexAttribPointer(up, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(up);

  if (obj_in.compiled.gl_uvs!==null && uv !==-1) {
    gl.bindBuffer(gl.ARRAY_BUFFER, obj_in.compiled.gl_uvs);
    gl.vertexAttribPointer(uv, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(uv);
  } 

  if (obj_in.compiled.gl_normals!==null && un !==-1) {
    gl.bindBuffer(gl.ARRAY_BUFFER, obj_in.compiled.gl_normals);
    gl.vertexAttribPointer(un, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(un);
  }

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj_in.compiled.gl_elements);
};

Material.prototype.clearObject = function(obj_in,light_shader) {
  var gl = GLCore.gl;

  var u = light_shader;
  var uv = u.aTextureCoord; 
  var un = u.aNormal; 
  
  if (obj_in.compiled.gl_uvs!==null && uv !==-1) {
      gl.disableVertexAttribArray(uv);
  }

  if (obj_in.compiled.gl_normals!==null && un !==-1) {
      gl.disableVertexAttribArray(un);    
  }

}


Material.prototype.use = function(light_type,num_lights) {
  if (num_lights === undef) {
    num_lights = 0;
  }
  
  if (this.customShader !== null) {
    this.customShader.use();
    return;
  }

  if (light_type === undef) {
    light_type = 0;
  }

  var m;
  var thistex = this.textures;
  
  if (this.shader[light_type] === undef) {
     this.shader[light_type] = [];
  }

  if (this.shader[light_type][num_lights] === undef) {
    
    var smask = this.calcShaderMask(light_type);
    
    if (ShaderPool[light_type][smask] === undef) {
      ShaderPool[light_type][smask] = [];
    }
    
    if (ShaderPool[light_type][smask][num_lights] === undef) {
      var hdr = this.getShaderHeader(light_type,num_lights);
      var vs = hdr + GLCore.CoreShader_vs;
      var fs = hdr + GLCore.CoreShader_fs;

      var l = new Shader(vs, fs);
      
      ShaderPool[light_type][smask][num_lights] = l;
      
      m = 0;

      if (light_type !== enums.light.type.DEPTH_PACK) {
        if ((light_type === enums.light.type.SPOT_SHADOW)||(light_type === enums.light.type.AREA)) {
          m+=num_lights;  // leave room for shadow map..
        }
        
        if (typeof(thistex[enums.texture.map.COLOR]) === 'object') {
          l.addInt("colorMap", m++);
        }
        if (typeof(thistex[enums.texture.map.ENVSPHERE]) === 'object') {
          l.addInt("envSphereMap", m++);
        }
        if (typeof(thistex[enums.texture.map.NORMAL]) === 'object') {
          l.addInt("normalMap", m++);
        }
        if (typeof(thistex[enums.texture.map.BUMP]) === 'object') {
          l.addInt("bumpMap", m++);
        }
        if (typeof(thistex[enums.texture.map.REFLECT]) === 'object') {
          l.addInt("reflectMap", m++);
        }
        if (typeof(thistex[enums.texture.map.SPECULAR]) === 'object') {
          l.addInt("specularMap", m++);
        }
        if (typeof(thistex[enums.texture.map.AMBIENT]) === 'object') {
          l.addInt("ambientMap", m++);
        }
      }

      if (typeof(thistex[enums.texture.map.ALPHA]) === 'object') {
        l.addInt("alphaMap", m++);
      }

      l.addMatrix("uMVMatrix");
      l.addMatrix("uPMatrix");
      l.addMatrix("uOMatrix");
      l.addMatrix("uNMatrix");

      l.addVertexArray("aVertexPosition");
      l.addVertexArray("aNormal");

      for (var mLight = 0; mLight < num_lights; mLight++) {
        l.addVector("lights["+mLight+"].lDiff");
        l.addVector("lights["+mLight+"].lSpec");
        l.addFloat("lights["+mLight+"].lInt");
        l.addFloat("lights["+mLight+"].lDist");
        l.addVector("lights["+mLight+"].lPos");
        l.addVector("lights["+mLight+"].lDir");
        if ((light_type === enums.light.type.SPOT_SHADOW)||(light_type === enums.light.type.SPOT)) {
          l.addFloat("lights["+mLight+"].lCut");
        }
        if ((light_type === enums.light.type.SPOT_SHADOW)||(light_type === enums.light.type.AREA)) {
          l.addInt("lDepthTex["+mLight+"]");
          l.addVector("lDepth["+mLight+"]");
          l.addMatrix("spMatrix["+mLight+"]");
        }
      }

      if (light_type !== enums.light.type.DEPTH_PACK) {  // not needed for depth packing stage

        l.addVector("lAmb");
        l.addVector("mDiff");
        l.addVector("mColor");
        l.addVector("mAmb");
        l.addVector("mSpec");
        l.addFloat("mShine");
        l.addFloat("envAmount");
        
      } // !DEPTH_PACK

      l.addFloat("mAlpha");      
      
      if (GLCore.depth_alpha || (light_type === enums.light.type.DEPTH_PACK) || (light_type === enums.light.type.SPOT_SHADOW) || (light_type === enums.light.type.AREA)) {
        l.addVector("depthInfo");
      }

      l.addUVArray("aTextureCoord");
    }
    
    this.shader[light_type][num_lights] = ShaderPool[light_type][smask][num_lights];
  }

  var sh = this.shader[light_type][num_lights];
  var gl = GLCore.gl

  sh.use();

  m = 0;
  var t;
  
  if (light_type !== enums.light.type.DEPTH_PACK) {
  
    if ((light_type === enums.light.type.SPOT_SHADOW)||(light_type === enums.light.type.AREA)) {
      m+=num_lights;  // leave room for shadow map..
    }

    if (t = thistex[enums.texture.map.COLOR]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.ENVSPHERE]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
      // sh.setFloat("envAmount", this.env_amount);
      gl.uniform1f(sh.envAmount,this.env_amount);
    }
    if (t = thistex[enums.texture.map.NORMAL]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.BUMP]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.REFLECT]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.SPECULAR]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.AMBIENT]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
  }

  if (t = thistex[enums.texture.map.ALPHA]) {
    t.use(GLCore.gl.TEXTURE0+m); m++;
  }

  // sh.setVector("mColor", this.color);
  // sh.setVector("mDiff", this.diffuse);
  // sh.setVector("mAmb", this.ambient);
  // sh.setVector("mSpec", this.specular);
  // sh.setFloat("mShine", this.shininess);
  // sh.setVector("lAmb", CubicVR.globalAmbient);

  if (light_type !== enums.light.type.DEPTH_PACK) {  
    gl.uniform3fv(sh.mColor,this.color);
    gl.uniform3fv(sh.mDiff,this.diffuse);
    gl.uniform3fv(sh.mAmb,this.ambient);
    gl.uniform3fv(sh.mSpec,this.specular);
    gl.uniform1f(sh.mShine,this.shininess*128.0);
    gl.uniform3fv(sh.lAmb, CubicVR.globalAmbient);
  

    if (GLCore.depth_alpha || (light_type === enums.light.type.SPOT_SHADOW) || (light_type === enums.light.type.AREA)) {
      //sh.setVector("depthInfo", [GLCore.depth_alpha_near, GLCore.depth_alpha_far, 0.0]);
      gl.uniform3fv(sh.depthInfo, [GLCore.depth_alpha_near, GLCore.depth_alpha_far, 0.0]);
    }
  }
  else { // Depth Pack
    gl.uniform3fv(sh.depthInfo, [GLCore.shadow_near, GLCore.shadow_far, 0.0]);
  }
  
  if (this.opacity !== 1.0) {
    gl.uniform1f(sh.mAlpha, this.opacity);
  }
};

/* Textures */
var DeferredLoadTexture = function(img_path, filter_type) {
  this.img_path = img_path;
  this.filter_type = filter_type;
} //DefferedLoadTexture

DeferredLoadTexture.prototype.getTexture = function(deferred_bin, binId) {
  return new Texture(this.img_path, this.filter_type, deferred_bin, binId);
} //getTexture

var Texture = function(img_path,filter_type,deferred_bin,binId,ready_func) {
  var gl = GLCore.gl;

  this.tex_id = Textures.length;
  this.filterType = -1;
  this.onready = ready_func;
  this.loaded = false;
  Textures[this.tex_id] = gl.createTexture();
  Textures_obj[this.tex_id] = this;

  if (img_path) {
    Images[this.tex_id] = new Image();
    Texture_ref[img_path] = this.tex_id;
  }

  gl.bindTexture(gl.TEXTURE_2D, Textures[this.tex_id]);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  if (img_path) {
    var texId = this.tex_id;
    var filterType = (filter_type!==undef)?filter_type:GLCore.default_filter;
    
    var that = this;

    Images[this.tex_id].onload = function() {
      gl.bindTexture(gl.TEXTURE_2D, Textures[texId]);

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);

      var img = Images[texId];

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

      var tw = img.width, th = img.height;
      
      var isPOT = true;
      
      if (tw===1||th===1) {
        isPOT = false;
      } else {
        if (tw!==1) { while ((tw % 2) === 0) { tw /= 2; } }
        if (th!==1) { while ((th % 2) === 0) { th /= 2; } }
        if (tw>1) { isPOT = false; }
        if (th>1) { isPOT = false; }        
      }

      if (!isPOT) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      }

      if (Textures_obj[texId].filterType===-1) {
        if (!isPOT) {
          if (filterType === enums.texture.filter.LINEAR_MIP) {
            filterType = enums.texture.filter.LINEAR;
          }
        }

        if (Textures_obj[texId].filterType===-1) {
          Textures_obj[texId].setFilter(filterType);      
        }
      }  
      else
      {
        Textures_obj[texId].setFilter(Textures_obj[texId].filterType);
      }        

      gl.bindTexture(gl.TEXTURE_2D, null);

      if (that.onready) {
        that.onready();
      } //if
      that.loaded = true;
    };

    if (!deferred_bin)
    {
    Images[this.tex_id].src = img_path;
  }
    else
    {
      Images[this.tex_id].deferredSrc = img_path;
      //console.log('adding image to binId=' + binId + ' img_path=' + img_path);
      deferred_bin.addImage(binId,img_path,Images[this.tex_id]);
    }
  }

  this.active_unit = -1;
};


Texture.prototype.setFilter = function(filterType) {
  var gl = CubicVR.GLCore.gl;

  gl.bindTexture(gl.TEXTURE_2D, Textures[this.tex_id]);

  if (filterType === enums.texture.filter.LINEAR) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  } else if (filterType === enums.texture.filter.LINEAR_MIP) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);      
  } else if (filterType === enums.texture.filter.NEAREST) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);  
  } else if (filterType === enums.texture.filter.NEAREST_MIP) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
      gl.generateMipmap(gl.TEXTURE_2D);      
  }

  this.filterType = filterType;
};

Texture.prototype.use = function(tex_unit) {
  GLCore.gl.activeTexture(tex_unit);
  GLCore.gl.bindTexture(GLCore.gl.TEXTURE_2D, Textures[this.tex_id]);
  this.active_unit = tex_unit;
};

Texture.prototype.clear = function() {
  if (this.active_unit !== -1) {
    GLCore.gl.activeTexture(this.active_unit);
    GLCore.gl.bindTexture(GLCore.gl.TEXTURE_2D, null);
    this.active_unit = -1;
  }
};

function CanvasTexture(options) {
  var gl = CubicVR.GLCore.gl;

  if ( options.nodeName === 'CANVAS' || options.nodeName === 'IMG' ) {
    this.canvasSource = options;
  }
  else {
    this.canvasSource = document.createElement('CANVAS');
    if (options.width === undefined || options.height === undefined) {
      throw new Error('Width and height must be specified for generating a new CanvasTexture.');
    } //if
    this.canvasSource.width = options.width;
    this.canvasSource.height = options.height;
    this.canvasContext = this.canvasSource.getContext('2d');
  } //if

  var c = this.canvasSource, tw = c.width, th = c.height;
  
  var isPOT = true;
  
  if (tw===1||th===1) {
    isPOT = false;
  } else {
    if (tw !== 1) { while ((tw % 2) === 0) { tw /= 2; } }
    if (th !== 1) { while ((th % 2) === 0) { th /= 2; } }
    if (tw > 1) { isPOT = false; }
    if (th > 1) { isPOT = false; }       
  }

  this.updateFunction = options.update;

  this.texture = new CubicVR.Texture();

  this.setFilter=this.texture.setFilter;
  this.clear=this.texture.clear;
  this.use=this.texture.use;
  this.tex_id=this.texture.tex_id;
  this.filterType=this.texture.filterType;

  if (!isPOT) {
    this.setFilter(enums.texture.filter.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);    
  } else {
    this.setFilter(enums.texture.filter.LINEAR_MIP);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);    
  }

  if ( options.nodeName === 'IMG' ) {
    this.update();
  } //if
}; //CanvasTexture

CanvasTexture.prototype.update = function() {
  if (this.updateFunction) {
    this.updateFunction(this.canvasSource, this.canvasContext);
  } //if

  var gl = CubicVR.GLCore.gl;
  gl.bindTexture(gl.TEXTURE_2D, CubicVR.Textures[this.texture.tex_id]);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvasSource);
  if (this.filterType === enums.texture.filter.LINEAR_MIP) {
    gl.generateMipmap(gl.TEXTURE_2D);          
  }
  gl.bindTexture(gl.TEXTURE_2D, null);
}; //CanvasTexture.update

function TextTexture(text, options) {
  var color = (options && options.color) || '#fff';
  var bgcolor = (options && options.bgcolor);
  var font = (options && options.font) || '18pt Arial';
  var align = (options && options.align) || 'start';
  var y = (options && options.y) || 0;
  var width = (options && options.width) || undef;
  var height = (options && options.height) || undef;
  
  var canvas = document.createElement('CANVAS');
  var ctx = canvas.getContext('2d');

  var lines = 0;
  if (typeof(text) === 'string') {
    lines = 1;
  }
  else {
    lines = text.length;
  } //if

  ctx.font = font;

  // This approximation is awful. There has to be a better way to find the height of a text block
  var lineHeight = (options && options.lineHeight) || ctx.measureText('OO').width;
  var widest;
  if (lines === 1) {
    widest = ctx.measureText(text).width;
  }
  else {
    widest = 0;
    for (var i=0; i<lines; ++i) {
      var w = ctx.measureText(text[i]).width;
      if (w > widest) {
        widest = w;
      } //if
    } //for
  } //if

  canvas.width = width || widest;
  canvas.height = height || lineHeight * lines;

  if (bgcolor) {
    ctx.fillStyle = bgcolor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } //if
  ctx.fillStyle = color;
  ctx.font = font;
  ctx.textAlign = align;
  ctx.textBaseline = 'top';
  if (lines === 1) {
    var x = (options && options.x) || align === 'center' ? canvas.width/2 : align === 'right' ? canvas.width : 0;
    ctx.fillText(text, x, y);
  }
  else {
    for (var i=0; i<lines; ++i) {
      var x = (options && options.x) || align === 'center' ? canvas.width/2 : align === 'right' ? canvas.width : 0;
      ctx.fillText(text[i], x, y+i*lineHeight);
    } //for
  } //if
  ctx.fill();

  this.use = CanvasTexture.prototype.use;
  this.clear = CanvasTexture.prototype.clear;
  this.update = CanvasTexture.prototype.update;
  CanvasTexture.apply(this, [canvas]);

  this.update();
  this.canvasSource = canvas = ctx = null;
}; //TextTexture

function PJSTexture(pjsURL, width, height) {
  var gl = CubicVR.GLCore.gl;
  this.texture = new CubicVR.Texture();
  this.canvas = document.createElement("CANVAS");
  this.canvas.width = width;
  this.canvas.height = height;
  
  // this assumes processing is already included..
  this.pjs = new Processing(this.canvas,CubicVR.util.getURL(pjsURL));
  this.pjs.noLoop();
  this.pjs.redraw();
  
  var tw = this.canvas.width, th = this.canvas.height;
  
  var isPOT = true;
  
  if (tw===1||th===1) {
    isPOT = false;
  } else {
    if (tw !== 1) { while ((tw % 2) === 0) { tw /= 2; } }
    if (th !== 1) { while ((th % 2) === 0) { th /= 2; } }
    if (tw > 1) { isPOT = false; }
    if (th > 1) { isPOT = false; }       
  }
  
  // bind functions to "subclass" a texture
  this.setFilter=this.texture.setFilter;
  this.clear=this.texture.clear;
  this.use=this.texture.use;
  this.tex_id=this.texture.tex_id;
  this.filterType=this.texture.filterType;


  if (!isPOT) {
    this.setFilter(enums.texture.filter.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);    
  } else {
    this.setFilter(enums.texture.filter.LINEAR_MIP);
  }
}

PJSTexture.prototype.update = function() {
  var gl = CubicVR.GLCore.gl;

  this.pjs.redraw();
 
  gl.bindTexture(gl.TEXTURE_2D, CubicVR.Textures[this.texture.tex_id]);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);
  
  if (this.filterType === enums.texture.filter.LINEAR_MIP) {
    gl.generateMipmap(gl.TEXTURE_2D);          
  }
  
  gl.bindTexture(gl.TEXTURE_2D, null); 
};


/* Render functions */


function cubicvr_renderObject(obj_in,camera,o_matrix,lighting) {

  if (obj_in.compiled===null) {
    return;
  }
  
  var ofs = 0;
  var gl = CubicVR.GLCore.gl;
  var numLights = (lighting === undef) ? 0: lighting.length;
  var mshader, last_ltype, l;
  var lcount = 0;
  var j;
  var mat = null;
//  var nullAmbient = [0,0,0];
//  var tmpAmbient = CubicVR.globalAmbient;
  
  var bound = false;
  
  gl.depthFunc(gl.LEQUAL);
  
  if (o_matrix === undef) { o_matrix = cubicvr_identity; }
  
  for (var ic = 0, icLen = obj_in.compiled.elements_ref.length; ic < icLen; ic++) {
    var i = obj_in.compiled.elements_ref[ic][0][0];

    mat = Materials[i];
        
    var len = 0;
    var drawn = false;
    
    if (mat.opacity !== 1.0) {
      gl.enable(gl.BLEND);
      gl.depthMask(0);
      gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
    } else {
      gl.depthMask(1);
      gl.disable(gl.BLEND);
      gl.blendFunc(gl.ONE,gl.ONE);
    }
    
    for (var jc = 0, jcLen = obj_in.compiled.elements_ref[ic].length; jc < jcLen; jc++) {
      j = obj_in.compiled.elements_ref[ic][jc][1];
      
      drawn = false;
      
      var this_len = obj_in.compiled.elements_ref[ic][jc][2];
      
      len += this_len;
      
      if (obj_in.segment_state[j]) {
        // ...
      } else if (len > this_len) {
        ofs += this_len*2;
        len -= this_len;
  
        // start lighting loop
         // start inner
        if (!numLights) {
         mat.use(0,0);

         gl.uniformMatrix4fv(mat.shader[0][0].uMVMatrix,false,camera.mvMatrix);
         gl.uniformMatrix4fv(mat.shader[0][0].uPMatrix,false,camera.pMatrix);
         gl.uniformMatrix4fv(mat.shader[0][0].uOMatrix,false,o_matrix);
         gl.uniformMatrix3fv(mat.shader[0][0].uNMatrix,false,camera.nMatrix);

         if (!bound) { mat.bindObject(obj_in,mat.shader[0][0]); bound = true; }

          gl.drawElements(gl.TRIANGLES, len, gl.UNSIGNED_SHORT, ofs);

        } else { 
          var subcount = 0;
          var blended = false;

          for (subcount = 0; subcount < numLights; )
          {
            nLights = numLights-subcount;
            if (nLights>MAX_LIGHTS) { 
              nLights=MAX_LIGHTS;
            }

            if (subcount>0 && !blended) {
              gl.enable(gl.BLEND);
              gl.blendFunc(gl.ONE,gl.ONE);
              gl.depthFunc(gl.EQUAL);
              blended = true;
            }

            mshader = undef;
            l = lighting[subcount];
            var lt = l.light_type

            for (lcount = 0; lcount < nLights; lcount++) {
              if (lighting[lcount+subcount].light_type!=lt) {
                nLights = lcount;
               break;
              }
            }

            mat.use(l.light_type,nLights);

            mshader = mat.shader[l.light_type][nLights];

            gl.uniformMatrix4fv(mshader.uMVMatrix,false,camera.mvMatrix);
            gl.uniformMatrix4fv(mshader.uPMatrix,false,camera.pMatrix);
            gl.uniformMatrix4fv(mshader.uOMatrix,false,o_matrix);
            gl.uniformMatrix3fv(mshader.uNMatrix,false,camera.nMatrix);

            if (!bound) { mat.bindObject(obj_in,mshader); bound = true; }

            for (lcount = 0; lcount < nLights; lcount++) {
              lighting[lcount+subcount].setupShader(mshader,lcount);
            }

            gl.drawElements(gl.TRIANGLES, len, gl.UNSIGNED_SHORT, ofs);
            // var err = gl.getError();
            // if (err) {
            //   var uv = mshader.uniforms["aTextureCoord"]; 
            //   var un = mshader.uniforms["aNormal"];
            //   console.log(obj_in.compiled.gl_uvs!==null,obj_in.compiled.gl_normals!==null, un, uv, len, ofs, subcount);
            //   
            //   throw new Error('webgl error on mesh: ' + obj_in.name);
            // }

            subcount += nLights;
          }

          if (blended)
          {
            gl.disable(gl.BLEND);
            gl.depthFunc(gl.LEQUAL);
          }
        }

        /// end inner
        
        
        ofs += len*2;  // Note: unsigned short = 2 bytes
        len = 0;      
        drawn = true;
      } else {
        ofs += len*2;
        len = 0;
      }
    }

    if (!drawn && obj_in.segment_state[j]) {
      // this is an exact copy/paste of above
      // start lighting loop
       // start inner
      if (!numLights) {
       mat.use(0,0);

       gl.uniformMatrix4fv(mat.shader[0][0].uMVMatrix,false,camera.mvMatrix);
       gl.uniformMatrix4fv(mat.shader[0][0].uPMatrix,false,camera.pMatrix);
       gl.uniformMatrix4fv(mat.shader[0][0].uOMatrix,false,o_matrix);
       gl.uniformMatrix3fv(mat.shader[0][0].uNMatrix,false,camera.nMatrix);

       if (!bound) { mat.bindObject(obj_in,mat.shader[0][0]); bound = true; }

        gl.drawElements(gl.TRIANGLES, len, gl.UNSIGNED_SHORT, ofs);

      } else { 
        var subcount = 0;
        var blended = false;

        for (subcount = 0; subcount < numLights; )
        {
          nLights = numLights-subcount;
          if (nLights>MAX_LIGHTS) { 
            nLights=MAX_LIGHTS;
          }

          if (subcount>0 && !blended) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE,gl.ONE);
            gl.depthFunc(gl.EQUAL);
            blended = true;
          }

          mshader = undef;
          l = lighting[subcount];
          var lt = l.light_type

          for (lcount = 0; lcount < nLights; lcount++) {
            if (lighting[lcount+subcount].light_type!=lt) {
              nLights = lcount;
             break;
            }
          }

          mat.use(l.light_type,nLights);

          mshader = mat.shader[l.light_type][nLights];

          gl.uniformMatrix4fv(mshader.uMVMatrix,false,camera.mvMatrix);
          gl.uniformMatrix4fv(mshader.uPMatrix,false,camera.pMatrix);
          gl.uniformMatrix4fv(mshader.uOMatrix,false,o_matrix);
          gl.uniformMatrix3fv(mshader.uNMatrix,false,camera.nMatrix);

          if (!bound) { mat.bindObject(obj_in,mshader); bound = true; }

          for (lcount = 0; lcount < nLights; lcount++) {
            lighting[lcount+subcount].setupShader(mshader,lcount);
          }

          gl.drawElements(gl.TRIANGLES, len, gl.UNSIGNED_SHORT, ofs);
          // var err = gl.getError();
          // if (err) {
          //   var uv = mshader.uniforms["aTextureCoord"]; 
          //   var un = mshader.uniforms["aNormal"];
          //   console.log(obj_in.compiled.gl_uvs!==null,obj_in.compiled.gl_normals!==null, un, uv, len, ofs, subcount);
          //   
          //   throw new Error('webgl error on mesh: ' + obj_in.name);
          // }

          subcount += nLights;
        }

        if (blended)
        {
          gl.disable(gl.BLEND);
          gl.depthFunc(gl.LEQUAL);
        }
      }

      /// end inner
      
      ofs += len*2;
    }
  }
  
  if (mat && mshader) {
    mat.clearObject(obj_in,mshader);
  }
  
  // gl.disableVertexAttribArray(0);
  // gl.disableVertexAttribArray(2);
  // gl.disableVertexAttribArray(3);
  
  gl.depthMask(1);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}


/* Procedural Objects */

function cubicvr_latheObject(obj_in, pointList, lathe_divisions, material, transform, uvmapper) {
  var slices = [];
  var sliceNum;

  var up = [0, 1, 0];
  var right = [1, 0, 0];
  var pos = [0, 0, 0];
  var pofs = obj_in.points.length;

  var i, j, jMax, k, kMax;

  sliceNum = 0;

  for (i = 0; i < M_TWO_PI; i += (M_TWO_PI / lathe_divisions)) {
    if (sliceNum === lathe_divisions) {
      break;
    }

    right = [Math.cos(i), 0, Math.sin(i)];

    for (j = 0, jMax = pointList.length; j < jMax; j++) {
      pos = vec3.add(vec3.multiply(right, pointList[j][0]), vec3.multiply(up, pointList[j][1]));

      if (slices[sliceNum] === undef) {
        slices[sliceNum] = [];
      }

      slices[sliceNum].push(pos);
    }

    sliceNum++;
  }

  var m = null;
  
  if (transform!==undef) m = (transform.getResult!==undef)?transform.getResult():transform;

  for (j = 0; j < lathe_divisions; j++) {
    for (k = 0, kMax = pointList.length; k < kMax; k++) {
      if (m) {
        obj_in.addPoint(mat4.vec3_multiply(slices[j][k], m));
      } else {
        obj_in.addPoint(slices[j][k]);
      }
    }
  }
  
  obj_in.setFaceMaterial(material);

  for (k = 0; k < lathe_divisions; k++) {
    for (j = 0, jMax = pointList.length - 1; j < jMax; j++) {
      var pt = j + (pointList.length * k);
      var pt_r = j + (pointList.length * ((k + 1) % (lathe_divisions)));

      if (vec3.equal(obj_in.points[pofs + pt], obj_in.points[pofs + pt_r])) {
        obj_in.addFace([pofs + pt + 1, pofs + pt_r + 1, pofs + pt_r]);
      } else if (vec3.equal(obj_in.points[pofs + pt + 1], obj_in.points[pofs + pt_r + 1])) {
        obj_in.addFace([pofs + pt, pofs + pt + 1, pofs + pt_r]);
      } else {
        obj_in.addFace([pofs + pt, pofs + pt + 1, pofs + pt_r + 1, pofs + pt_r]);
      }
    }
  }

  
  if (uvmapper !== undef)
  {
    var uvm = null;

    if (uvmapper.apply !== undef)
    {
      uvm = uvmapper;
    }
    else if (uvmapper)
    {
      uvm = new UVMapper(uvmapper);
    }

    if (uvm !== null)
    {
      // Calculate face normals (used for UV mapping and lighting), todo: face range+offset
      obj_in.calcNormals();

      uvm.apply(obj_in, material);  
    }
  }  

}

function cubicvr_planeObject(mesh, size, mat, transform, uvmapper) {
  var half_size = size*0.5;
  var pofs = mesh.points.length;

  mesh.setFaceMaterial(mat);

  if (transform !== undef) {
    var m = (transform.getResult!==undef)?transform.getResult():transform;
    mesh.addPoint([
      mat4.vec3_multiply([half_size, -half_size, 0],m),
      mat4.vec3_multiply([half_size, half_size, 0],m),
      mat4.vec3_multiply([-half_size, half_size, 0],m),
      mat4.vec3_multiply([-half_size, -half_size, 0],m)
    ]);
  }
  else {
    mesh.addPoint([
      [half_size, -half_size, 0],
      [half_size, half_size, 0],
      [-half_size, half_size, 0],
      [-half_size, -half_size, 0]
    ]);
  }
  mesh.addFace([
    [pofs+0, pofs+1, pofs+2, pofs+3], //back
    [pofs+3, pofs+2, pofs+1, pofs+0]  //front
  ]);

  if (uvmapper !== undef)
  {
    var uvm = null;

    if (uvmapper.apply !== undef)
    {
      uvm = uvmapper;
    }
    else if (uvmapper)
    {
      uvm = new UVMapper(uvmapper);
    }

    if (uvm !== null)
    {
      // Calculate face normals (used for UV mapping and lighting), todo: face range+offset
      mesh.calcNormals();

      uvm.apply(mesh, mat);  
    }
  }  

} //cubicvr_planeObject

function cubicvr_boxObject(boxObj, box_size, box_mat, transform, uvmapper) {
  var half_box = box_size / 2.0;
  var pofs = boxObj.points.length;
  
  boxObj.setFaceMaterial(box_mat);

  if (transform !== undef) {
    var m = (transform.getResult!==undef)?transform.getResult():transform;
    boxObj.addPoint([
      mat4.vec3_multiply([half_box, -half_box, half_box], m),
      mat4.vec3_multiply([half_box, half_box, half_box], m),
      mat4.vec3_multiply([-half_box, half_box, half_box], m),
      mat4.vec3_multiply([-half_box, -half_box, half_box], m),
      mat4.vec3_multiply([half_box, -half_box, -half_box], m),
      mat4.vec3_multiply([half_box, half_box, -half_box], m),
      mat4.vec3_multiply([-half_box, half_box, -half_box], m),
      mat4.vec3_multiply([-half_box, -half_box, -half_box], m)
      ]);
  } else {
    boxObj.addPoint([
      [half_box, -half_box, half_box],
      [half_box, half_box, half_box],
      [-half_box, half_box, half_box],
      [-half_box, -half_box, half_box],
      [half_box, -half_box, -half_box],
      [half_box, half_box, -half_box],
      [-half_box, half_box, -half_box],
      [-half_box, -half_box, -half_box]
      ]);

}

boxObj.addFace([
  [pofs + 0, pofs + 1, pofs + 2, pofs + 3],
  [pofs + 7, pofs + 6, pofs + 5, pofs + 4],
  [pofs + 4, pofs + 5, pofs + 1, pofs + 0],
  [pofs + 5, pofs + 6, pofs + 2, pofs + 1],
  [pofs + 6, pofs + 7, pofs + 3, pofs + 2],
  [pofs + 7, pofs + 4, pofs + 0, pofs + 3]
  ]);
  
  if (uvmapper !== undef)
  {
    var uvm = null;

    if (uvmapper.apply !== undef)
    {
      uvm = uvmapper;
    }
    else if (uvmapper)
    {
      uvm = new UVMapper(uvmapper);
    }

    if (uvm !== null)
    {
      // Calculate face normals (used for UV mapping and lighting), todo: face range+offset
      boxObj.calcNormals();

      uvm.apply(boxObj, box_mat);  
    }
  }  
}

function cubicvr_torusObject(mesh, inner_radius, outer_radius, lon, lat, material, transform, uvmapper) {
    var pointList = new Array();

    var thick = outer_radius-inner_radius;
    var radius = inner_radius+(thick)/2.0;

    // generate a circle on the right side (radius) of the X/Y axis, circle radius of (thick)
    var step = (M_TWO_PI / lat);
    var theta = 0;
    for (var i = 0; i <= lat; i ++) {
        pointList.push([radius + Math.cos(theta) * thick, Math.sin(theta) * thick, 0]);
        theta += step;
    }

    CubicVR.genLatheObject(mesh, pointList, lon, material, transform, uvmapper);
}


function cubicvr_coneObject(mesh, base, height, lon, material, transform, uvmapper) {
    CubicVR.genLatheObject(mesh, [[0,-height/2,0],[base/2.0,-height/2,0],[0,height/2,0]], lon, material, transform, uvmapper);
}


function cubicvr_cylinderObject(mesh, radius, height, lon, material, transform, uvmapper) {
    CubicVR.genLatheObject(mesh, [[0,-height/2,0],[radius,-height/2,0],[radius,height/2,0],[0,height/2,0]], lon, material, transform, uvmapper);
}

function cubicvr_sphereObject(mesh, radius, lon, lat, material, transform, uvmapper) {
    var pointList = new Array();

    lat = parseInt(lat /= 2);
    lon = parseInt(lon);

    // generate a half-circle on the right side of the x/y axis
    var step = (M_PI / lat);
    var theta = -M_HALF_PI;
    for (var i = 0; i <= lat; i ++) {
        pointList.push([Math.cos(theta) * radius, Math.sin(theta) * radius, 0]);
        theta += step;
    }

    CubicVR.genLatheObject(mesh, pointList, lon, material, transform, uvmapper);
}

var primitives = {
  
  lathe: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var pointList, lathe_divisions;
    
    if (obj_init.points==undef) return null;
    
    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    lathe_divisions = (obj_init.divisions!==undef)?obj_init.divisions:24;
    
    cubicvr_latheObject(obj_in,obj_init.points,lathe_divisions,material,transform,uvmapper);
    
    return obj_in;
  },
  box: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var size;
    
    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;
    
    size = (obj_init.size!==undef)?obj_init.size:1.0;

    cubicvr_boxObject(obj_in, size, material, transform, uvmapper);
    
    return obj_in;
  },
  plane: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var size;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    size = (obj_init.size!==undef)?obj_init.size:1.0;
 
    cubicvr_planeObject(obj_in, size, material, transform, uvmapper);
        
    return obj_in;
  },
  sphere: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var radius, lon, lat;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    radius = (obj_init.radius!==undef)?obj_init.radius:1.0;
    lon = (obj_init.lon!==undef)?obj_init.lon:24;
    lat = (obj_init.lat!==undef)?obj_init.lat:24;
    
    cubicvr_sphereObject(obj_in, radius, lon, lat, material, transform, uvmapper);
      
    return obj_in;    
  },
  torus: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var innerRadius, outerRadius, lon, lat;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    innerRadius = (obj_init.innerRadius!==undef)?obj_init.innerRadius:0.75;
    outerRadius = (obj_init.outerRadius!==undef)?obj_init.outerRadius:1.0;
    lon = (obj_init.lon!==undef)?obj_init.lon:24;
    lat = (obj_init.lat!==undef)?obj_init.lat:24;
    
    cubicvr_torusObject(obj_in, innerRadius, outerRadius, lon, lat, material, transform, uvmapper);
    
    return obj_in;    
  },
  cone: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var base, height, lon;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    base = (obj_init.base!==undef)?obj_init.base:1.0;
    height = (obj_init.height!==undef)?obj_init.height:1.0;
    lon = (obj_init.lon!==undef)?obj_init.lon:24;

    cubicvr_coneObject(obj_in, base, height, lon, material, transform, uvmapper);
    
    return obj_in;    
  },
  cylinder: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var radius, height;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    radius = (obj_init.radius!==undef)?obj_init.radius:1.0;
    height = (obj_init.height!==undef)?obj_init.height:1.0;
    lon = (obj_init.lon!==undef)?obj_init.lon:24;

    cubicvr_cylinderObject(obj_in, radius, height, lon, material, transform, uvmapper);
    
    return obj_in;    
  }
}



function Landscape(size_in, divisions_in_w, divisions_in_h, matRef_in) {
  this.doTransform = function() {};
  this.tMatrix = cubicvr_identity;

  this.parent = null;
  this.position = [0, 0, 0];
  this.scale = [1, 1, 1];
  this.size = size_in;
  this.divisions_w = divisions_in_w;
  this.divisions_h = divisions_in_h;
  this.matRef = matRef_in;
  this.children = null;

  this.obj = new Mesh();

  var i, j;

  if (this.divisions_w > this.divisions_h) {
    this.size_w = size_in;
    this.size_h = (size_in / this.divisions_w) * this.divisions_h;
  } else if (this.divisions_h > this.divisions_w) {
    this.size_w = (size_in / this.divisions_h) * this.divisions_w;
    this.size_h = size_in;
  } else {
    this.size_w = size_in;
    this.size_h = size_in;
  }

  for (j = -(this.size_h / 2.0); j < (this.size_h / 2.0); j += (this.size_h / this.divisions_h)) {
    for (i = -(this.size_w / 2.0); i < (this.size_w / 2.0); i += (this.size_w / this.divisions_w)) {
      this.obj.addPoint([i + ((this.size_w / (this.divisions_w)) / 2.0), 0, j + ((this.size_h / (this.divisions_h)) / 2.0)]);
    }
  }

  var k, l;

  this.obj.setFaceMaterial(this.matRef);

  for (l = 0; l < this.divisions_h - 1; l++) {
    for (k = 0; k < this.divisions_w - 1; k++) {
      this.obj.addFace([(k) + ((l + 1) * this.divisions_w),
                              (k + 1) + ((l) * this.divisions_w),
                                (k) + ((l) * this.divisions_w)]);

      this.obj.addFace([(k) + ((l + 1) * this.divisions_w),
                              (k + 1) + ((l + 1) * this.divisions_w),
                              (k + 1) + ((l) * this.divisions_w)]);
    }
  }
}

Landscape.prototype.getMesh = function() {
  return this.obj;
}

Landscape.prototype.setIndexedHeight = function(ipos, jpos, val) {
  obj.points[(ipos) + (jpos * this.divisions_w)][1] = val;
}

Landscape.prototype.mapGen = function(w_func, ipos, jpos, ilen, jlen) {
  var pt;
  
  if (ipos!==undef && jpos !==undef && ilen !==undef && jlen!==undef) {
    if (ipos>=this.divisions_w) return;
    if (jpos>=this.divisions_h) return;
    if (ipos+ilen>=this.divisions_w) ilen = this.divisions_w-1-ipos; 
    if (jpos+jlen>=this.divisions_h) jlen = this.divisions_h-1-jpos; 
    if (ilen<=0 || jlen<=0) return;

    for (var i = ipos, imax = ipos+ilen; i < imax; i++) {
      for (var j = jpos, jmax = jpos+jlen; j < jmax; j++) {
        pt = this.obj.points[(i) + (j * this.divisions_w)];
        
        pt[1] = w_func(pt[0],pt[2]);
      }
    }
  } else {
    for (var x = 0, xmax = this.obj.points.length; x < xmax; x++) {
      pt = this.obj.points[x];
      
      pt[1] = w_func(pt[0],pt[2]);
    }
  }
}


Landscape.prototype.getFaceAt = function(x, z) {
  if (typeof(x) === 'object') {
     return this.getFaceAt(x[0], x[2]);
  }
 
  var ofs_w = (this.size_w / 2.0) - ((this.size_w / (this.divisions_w)) / 2.0);
  var ofs_h = (this.size_h / 2.0) - ((this.size_h / (this.divisions_h)) / 2.0);

  var i = parseInt(Math.floor(((x + ofs_w) / this.size_w) * (this.divisions_w)), 10);
  var j = parseInt(Math.floor(((z + ofs_h) / this.size_h) * (this.divisions_h)), 10);

  if (i < 0) {
    return -1;
  }
  if (i >= this.divisions_w - 1) {
    return -1;
  }
  if (j < 0) {
    return -1;
  }
  if (j >= this.divisions_h - 1) {
    return -1;
  }

  var faceNum1 = parseInt(i + (j * (this.divisions_w - 1)), 10) * 2;
  var faceNum2 = parseInt(faceNum1 + 1, 10);

  var testPt = this.obj.points[this.obj.faces[faceNum1].points[0]];

  var slope = Math.abs(z - testPt[2]) / Math.abs(x - testPt[0]);

  if (slope >= 1.0) {
    return (faceNum1);
  } else {
    return (faceNum2);
  }
};


Landscape.prototype.getHeightValue = function(x, z) {

  if (typeof(x) === 'object') {
    return this.getHeightValue(x[0], x[2]);
  }

  var tmpFace;
  var tmpPoint;

  var faceNum = this.getFaceAt(x, z);

  if (faceNum === -1) {
    return 0;
  }

  tmpFace = this.obj.faces[faceNum];
  tmpPoint = this.obj.points[this.obj.faces[faceNum].points[0]];

  var tmpNorm = triangle.normal(this.obj.points[this.obj.faces[faceNum].points[0]], this.obj.points[this.obj.faces[faceNum].points[1]], this.obj.points[this.obj.faces[faceNum].points[2]]);

  var na = tmpNorm[0];
  var nb = tmpNorm[1];
  var nc = tmpNorm[2];

  var d = -(na * tmpPoint[0]) - (nb * tmpPoint[1]) - (nc * tmpPoint[2]);

  return (((na * x) + (nc * z) + d) / (-nb)); // add height ofs here
};


Landscape.prototype.orient = function(x, z, width, length, heading, center) {
  if (center === undef) {
    center = 0;
  }

  var xpos, zpos;
  var xrot, zrot;
  var heightsample = [];
  var xyzTmp;

  var halfw = width / 2.0;
  var halfl = length / 2.0;

  var mag = Math.sqrt(halfl * halfl + halfw * halfw);
  var ang = Math.atan2(halfl, halfw);

  heading *= (M_PI / 180.0);

  xpos = x + (Math.sin(heading) * center);
  zpos = z + (Math.cos(heading) * center);

  heightsample[0] = this.getHeightValue([xpos + mag * Math.cos(-ang - M_HALF_PI + heading), 0, zpos + mag * -Math.sin(-ang - M_HALF_PI + heading)]);
  heightsample[1] = this.getHeightValue([xpos + mag * Math.cos(ang - M_HALF_PI + heading), 0, zpos + mag * (-Math.sin(ang - M_HALF_PI + heading))]);
  heightsample[2] = this.getHeightValue([xpos + mag * Math.cos(-ang + M_HALF_PI + heading), 0, zpos + mag * (-Math.sin(-ang + M_HALF_PI + heading))]);
  heightsample[3] = this.getHeightValue([xpos + mag * Math.cos(ang + M_HALF_PI + heading), 0, zpos + mag * (-Math.sin(ang + M_HALF_PI + heading))]);

  xrot = -Math.atan2((heightsample[1] - heightsample[2]), width);
  zrot = -Math.atan2((heightsample[0] - heightsample[1]), length);

  xrot += -Math.atan2((heightsample[0] - heightsample[3]), width);
  zrot += -Math.atan2((heightsample[3] - heightsample[2]), length);

  xrot /= 2.0; // average angles
  zrot /= 2.0;


  return [[x, ((heightsample[2] + heightsample[3] + heightsample[1] + heightsample[0])) / 4.0, z], //
  [xrot * (180.0 / M_PI), heading, zrot * (180.0 / M_PI)]];
};

var scene_object_uuid = 0;

function SceneObject(obj, name) {
  var obj_init = null;
  
  if (obj!==undef && obj!==null)
  {
    if (obj.compile)
    {
      obj_init = null;
    } else {
      obj_init = obj;
    }    
  }

  if (obj_init) {
    this.position = (obj_init.position===undef)?[0, 0, 0]:obj_init.position;
    this.rotation = (obj_init.rotation===undef)?[0, 0, 0]:obj_init.rotation;
    this.scale = (obj_init.scale===undef)?[1, 1, 1]:obj_init.scale;

    this.motion = (obj_init.motion===undef)?null:obj_init.motion;
    this.obj = (obj_init.mesh===undef)?((obj !== undef && obj_init.faces !== undef) ? obj : null):obj_init.mesh;
    this.name = (obj_init.name===undef)?((name !== undef) ? name : null):obj_init.name;
  } else {
    this.position = [0, 0, 0];
    this.rotation = [0, 0, 0];
    this.scale = [1, 1, 1];

    this.motion = null;
    this.obj = obj;
    this.name = name;    
  }
  
  this.children = null;
  this.parent = null;

  this.drawn_this_frame = false;

  this.lposition = [0, 0, 0];
  this.lrotation = [0, 0, 0];
  this.lscale = [0, 0, 0];

  this.trans = new Transform();

  this.tMatrix = this.trans.getResult();

  this.dirty = true;

  this.aabb = [];

  this.id = -1;

  this.octree_leaves = [];
  this.octree_common_root = null;
  this.octree_aabb = [[0,0,0],[0,0,0]];
  AABB_reset(this.octree_aabb, [0,0,0]);
  this.ignore_octree = false;
  this.visible = true;
  this.culled = true;
  this.was_culled = true;

  this.dynamic_lights = [];
  this.static_lights = [];
}

SceneObject.prototype.doTransform = function(mat) {
  if (!vec3.equal(this.lposition, this.position) || !vec3.equal(this.lrotation, this.rotation) || !vec3.equal(this.lscale, this.scale) || (mat !== undef)) {

    this.trans.clearStack();

    if ((mat !== undef)) {
      this.trans.pushMatrix(mat);
    }

    this.trans.translate(this.position);

    if (! (this.rotation[0] === 0 && this.rotation[1] === 0 && this.rotation[2] === 0)) {
      this.trans.pushMatrix();
      this.trans.rotate(this.rotation);
    }

    if (! (this.scale[0] === 1 && this.scale[1] === 1 && this.scale[2] === 1)) {
      this.trans.pushMatrix();
      this.trans.scale(this.scale);
    }




    this.tMatrix = this.trans.getResult();

    this.lposition[0] = this.position[0];
    this.lposition[1] = this.position[1];
    this.lposition[2] = this.position[2];
    this.lrotation[0] = this.rotation[0];
    this.lrotation[1] = this.rotation[1];
    this.lrotation[2] = this.rotation[2];
    this.lscale[0] = this.scale[0];
    this.lscale[1] = this.scale[1];
    this.lscale[2] = this.scale[2];
    this.dirty = true;
  }
};

SceneObject.prototype.adjust_octree = function() {
  var aabb = this.getAABB();
  var taabb = this.octree_aabb;
  var px0 = aabb[0][0];
  var py0 = aabb[0][1];
  var pz0 = aabb[0][2];
  var px1 = aabb[1][0];
  var py1 = aabb[1][1];
  var pz1 = aabb[1][2];
  var tx0 = taabb[0][0];
  var ty0 = taabb[0][1];
  var tz0 = taabb[0][2];
  var tx1 = taabb[1][0];
  var ty1 = taabb[1][1];
  var tz1 = taabb[1][2];
  if (this.octree_leaves.length > 0 && (px0 < tx0 || py0 < ty0 || pz0 < tz0 || px1 > tx1 || py1 > ty1 || pz1 > tz1)) {
    for (var i = 0; i < this.octree_leaves.length; ++i) {
      this.octree_leaves[i].remove(this);
    } //for
    this.octree_leaves = [];
    this.static_lights = [];
    var common_root = this.octree_common_root;
    this.octree_common_root = null;
    if (common_root !== null) {

      while (true) {
        if (!common_root.contains_point(aabb[0]) || !common_root.contains_point(aabb[1])) {
          if (common_root._root !== undef && common_root._root !== null) {
            common_root = common_root._root;
          } else {
            break;
          } //if
        } else {
          break;
        } //if
      } //while
      AABB_reset(this.octree_aabb, this.position);
      common_root.insert(this);
    } //if
  } //if
}; //SceneObject::adjust_octree
SceneObject.prototype.bindChild = function(childSceneObj) {
  if (this.children === null) {
    this.children = [];
  }

  childSceneObj.parent = this;
  this.children.push(childSceneObj);
};


SceneObject.prototype.control = function(controllerId, motionId, value) {
  if (controllerId === enums.motion.POS) {
    this.position[motionId] = value;
  } else if (controllerId === enums.motion.SCL) {
    this.scale[motionId] = value;
  } else if (controllerId === enums.motion.ROT) {
    this.rotation[motionId] = value;
  }
};

SceneObject.prototype.getAABB = function() {
  if (this.dirty) {
    var p = new Array(8);

    this.doTransform();

    var aabbMin;
    var aabbMax;



    if (this.obj !== null)
    {
      if (this.obj.bb === null)
      {
        this.aabb = [vec3.add([-1,-1,-1],this.position),vec3.add([1,1,1],this.position)];
        return this.aabb;
      }

      aabbMin = this.obj.bb[0];
      aabbMax = this.obj.bb[1];
    }
    
    if (this.obj === null || aabbMin === undef || aabbMax === undef)
    {
      // aabbMin=[-1,-1,-1];
      // aabbMax=[1,1,1];      
      // 
      // if (this.obj.bb.length===0)
      // {
        this.aabb = [vec3.add([-1,-1,-1],this.position),vec3.add([1,1,1],this.position)];
        return this.aabb;
      // }
    }

    /*
    if (this.scale[0] !== 1 || this.scale[1] !== 1 || this.scale[2] !== 1) {
      aabbMin[0] *= this.scale[0];
      aabbMin[1] *= this.scale[1];
      aabbMin[2] *= this.scale[2];
      aabbMax[0] *= this.scale[0];
      aabbMax[1] *= this.scale[1];
      aabbMax[2] *= this.scale[2];
    }
    */

    var obj_aabb = aabbMin;
    var obj_bounds = vec3.subtract(aabbMax, aabbMin);

    p[0] = [obj_aabb[0], obj_aabb[1], obj_aabb[2]];
    p[1] = [obj_aabb[0], obj_aabb[1], obj_aabb[2] + obj_bounds[2]];
    p[2] = [obj_aabb[0] + obj_bounds[0], obj_aabb[1], obj_aabb[2]];
    p[3] = [obj_aabb[0] + obj_bounds[0], obj_aabb[1], obj_aabb[2] + obj_bounds[2]];
    p[4] = [obj_aabb[0], obj_aabb[1] + obj_bounds[1], obj_aabb[2]];
    p[5] = [obj_aabb[0], obj_aabb[1] + obj_bounds[1], obj_aabb[2] + obj_bounds[2]];
    p[6] = [obj_aabb[0] + obj_bounds[0], obj_aabb[1] + obj_bounds[1], obj_aabb[2]];
    p[7] = [obj_aabb[0] + obj_bounds[0], obj_aabb[1] + obj_bounds[1], obj_aabb[2] + obj_bounds[2]];

    var aabbTest;

    aabbTest = mat4.vec3_multiply(p[0], this.tMatrix);

    aabbMin = [aabbTest[0], aabbTest[1], aabbTest[2]];
    aabbMax = [aabbTest[0], aabbTest[1], aabbTest[2]];

    for (var i = 1; i < 8; ++i) {
      aabbTest = mat4.vec3_multiply(p[i], this.tMatrix);

      if (aabbMin[0] > aabbTest[0]) {
        aabbMin[0] = aabbTest[0];
      }
      if (aabbMin[1] > aabbTest[1]) {
        aabbMin[1] = aabbTest[1];
      }
      if (aabbMin[2] > aabbTest[2]) {
        aabbMin[2] = aabbTest[2];
      }

      if (aabbMax[0] < aabbTest[0]) {
        aabbMax[0] = aabbTest[0];
      }
      if (aabbMax[1] < aabbTest[1]) {
        aabbMax[1] = aabbTest[1];
      }
      if (aabbMax[2] < aabbTest[2]) {
        aabbMax[2] = aabbTest[2];
      }
    }

    this.aabb[0] = aabbMin;
    this.aabb[1] = aabbMax;

    this.dirty = false;
  }

  return this.aabb;
};

var cubicvr_env_range = function(v, lo, hi) {
  var v2, i = 0,
    r;

  r = hi - lo;

  if (r === 0.0) {
    return [lo, 0];
  }

  v2 = v - r * Math.floor((v - lo) / r);

  i = -parseInt((v2 - v) / r + (v2 > v ? 0.5 : -0.5), 10);

  return [v2, i];
};

var cubicvr_env_hermite = function(t) {
  var h1, h2, h3, h4;
  var t2, t3;

  t2 = t * t;
  t3 = t * t2;

  h2 = 3.0 * t2 - t3 - t3;
  h1 = 1.0 - h2;
  h4 = t3 - t2;
  h3 = h4 - t2 + t;

  return [h1, h2, h3, h4];
};

var cubicvr_env_bezier = function(x0, x1, x2, x3, t) {
  var a, b, c, t2, t3;

  t2 = t * t;
  t3 = t2 * t;

  c = 3.0 * (x1 - x0);
  b = 3.0 * (x2 - x1) - c;
  a = x3 - x0 - c - b;

  return a * t3 + b * t2 + c * t + x0;
};



var cubicvr_env_bez2_time = function(x0, x1, x2, x3, time, t0, t1) {

  var v, t;

  t = t0 + (t1 - t0) * 0.5;
  v = cubicvr_env_bezier(x0, x1, x2, x3, t);
  if (Math.abs(time - v) > 0.0001) {
    if (v > time) {
      t1 = t;
    } else {
      t0 = t;
    }
    return cubicvr_env_bez2_time(x0, x1, x2, x3, time, t0, t1);
  } else {
    return t;
  }
};



var cubicvr_env_bez2 = function(key0, key1, time)
{
   var x, y, t, t0 = 0.0, t1 = 1.0;

   if ( key0.shape === enums.envelope.shape.BEZ2 ) {
     
      x = key0.time + key0.param[ 2 ];
  } else {
      x = key0.time + ( key1.time - key0.time ) / 3.0;
    }
    
   t = cubicvr_env_bez2_time( key0.time, x, key1.time + key1.param[ 0 ], key1.time, time, t0, t1 );

   if ( key0.shape === enums.envelope.shape.BEZ2 ){
      y = key0.value + key0.param[ 3 ];
    }
   else {
      y = key0.value + key0.param[ 1 ] / 3.0;
    }

   return cubicvr_env_bezier( key0.value, y, key1.param[ 1 ] + key1.value, key1.value, t );
}


var cubicvr_env_outgoing = function(key0, key1) {
  var a, b, d, t, out;

  if (key0.shape === enums.envelope.shape.TCB) {
    a = (1.0 - key0.tension) * (1.0 + key0.continuity) * (1.0 + key0.bias);
    b = (1.0 - key0.tension) * (1.0 - key0.continuity) * (1.0 - key0.bias);
    d = key1.value - key0.value;

    if (key0.prev) {
      t = (key1.time - key0.time) / (key1.time - (key0.prev).time);
      out = t * (a * (key0.value - (key0.prev).value) + b * d);
    } else {
      out = b * d;
    }
  } else if (key0.shape === enums.envelope.shape.LINE) {
    d = key1.value - key0.value;
    if (key0.prev) {
      t = (key1.time - key0.time) / (key1.time - (key0.prev).time);
      out = t * (key0.value - (key0.prev).value + d);
    } else {
      out = d;
    }
  } else if ((key0.shape === enums.envelope.shape.BEZI)||(key0.shape === enums.envelope.shape.HERM)) {
    out = key0.param[1];
    if (key0.prev) {
      out *= (key1.time - key0.time) / (key1.time - (key0.prev).time);
    }
  } else if (key0.shape === enums.envelope.shape.BEZ2) {
    out = key0.param[3] * (key1.time - key0.time);
    if (Math.abs(key0.param[2]) > 1e-5) {
      out /= key0.param[2];
    } else {
      out *= 1e5;
    }
  } else if (key0.shape === enums.envelope.shape.STEP) {
    out = 0.0;    
  } else {
    out = 0.0;
  }

  return out;
};



var cubicvr_env_incoming = function(key0, key1) {
  var a, b, d, t, inval;

  if (key1.shape === enums.envelope.shape.LINE) {
    d = key1.value - key0.value;
    if (key1.next) {
      t = (key1.time - key0.time) / ((key1.next).time - key0.time);
      inval = t * ((key1.next).value - key1.value + d);
    } else {
      inval = d;
    }
  } else if (key1.shape === enums.envelope.shape.TCB) {
    a = (1.0 - key1.tension) * (1.0 - key1.continuity) * (1.0 + key1.bias);
    b = (1.0 - key1.tension) * (1.0 + key1.continuity) * (1.0 - key1.bias);
    d = key1.value - key0.value;

    if (key1.next) {
      t = (key1.time - key0.time) / ((key1.next).time - key0.time);
      inval = t * (b * ((key1.next).value - key1.value) + a * d);
    } else {
      inval = a * d;
    }
  } else if ((key1.shape === enums.envelope.shape.HERM) || (key1.shape === enums.envelope.shape.BEZI)) {
    inval = key1.param[0];
    if (key1.next) {
      inval *= (key1.time - key0.time) / ((key1.next).time - key0.time);
    }
  } else if (key1.shape === enums.envelope.shape.BEZ2) {    
    inval = key1.param[1] * (key1.time - key0.time);
    if (Math.abs(key1.param[0]) > 1e-5) {
      inval /= key1.param[0];
    } else {
      inval *= 1e5;
    }
  } else if (key1.shape === enums.envelope.shape.STEP) {
    inval = 0.0;    
  } else {
    inval = 0.0;
  }

  return inval;
};


function EnvelopeKey() {
  this.value = 0;
  this.time = 0;
  this.shape = enums.envelope.shape.TCB;
  this.tension = 0;
  this.continuity = 0;
  this.bias = 0;
  this.prev = null;
  this.next = null;

  this.param = [0,0,0,0];
}


function Envelope(obj_init) {
  this.nKeys = 0;
  this.keys = null;
  this.firstKey = null;
  this.lastKey = null;
  
  if (obj_init)
  {
    this.in_behavior = obj_init.in_behavior?obj_init.in_behavior:enums.envelope.behavior.CONSTANT;
    this.out_behavior = obj_init.out_behavior?obj_init.out_behavior:enums.envelope.behavior.CONSTANT;
  }
  else
  {
    this.in_behavior = enums.envelope.behavior.CONSTANT;
    this.out_behavior = enums.envelope.behavior.CONSTANT;
  }
}

Envelope.prototype.setBehavior = function(in_b, out_b) {
  this.in_behavior = in_b;
  this.out_behavior = out_b;
};


Envelope.prototype.empty = function() {
  return (this.nKeys === 0);
};


Envelope.prototype.addKey = function(time, value, key_init) {
  var tempKey;

  var obj = (typeof(time)=='object')?time:key_init;

  if (!value) value = 0;
  if (!time) time = 0;
  
  if (obj) {
    obj = time;
    time = obj.time;

    tempKey = this.insertKey(time);
    
    tempKey.value = obj.value?obj.value:value;
    tempKey.time = obj.time?obj.time:time;;
    tempKey.shape = obj.shape?obj.shape:enums.envelope.shape.TCB;
    tempKey.tension = obj.tension?obj.tension:0;
    tempKey.continuity = obj.continuity?obj.continuity:0;
    tempKey.bias = obj.bias?obj.bias:0;
    tempKey.param = obj.param?obj.param:[0,0,0,0];
    
  } else {
    tempKey = this.insertKey(time);    
    tempKey.value = value;
  }


  return tempKey;
};


Envelope.prototype.insertKey = function(time) {
  var tempKey = new EnvelopeKey();

  tempKey.time = time;
  if (!this.nKeys) {
    this.keys = tempKey;
    this.firstKey = tempKey;
    this.lastKey = tempKey;
    this.nKeys++;

    return tempKey;
  }

  var k1 = this.keys;

  while (k1) {
    // update first/last key
    if (this.firstKey.time > time) {
      this.firstKey = tempKey;
    } else if (this.lastKey.time < time) {
      this.lastKey = tempKey;
    }

    if (k1.time > tempKey.time) {
      tempKey.prev = k1.prev;
      if (tempKey.prev) {
        tempKey.prev.next = tempKey;
      }

      tempKey.next = k1;
      tempKey.next.prev = tempKey;

      this.nKeys++;
      
      return tempKey;
    } else if (!k1.next) {
      tempKey.prev = k1;
      k1.next = tempKey;

      this.nKeys++;

      return tempKey;
    }

    k1 = k1.next;
  }

  return null; // you should not be here, time and space has imploded
};

Envelope.prototype.evaluate = function(time) {
  var key0, key1, skey, ekey;
  var t, h1, h2, h3, h4, inval, out, offset = 0.0;
  var noff;

  /* if there's no key, the value is 0 */
  if (this.nKeys === 0) {
    return 0.0;
  }

  /* if there's only one key, the value is constant */
  if (this.nKeys === 1) {
    return (this.keys).value;
  }

  /* find the first and last keys */
  skey = this.firstKey;
  ekey = this.lastKey;

  var tmp, behavior;

  /* use pre-behavior if time is before first key time */
  if (time < skey.time) {
    behavior = this.in_behavior;

    if (behavior        === enums.envelope.behavior.RESET) {
      return 0.0;
    } else if (behavior === enums.envelope.behavior.CONSTANT) {
      return skey.value;
    } else if (behavior === enums.envelope.behavior.REPEAT) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
    } else if (behavior === enums.envelope.behavior.OCILLATE) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];

      if (noff % 2) {
        time = ekey.time - skey.time - time;
      }
    } else if (behavior === enums.envelope.behavior.OFFSET) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];
      offset = noff * (ekey.value - skey.value);
    } else if (behavior === enums.envelope.behavior.LINEAR) {
      out = cubicvr_env_outgoing(skey, skey.next) / (skey.next.time - skey.time);
      return out * (time - skey.time) + skey.value;
    } 

  }

  /* use post-behavior if time is after last key time */
  else if (time > ekey.time) {
    behavior = this.out_behavior;

    if (behavior        === enums.envelope.behavior.RESET) {
      return 0.0;
    } else if (behavior === enums.envelope.behavior.CONSTANT) {
      return ekey.value;
    } else if (behavior === enums.envelope.behavior.REPEAT) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
    } else if (behavior === enums.envelope.behavior.OCILLATE) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];

      if (noff % 2) {
        time = ekey.time - skey.time - time;
      }
    } else if (behavior === enums.envelope.behavior.OFFSET) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];
      offset = noff * (ekey.value - skey.value);
    } else if (behavior === enums.envelope.behavior.LINEAR) {
      inval = cubicvr_env_incoming(ekey.prev, ekey) / (ekey.time - ekey.prev.time);
      return inval * (time - ekey.time) + ekey.value;
    } 
  }

  // get the endpoints of the interval being evaluated
  
  // if we have a last key, it's likely we haven't moved far on the list
  if (this.lastKey0) {
    if (time > this.lastKey0.time) {
      key0 = this.lastKey0;
    } else if (time < this.lastKey0.time) {
      key0 = this.lastKey;
      while (time < key0.time && key0.prev) {
        key0 = key0.prev;
      }
    } else {
      key0 = this.keys;
    }
  } else {
    key0 = this.keys;    
  }

  while (time > key0.next.time) {
    key0 = key0.next;
  }

  key1 = key0.next;

  // cache last key
  this.lastKey0 = key0;


  // check for singularities first
  if (time === key0.time) {
    return key0.value + offset;
  } else if (time === key1.time) {
    return key1.value + offset;
  }

  // get interval length, time in [0, 1]
  t = (time - key0.time) / (key1.time - key0.time);

  // interpolate

  var keyShape = key1.shape;

  if (keyShape === enums.envelope.shape.TCB || keyShape === enums.envelope.shape.BEZI || keyShape === enums.envelope.shape.HERM) {
    out = cubicvr_env_outgoing(key0, key1);
    inval = cubicvr_env_incoming(key0, key1);
    var h = cubicvr_env_hermite(t);
    return h[0] * key0.value + h[1] * key1.value + h[2] * out + h[3] * inval + offset;
  } else if (keyShape === enums.envelope.shape.BEZ2) {
    return cubicvr_env_bez2(key0, key1, time) + offset;
  } else if (keyShape === enums.envelope.shape.LINE) {
    return key0.value + t * (key1.value - key0.value) + offset;
  } else if (keyShape === enums.envelope.shape.STEP) {
    return key0.value + offset;
  } else {
    return offset;
  }
};

function Motion(env_init, key_init) {
  this.env_init = env_init;
  this.key_init = key_init;
  this.controllers = [];
  this.yzflip = false;
//  this.rscale = 1;
}

Motion.prototype.envelope = function(controllerId, motionId) {
  if (this.controllers[controllerId] === undef) {
    this.controllers[controllerId] = [];
  }
  if (this.controllers[controllerId][motionId] === undef) {
    this.controllers[controllerId][motionId] = new Envelope(this.env_init);
  }

  return this.controllers[controllerId][motionId];
};

Motion.prototype.evaluate = function(index) {
  var retArr = [];

  for (var i in this.controllers) {
    if (this.controllers.hasOwnProperty(i)) {
      retArr[i] = [];

      for (var j in this.controllers[i]) {
        if (this.controllers[i].hasOwnProperty(j)) {
          retArr[i][j] = this.controllers[i][j].evaluate(index);
        }
      }
    }
  }

  return retArr;
};

Motion.prototype.apply = function(index, target) {
  for (var i in this.controllers) {
    if (this.controllers.hasOwnProperty(i)) {
      var ic = parseInt(i, 10);

      /* Special case quaternion fix for ZY->YZ rotation envelopes */
      if (this.yzflip && ic === enums.motion.ROT) // assume channel 0,1,2
      {
        if (!this.q) {
          this.q = new Quaternion();
        }
        var q = this.q;

        var x = this.controllers[i][0].evaluate(index);
        var y = this.controllers[i][1].evaluate(index);
        var z = this.controllers[i][2].evaluate(index);

        //q.fromEuler(x*this.rscale, z*this.rscale, -y*this.rscale);
        q.fromEuler(x, z, -y);


        var qr = q.toEuler();

        target.control(ic, 0, qr[0]);
        target.control(ic, 1, qr[1]);
        target.control(ic, 2, qr[2]);
      }
      else {
        for (var j in this.controllers[i]) {
          if (this.controllers[i].hasOwnProperty(j)) {
            target.control(ic, parseInt(j, 10), this.controllers[i][j].evaluate(index));
          }
        }
      }
    }
  }
};


Motion.prototype.setKey = function(controllerId, motionId, index, value, key_init) {
  var ev = this.envelope(controllerId, motionId);
  return ev.addKey(index, value, key_init?key_init:this.key_init);
};

Motion.prototype.setArray = function(controllerId, index, value, key_init) {
  var tmpKeys = [];

  for (var i in value) {
    if (value.hasOwnProperty(i)) {
      var ev = this.envelope(controllerId, i);
      tmpKeys[i] = ev.addKey(index, value[i], key_init?key_init:this.key_init);
    }
  }

  return tmpKeys;
};


Motion.prototype.setBehavior = function(controllerId, motionId, behavior_in, behavior_out) {
  var ev = this.envelope(controllerId, motionId);
  ev.setBehavior(behavior_in, behavior_out);
};


Motion.prototype.setBehaviorArray = function(controllerId, behavior_in, behavior_out) {
  for (var motionId in this.controllers[controllerId]) {
    if (this.controllers[controllerId].hasOwnProperty(motionId)) {
      var ev = this.envelope(controllerId, motionId);
      ev.setBehavior(behavior_in, behavior_out);
    }
  }
};



function cubicvr_nodeToMotion(node, controllerId, motion) {
  var c = [];
  c[0] = node.getElementsByTagName("x");
  c[1] = node.getElementsByTagName("y");
  c[2] = node.getElementsByTagName("z");
  c[3] = node.getElementsByTagName("fov");

  var etime, evalue, ein, eout, etcb;

  for (var k in c) {
    if (c.hasOwnProperty(k)) {
      if (c[k] !== undef) {
        if (c[k].length) {
          etime = c[k][0].getElementsByTagName("time");
          evalue = c[k][0].getElementsByTagName("value");
          ein = c[k][0].getElementsByTagName("in");
          eout = c[k][0].getElementsByTagName("out");
          etcb = c[k][0].getElementsByTagName("tcb");

          var time = null,
            value = null,
            tcb = null;

          var intype = null,
            outtype = null;

          if (ein.length) {
            intype = util.collectTextNode(ein[0]);
          }

          if (eout.length) {
            outtype = util.collectTextNode(eout[0]);
          }

          if (etime.length) {
            time = util.floatDelimArray(util.collectTextNode(etime[0]), " ");
          }

          if (evalue.length) {
            value = util.floatDelimArray(util.collectTextNode(evalue[0]), " ");
          }

          if (etcb.length) {
            tcb = util.floatDelimArray(util.collectTextNode(etcb[0]), " ");
          }


          if (time !== null && value !== null) {
            for (var i = 0, iMax = time.length; i < iMax; i++) {
              var mkey = motion.setKey(controllerId, k, time[i], value[i]);

              if (tcb) {
                mkey.tension = tcb[i * 3];
                mkey.continuity = tcb[i * 3 + 1];
                mkey.bias = tcb[i * 3 + 2];
              }
            }
          }

          var in_beh = enums.envelope.behavior.CONSTANT;
          var out_beh = enums.envelope.behavior.CONSTANT;

          if (intype) {
            switch (intype) {
            case "reset":
              in_beh = enums.envelope.behavior.RESET;
              break;
            case "constant":
              in_beh = enums.envelope.behavior.CONSTANT;
              break;
            case "repeat":
              in_beh = enums.envelope.behavior.REPEAT;
              break;
            case "oscillate":
              in_beh = enums.envelope.behavior.OSCILLATE;
              break;
            case "offset":
              in_beh = enums.envelope.behavior.OFFSET;
              break;
            case "linear":
              in_beh = enums.envelope.behavior.LINEAR;
              break;
            }
          }

          if (outtype) {
            switch (outtype) {
            case "reset":
              out_beh = enums.envelope.behavior.RESET;
              break;
            case "constant":
              out_beh = enums.envelope.behavior.CONSTANT;
              break;
            case "repeat":
              out_beh = enums.envelope.behavior.REPEAT;
              break;
            case "oscillate":
              out_beh = enums.envelope.behavior.OSCILLATE;
              break;
            case "offset":
              out_beh = enums.envelope.behavior.OFFSET;
              break;
            case "linear":
              out_beh = enums.envelope.behavior.LINEAR;
              break;
            }
          }

          motion.setBehavior(controllerId, k, in_beh, out_beh);
        }
      }
    }
  }
}


function cubicvr_isMotion(node) {
  if (node === null) {
    return false;
  }

  return (node.getElementsByTagName("x").length || node.getElementsByTagName("y").length || node.getElementsByTagName("z").length || node.getElementsByTagName("fov").length);
}

/***********************************************
 * Plane
 ***********************************************/

function Plane() {
  this.a = 0;
  this.b = 0;
  this.c = 0;
  this.d = 0;
} //Plane::Constructor
Plane.prototype.classify_point = function(pt) {
  var dist = (this.a * pt[0]) + (this.b * pt[1]) + (this.c * pt[2]) + (this.d);
  if (dist < 0) {
    return -1;
  }
  if (dist > 0) {
    return 1;
  }
  return 0;
}; //Plane::classify_point
Plane.prototype.normalize = function() {
  var mag = Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
  this.a = this.a / mag;
  this.b = this.b / mag;
  this.c = this.c / mag;
  this.d = this.d / mag;
}; //Plane::normalize
Plane.prototype.toString = function() {
  return "[Plane " + this.a + ", " + this.b + ", " + this.c + ", " + this.d + "]";
}; //Plane::toString
/***********************************************
 * Sphere
 ***********************************************/

function Sphere(position, radius) {
  this.position = position;
  if (this.position === undef) {
    this.position = [0, 0, 0];
  }
  this.radius = radius;
} //Sphere::Constructor
Sphere.prototype.intersects = function(other_sphere) {
  var diff = vec3.subtract(this.position, other_sphere.position);
  var mag = Math.sqrt(diff[0] * diff[0] + diff[1] * diff[1] + diff[2] * diff[2]);
  var sum_radii = this.radius + other_sphere.radius;
  if (mag * mag < sum_radii * sum_radii) {
    return true;
  }
  return false;
}; //Sphere::intersects

function OctreeWorkerProxy(size, depth) {
  var that = this;
  this.size = size;
  this.depth = depth;
  this.worker = new CubicVR_Worker({
      message: function(e) {
        console.log('Octree Worker Message:', e);
      },
      error: function(e) {
        console.log('Octree Worker Error:', e);
      },
      type: 'octree'});
  this.worker.start();

  this.init = function(scene) {
    that.scene = scene;
    that.worker.init({
      size: that.size,
      max_depth: that.depth,
      camera: scene.camera
    });
  }; //init
  this.insert = function(node) {
    that.worker.send({message:'insert', node:node});
  }; //insert
  this.draw_on_map = function() {
    return;
  }; //draw_on_map
  this.reset_node_visibility = function() {
    return;
  }; //reset_node_visibility
  this.get_frustum_hits = function() {
  }; //get_frustum_hits
} //OctreeWorkerProxy

function Octree(size, max_depth, root, position, child_index) {
  this._children = [];
  this._dirty = false;
  this._children[0] = null;
  this._children[1] = null;
  this._children[2] = null;
  this._children[3] = null;
  this._children[4] = null;
  this._children[5] = null;
  this._children[6] = null;
  this._children[7] = null;

  if (child_index === undef) {
    this._child_index = -1;
  } else {
    this._child_index = child_index;
  }

  if (size === undef) {
    this._size = 0;
  } else {
    this._size = size;
  }

  if (max_depth === undef) {
    this._max_depth = 0;
  } else {
    this._max_depth = max_depth;
  }

  if (root === undef) {
    this._root = null;
  } else {
    this._root = root;
  }

  if (position === undef) {
    this._position = [0, 0, 0];
  } else {
    this._position = position;
  }

  this._nodes = [];
  //this._static_nodes = [];
  this._lights = [];
  this._static_lights = [];

  this._sphere = new Sphere(this._position, Math.sqrt(3 * (this._size / 2 * this._size / 2)));
  this._bbox = [[0,0,0],[0,0,0]];
  AABB_reset(this._bbox, this._position);

  var s = this._size/2;
  AABB_engulf(this._bbox, [this._position[0] + s, this._position[1] + s, this._position[2] + s]);
  AABB_engulf(this._bbox, [this._position[0] - s, this._position[1] - s, this._position[2] - s]);
  this._debug_visible = false;
} //Octree::Constructor
Array_remove = function(arr, from, to) {
  var rest = arr.slice((to || from) + 1 || arr.length);
  arr.length = from < 0 ? arr.length + from : from;
  return arr.push.apply(arr, rest);
};
Octree.prototype.destroy = function() {
  for (var i=0, li = this._static_lights.length; i<li; ++i) {
    var light = this._static_lights[i];
    light.octree_leaves = null;
    light.octree_common_root = null;
    light.octree_aabb = null;
  } //for
  for (var i=0, li = this._lights.length; i<li; ++i) {
    var light = this._lights[i];
    light.octree_leaves = null;
    light.octree_common_root = null;
    light.octree_aabb = null;
  } //for
  this._static_lights = null;
  this._lights = null;
  for (var i = 0, len = this._children.length; i < len; ++i) {
    if (this._children[i] !== null) {
      this._children[i].destroy();
    } //if
  } //for
  for (var i = 0, max_i = this._nodes.length; i < max_i; ++i) {
    var node = this._nodes[i];
    node.octree_leaves = null;
    node.octree_common_root = null;
    node.octree_aabb = null;
    node.dynamic_lights = [];
    node.static_lights = [];
  } //for
  this._children[0] = null;
  this._children[1] = null;
  this._children[2] = null;
  this._children[3] = null;
  this._children[4] = null;
  this._children[5] = null;
  this._children[6] = null;
  this._children[7] = null;
  this._children = null;
  this._root = null;
  this._position = null;
  this._nodes = null;
  this._lights = null;
  this._static_lights = null;
  this._sphere = null;
  this._bbox = null;
} //Octree::destroy
Octree.prototype.toString = function() {
  var real_size = [this._bbox[1][0] - this._bbox[0][0], this._bbox[1][2] - this._bbox[0][2]];
  return "[Octree: @" + this._position + ", depth: " + this._max_depth + ", size: " + this._size + ", nodes: " + this._nodes.length + ", measured size:" + real_size + "]";
}; //Octree::toString
Octree.prototype.remove = function(node) {
  var dont_check_lights = false;
  var len = this._nodes.length;
  var i;
  for (i = len - 1, len = this._nodes.length; i >= 0; --i) {
    if (node === this._nodes[i]) {
      Array_remove(this._nodes, i);
      this.dirty_lineage();
      dont_check_lights = true;
      break;
    } //if
  } //for
  if (!dont_check_lights) {
    for (i = len - 1, len = this._lights.length; i >= 0; --i) {
      if (node === this._lights[i]) {
        Array_remove(this._lights, i);
        this.dirty_lineage();
        break;
      } //if      
    } //for
  } //if
}; //Octree::remove
Octree.prototype.dirty_lineage = function() {
  this._dirty = true;
  if (this._root !== null) { this._root.dirty_lineage(); }
} //Octree::dirty_lineage
Octree.prototype.cleanup = function() {
  var num_children = this._children.length;
  var num_keep_children = 0;
  for (var i = 0; i < num_children; ++i) {
    var child = this._children[i];
    if (child !== null) {
      var keep = true;
      if (child._dirty === true) {
        keep = child.cleanup();
      } //if
      if (!keep) {
        this._children[i] = null;
      } else {
        ++num_keep_children;
      }
    } //if
  } //for
  if ((this._nodes.length === 0 && this._static_lights.length === 0 && this._lights.length === 0) && (num_keep_children === 0 || num_children === 0)) {
    return false;
  }
  return true;
}; //Octree::cleanup
Octree.prototype.insert_light = function(light) {
  this.insert(light, true);
}; //insert_light
Octree.prototype.propagate_static_light = function(light) {
  var i,l;
  for (i = 0, l = this._nodes.length; i < l; ++i) {
    if (this._nodes[i].static_lights.indexOf(light) === -1) {
      this._nodes[i].static_lights.push(light);
    } //if
  } //for
  for (i = 0; i < 8; ++i) {
    if (this._children[i] !== null) {
      this._children[i].propagate_static_light(light);
    } //if
  } //for
}; //propagate_static_light
Octree.prototype.collect_static_lights = function(node) {
  for (var i=0, li = this._static_lights.length; i<li; ++i) {
    if (node.static_lights.indexOf(this._static_lights[i]) === -1) {
      node.static_lights.push(this._static_lights[i]);
    } //if
  } //for
  for (var i = 0; i < 8; ++i) {
    if (this._children[i] !== null) {
      this._children[i].collect_static_lights(node);
    } //if
  } //for
}; //collect_static_lights
Octree.prototype.insert = function(node, is_light) {
  if (is_light === undef) { is_light = false; }
  function $insert(octree, node, is_light, root) {
    var i, li;
    if (is_light) {
      if (node.method === enums.light.method.STATIC) {
        if (octree._static_lights.indexOf(node) === -1) {
          octree._static_lights.push(node);
        } //if
        for (i=0; i<octree._nodes.length; ++i) {
          if (octree._nodes[i].static_lights.indexOf(node) === -1) {
            octree._nodes[i].static_lights.push(node);
          } //if
        } //for
        var root_tree = octree._root;
        while (root_tree !== null) {
          for (var i=0, l=root_tree._nodes.length; i<l; ++i) {
            var n = root_tree._nodes[i];
            if (n.static_lights.indexOf(node) === -1) {
              n.static_lights.push(node);
            } //if
          } //for
          root_tree = root_tree._root;
        } //while
      }
      else {
        if (octree._lights.indexOf(node) === -1) {
          octree._lights.push(node);
        } //if
      } //if
    } else {
      octree._nodes.push(node);
      for (i=0, li = octree._static_lights.length; i<li; ++i) {
        if (node.static_lights.indexOf(octree._static_lights[i]) === -1) {
          node.static_lights.push(octree._static_lights[i]);
        } //if
      } //for
      var root_tree = octree._root;
      while (root_tree !== null) {
        for (var i=0, l=root_tree._static_lights.length; i<l; ++i) {
          var light = root_tree._static_lights[i];
          if (node.static_lights.indexOf(light) === -1) {
            node.static_lights.push(light);
          } //if
        } //for
        root_tree = root_tree._root;
      } //while
    } //if
    node.octree_leaves.push(octree);
    node.octree_common_root = root;
    AABB_engulf(node.octree_aabb, octree._bbox[0]);
    AABB_engulf(node.octree_aabb, octree._bbox[1]);
  } //$insert
  if (this._root === null) {
    node.octree_leaves = [];
    node.octree_common_root = null;
  } //if
  if (this._max_depth === 0) {
    $insert(this, node, is_light, this._root);
    return;
  } //if
  //Check to see where the node is
  var p = this._position;
  var t_nw, t_ne, t_sw, t_se, b_nw, b_ne, b_sw, b_se;
  var aabb = node.getAABB();
  var min = [aabb[0][0], aabb[0][1], aabb[0][2]];
  var max = [aabb[1][0], aabb[1][1], aabb[1][2]];

  t_nw = min[0] < p[0] && min[1] < p[1] && min[2] < p[2];
  t_ne = max[0] > p[0] && min[1] < p[1] && min[2] < p[2];
  b_nw = min[0] < p[0] && max[1] > p[1] && min[2] < p[2];
  b_ne = max[0] > p[0] && max[1] > p[1] && min[2] < p[2];
  t_sw = min[0] < p[0] && min[1] < p[1] && max[2] > p[2];
  t_se = max[0] > p[0] && min[1] < p[1] && max[2] > p[2];
  b_sw = min[0] < p[0] && max[1] > p[1] && max[2] > p[2];
  b_se = max[0] > p[0] && max[1] > p[1] && max[2] > p[2];

  //Is it in every sector?
  if (t_nw && t_ne && b_nw && b_ne && t_sw && t_se && b_sw && b_se) {
    $insert(this, node, is_light, this);
    if (is_light) {
      if (node.method == enums.light.method.STATIC) {
        this.propagate_static_light(node);
      } //if
    }
    else {
      this.collect_static_lights(node);
    } //if
  } else {

    //Add static lights in this octree
    for (var i=0, ii=this._static_lights.length; i<ii; ++i) {
      if (node.static_lights === undef) node.static_lights = [];
      if (node.static_lights.indexOf(this._static_lights[i]) === -1) {
        node.static_lights.push(this._static_lights[i]);
      } //if
    } //for

    var new_size = this._size / 2;
    var offset = this._size / 4;
    var new_position;

    var num_inserted = 0;
    //Create & check children to see if node fits there too
    var x = this._position[0];
    var y = this._position[1];
    var z = this._position[2];
    if (t_nw) {
      new_position = [x - offset, y - offset, z - offset];
      if (this._children[enums.octree.TOP_NW] === null) {
        this._children[enums.octree.TOP_NW] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.TOP_NW);
      }
      this._children[enums.octree.TOP_NW].insert(node, is_light);
      ++num_inserted;
    } //if
    if (t_ne) {
      new_position = [x + offset, y - offset, z - offset];
      if (this._children[enums.octree.TOP_NE] === null) {
        this._children[enums.octree.TOP_NE] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.TOP_NE);
      }
      this._children[enums.octree.TOP_NE].insert(node, is_light);
      ++num_inserted;
    } //if
    if (b_nw) {
      new_position = [x - offset, y + offset, z - offset];
      if (this._children[enums.octree.BOTTOM_NW] === null) {
        this._children[enums.octree.BOTTOM_NW] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.BOTTOM_NW);
      }
      this._children[enums.octree.BOTTOM_NW].insert(node, is_light);
      ++num_inserted;
    } //if
    if (b_ne) {
      new_position = [x + offset, y + offset, z - offset];
      if (this._children[enums.octree.BOTTOM_NE] === null) {
        this._children[enums.octree.BOTTOM_NE] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.BOTTOM_NE);
      }
      this._children[enums.octree.BOTTOM_NE].insert(node, is_light);
      ++num_inserted;
    } //if
    if (t_sw) {
      new_position = [x - offset, y - offset, z + offset];
      if (this._children[enums.octree.TOP_SW] === null) {
        this._children[enums.octree.TOP_SW] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.TOP_SW);
      }
      this._children[enums.octree.TOP_SW].insert(node, is_light);
      ++num_inserted;
    } //if
    if (t_se) {
      new_position = [x + offset, y - offset, z + offset];
      if (this._children[enums.octree.TOP_SE] === null) {
        this._children[enums.octree.TOP_SE] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.TOP_SE);
      }
      this._children[enums.octree.TOP_SE].insert(node, is_light);
      ++num_inserted;
    } //if
    if (b_sw) {
      new_position = [x - offset, y + offset, z + offset];
      if (this._children[enums.octree.BOTTOM_SW] === null) {
        this._children[enums.octree.BOTTOM_SW] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.BOTTOM_SW);
      }
      this._children[enums.octree.BOTTOM_SW].insert(node, is_light);
      ++num_inserted;
    } //if
    if (b_se) {
      new_position = [x + offset, y + offset, z + offset];
      if (this._children[enums.octree.BOTTOM_SE] === null) {
        this._children[enums.octree.BOTTOM_SE] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.BOTTOM_SE);
      }
      this._children[enums.octree.BOTTOM_SE].insert(node, is_light);
      ++num_inserted;
    } //if
    if (num_inserted > 1 || node.octree_common_root === null) {
      node.octree_common_root = this;
    } //if
  } //if
}; //Octree::insert
Octree.prototype.draw_on_map = function(map_canvas, map_context, target) {
  var mhw = map_canvas.width/2;
  var mhh = map_canvas.height/2;
  var x, y, w, h;
  var i, len;

  if (target === undef || target === "map") {
    map_context.save();
    if (this._debug_visible !== false) {
      map_context.fillStyle = "rgba(0,0,0,0)";
      map_context.strokeStyle = "#FF0000";
    }
    else {
      map_context.fillStyle = "rgba(0,0,0,0)";
      map_context.strokeStyle = "rgba(0,0,0,0)";
    } //if
    map_context.beginPath();
    var offset = this._size / 2;
    x = this._position[0];
    y = this._position[2];
    map_context.moveTo(mhw + x - offset, mhw + y - offset);
    map_context.lineTo(mhw + x - offset, mhw + y + offset);
    map_context.lineTo(mhw + x + offset, mhw + y + offset);
    map_context.lineTo(mhw + x + offset, mhw + y - offset);
    map_context.stroke();
    map_context.fill();
    map_context.restore();
  }

  if (target === undef || target === "objects") {
    map_context.save();
    for (i = 0, len = this._nodes.length; i < len; ++i) {
      var n = this._nodes[i];
      map_context.fillStyle = "#5500FF";
      if (n.visible === true && n.culled === false) {
        map_context.strokeStyle = "#FFFFFF";
      } else {
        map_context.strokeStyle = "#000000";
      } //if
      map_context.beginPath();
      x = n.aabb[0][0];
      y = n.aabb[0][2];
      w = n.aabb[1][0] - x;
      h = n.aabb[1][2] - y;
      map_context.rect(mhw + x, mhh + y, w, h);
      map_context.stroke();
    } //for
    map_context.restore();
  }

  if (target === undef || target === "lights") {
    for (i = 0, len = this._lights.length; i < len; ++i) {
      var l = this._lights[i];
      if (l.culled === false && l.visible === true) {
        map_context.fillStyle = "rgba(255, 255, 255, 0.1)";
      } else {
        map_context.fillStyle = "rgba(255, 255, 255, 0.0)";
      }
      map_context.strokeStyle = "#FFFF00";
      map_context.beginPath();
      var d = l.distance;
      x = l.position[0];
      y = l.position[2];
      map_context.arc(mhw + x, mhh + y, d, 0, Math.PI * 2, true);
      map_context.closePath();
      map_context.stroke();
      map_context.fill();
      map_context.beginPath();
      x = l.aabb[0][0];
      y = l.aabb[0][2];
      w = l.aabb[1][0] - x;
      h = l.aabb[1][2] - y;
      map_context.rect(mhw + x, mhh + y, w, h);
      map_context.closePath();
      map_context.stroke();
    } //for
    for (i = 0, len = this._static_lights.length; i < len; ++i) {
      var l = this._static_lights[i];
      if (l.culled === false && l.visible === true) {
        map_context.fillStyle = "rgba(255, 255, 255, 0.01)";
      } else {
        map_context.fillStyle = "rgba(255, 255, 255, 0.0)";
      }
      map_context.strokeStyle = "#FF66BB";
      map_context.beginPath();
      var d = l.distance;
      x = l.position[0];
      y = l.position[2];
      map_context.arc(mhw + x, mhh + y, d, 0, Math.PI * 2, true);
      map_context.closePath();
      map_context.stroke();
      map_context.fill();
      map_context.beginPath();
      x = l.aabb[0][0];
      y = l.aabb[0][2];
      w = l.aabb[1][0] - x;
      h = l.aabb[1][2] - y;
      map_context.rect(mhw + x, mhh + y, w, h);
      map_context.closePath();
      map_context.stroke();
    } //for
  } //if

  function $draw_box(x1, y1, x2, y2, fill) {
    var x = x1 < x2 ? x1 : x2;
    var y = y1 < y2 ? y1 : y2;
    var w = x1 < x2 ? x2-x1 : x1-x2;
    var h = y1 < y2 ? y2-y1 : y1-y2;
    map_context.save();
    if (fill !== undefined) {
      map_context.fillStyle = fill;
      map_context.fillRect(mhw+x,mhh+y,w,h);
    } //if
    map_context.strokeRect(mhw+x,mhh+y,w,h);
    map_context.restore();
  } //$draw_box

  function $draw_oct(oct, fill) {
    var x1 = oct._bbox[0][0];
    var y1 = oct._bbox[0][2];
    var x2 = oct._bbox[1][0];
    var y2 = oct._bbox[1][2];
    $draw_box(x1, y1, x2, y2, fill);
  } //$draw_oct
  if (target != "lights" && target != "objects" && target != "map") {
    map_context.save();
    var nodes = this._nodes;
    for (var i=0,l=nodes.length;i<l;++i) {
      var n = nodes[i];
      if (n.name == target) {
        map_context.strokeStyle = "#FFFF00";
        map_context.lineWidth = 3;
        map_context.beginPath();
        x = n.aabb[0][0];
        y = n.aabb[0][2];
        w = n.aabb[1][0] - x;
        h = n.aabb[1][2] - y;
        map_context.rect(mhw + x, mhh + y, w, h);
        map_context.closePath();
        map_context.stroke();

        var oab = n.octree_aabb;
        map_context.strokeStyle = "#0000FF";
        $draw_box(oab[0][0], oab[0][2], oab[1][0], oab[1][2]);
        map_context.lineWidth = 1;
        if (n.common_root !== null) {
          map_context.strokeStyle = "#00FF00";
          //$draw_oct(n.octree_common_root);
        } //if
        break;
      } //if
    } //for
    map_context.lineWidth = 1;
    map_context.strokeStyle = "#FFFF00";
    $draw_oct(this, "#444444");
    map_context.fill();
    map_context.restore();

  } //if

  for (i = 0, len = this._children.length; i < len; ++i) {
    if (this._children[i] !== null) {
      this._children[i].draw_on_map(map_canvas, map_context, target);
    }
  } //for
}; //Octree::draw_on_map
Octree.prototype.contains_point = function(position) {
  return position[0] <= this._position[0] + this._size / 2 && position[1] <= this._position[1] + this._size / 2 && position[2] <= this._position[2] + this._size / 2 && position[0] >= this._position[0] - this._size / 2 && position[1] >= this._position[1] - this._size / 2 && position[2] >= this._position[2] - this._size / 2;
}; //Octree::contains_point
Octree.prototype.get_frustum_hits = function(camera, test_children) {
  var hits = {
    objects: [],
    lights: []
  };
  if (test_children === undef || test_children === true) {
    if (! (this.contains_point(camera.position))) {
      if (camera.frustum.sphere.intersects(this._sphere) === false) {
        return hits;
      }
      //if(_sphere.intersects(c.get_frustum().get_cone()) === false) return;
      var contains_sphere = camera.frustum.contains_sphere(this._sphere);
      if (contains_sphere === -1) {
        this._debug_visible = false;
        return hits;
      }
      else if (contains_sphere === 1) {
        this._debug_visible = 2;
        test_children = false;
      }
      else if (contains_sphere === 0) {
        this._debug_visible = true;
        var contains_box = camera.frustum.contains_box(this._bbox);
        if (contains_box === -1) {
          this._debug_visible = false;
          return hits;
        }
        else if (contains_box === 1) {
          this._debug_visible = 3;
          test_children = false;
        } //if
      } //if
    } //if
  } //if
  var i, max_i;
  for (i = 0, max_i = this._nodes.length; i < max_i; ++i) {
    var n = this._nodes[i];
    hits.objects.push(n);
    n.dynamic_lights = [].concat(this._lights);
    n.was_culled = n.culled;
    n.culled = false;
    n.drawn_this_frame = false;
  } //for objects
  this._debug_visible = this._lights.length > 0 ? 4 : this._debug_visible;
  for (i = 0, max_i = this._lights.length; i < max_i; ++i) {
    var l = this._lights[i];
    if (l.visible === true) {
      hits.lights.push(l);
      l.was_culled = l.culled;
      l.culled = false;
    } //if
  } //for dynamic lights
  for (i = 0, max_i = this._static_lights.length; i < max_i; ++i) {
    var l = this._static_lights[i];
    if (l.visible === true) {
      l.culled = false;
    } //if
  } //for static lights
  for (i = 0; i < 8; ++i) {
    if (this._children[i] !== null) {
      var child_hits = this._children[i].get_frustum_hits(camera, test_children);
      var o, max_o;
      for (o = 0, max_o = child_hits.objects.length; o < max_o; ++o) {
        hits.objects.push(child_hits.objects[o]);
        var obj_lights = child_hits.objects[o].dynamic_lights;
        for (var j=0, lj=this._lights.length; j<lj; ++j) {
          if(obj_lights.indexOf(this._lights[j]) < 0) {
            obj_lights.push(this._lights[j]);
          } //if
        } //for j
      } //for o
      //hits.lights = hits.lights.concat(child_hits.lights);
      //collect lights and make sure they're unique <- really slow
      for (o = 0, max_o = child_hits.lights.length; o < max_o; ++o) {
        if (hits.lights.indexOf(child_hits.lights[o]) < 0) {
          hits.lights.push(child_hits.lights[o]);
        } //if
      } //for o
    } //if
  } //for
  return hits;
}; //Octree::get_frustum_hits
Octree.prototype.reset_node_visibility = function() {
  this._debug_visible = false;

  var i, l;
  for (i = 0, l = this._nodes.length; i < l; ++i) {
    this._nodes[i].culled = true;
  } //for
  for (i = 0, l = this._lights.length; i < l; ++i) {
    this._lights[i].culled = true;
  } //for
  for (i = 0, l = this._static_lights.length; i < l; ++i) {
    this._static_lights[i].culled = true;
  } //for
  for (i = 0, l = this._children.length; i < l; ++i) {
    if (this._children[i] !== null) {
      this._children[i].reset_node_visibility();
    } //if
  } //for
}; //Octree::reset_visibility
/***********************************************
 * OctreeNode
 ***********************************************/

function OctreeNode() {
  this.position = [0, 0, 0];
  this.visible = false;
  this._object = null;
} //OctreeNode::Constructor
OctreeNode.prototype.toString = function() {
  return "[OctreeNode " + this.position + "]";
}; //OctreeNode::toString
OctreeNode.prototype.attach = function(obj) {
  this._object = obj;
}; //OctreeNode::attach

function CubicVR_OctreeWorker() {
  this.octree = null;
  this.nodes = [];
  this.camera = null;
} //CubicVR_OctreeWorker::Constructor
CubicVR_OctreeWorker.prototype.onmessage = function(input) {
  var message = input.message;
  if (message === "init") {
    var params = input.data;
    this.octree = new Octree(params.size, params.max_depth);
    this.camera = new Camera();
  }
  else if (type === "set_camera") {
    var data = message.data;
    this.camera.mvMatrix = data.mvMatrix;
    this.camera.pMatrix = data.pMatrix;
    this.camera.position = data.position;
    this.camera.target = data.target;
    this.camera.frustum.extract(this.camera, this.camera.mvMatrix, this.camera.pMatrix);
  }
  else if (type === "insert") {
    var json_node = JSON.parse(message.data);
    var node = new SceneObject();
    var trans = new Transform();

    for (var i in json_node) {
      if (json_node.hasOwnProperty(i)) {
        node[i] = json_node[i];
      } //if
    } //for

    for (var i in json_node.trans) {
      if (json_node.trans.hasOwnProperty(i)) {
        trans[i] = json_node.trans[i];
      } //if
    } //for

    node.trans = trans;
    node.id = json_node.id;

    this.octree.insert(node);
    this.nodes[node.id] = node;
  }
  else if (type === "cleaup") {
    this.octree.cleanup();
  } //if
}; //onmessage

/***********************************************
 * Frustum
 ***********************************************/

function FrustumWorkerProxy(worker, camera) {
  this.camera = camera;
  this.worker = worker;
  this.draw_on_map = function(map_context) {
    return;
  };
} //FrustumWorkerProxy
FrustumWorkerProxy.prototype.extract = function(camera, mvMatrix, pMatrix) {
  this.worker.send({
    type: "set_camera",
    data: {
      mvMatrix: this.camera.mvMatrix,
      pMatrix: this.camera.pMatrix,
      position: this.camera.position,
      target: this.camera.target
    }
  });
}; //FrustumWorkerProxy::extract

function Frustum() {
  this.last_in = [];
  this._planes = [];
  this.sphere = null;
  for (var i = 0; i < 6; ++i) {
    this._planes[i] = new Plane();
  } //for
} //Frustum::Constructor
Frustum.prototype.extract = function(camera, mvMatrix, pMatrix) {
  if (mvMatrix === undef || pMatrix === undef) {
    return;
  }
  var comboMatrix = mat4.multiply(mvMatrix, pMatrix);

  // Left clipping plane
  this._planes[enums.frustum.plane.LEFT].a = comboMatrix[3] + comboMatrix[0];
  this._planes[enums.frustum.plane.LEFT].b = comboMatrix[7] + comboMatrix[4];
  this._planes[enums.frustum.plane.LEFT].c = comboMatrix[11] + comboMatrix[8];
  this._planes[enums.frustum.plane.LEFT].d = comboMatrix[15] + comboMatrix[12];

  // Right clipping plane
  this._planes[enums.frustum.plane.RIGHT].a = comboMatrix[3] - comboMatrix[0];
  this._planes[enums.frustum.plane.RIGHT].b = comboMatrix[7] - comboMatrix[4];
  this._planes[enums.frustum.plane.RIGHT].c = comboMatrix[11] - comboMatrix[8];
  this._planes[enums.frustum.plane.RIGHT].d = comboMatrix[15] - comboMatrix[12];

  // Top clipping plane
  this._planes[enums.frustum.plane.TOP].a = comboMatrix[3] - comboMatrix[1];
  this._planes[enums.frustum.plane.TOP].b = comboMatrix[7] - comboMatrix[5];
  this._planes[enums.frustum.plane.TOP].c = comboMatrix[11] - comboMatrix[9];
  this._planes[enums.frustum.plane.TOP].d = comboMatrix[15] - comboMatrix[13];

  // Bottom clipping plane
  this._planes[enums.frustum.plane.BOTTOM].a = comboMatrix[3] + comboMatrix[1];
  this._planes[enums.frustum.plane.BOTTOM].b = comboMatrix[7] + comboMatrix[5];
  this._planes[enums.frustum.plane.BOTTOM].c = comboMatrix[11] + comboMatrix[9];
  this._planes[enums.frustum.plane.BOTTOM].d = comboMatrix[15] + comboMatrix[13];

  // Near clipping plane
  this._planes[enums.frustum.plane.NEAR].a = comboMatrix[3] + comboMatrix[2];
  this._planes[enums.frustum.plane.NEAR].b = comboMatrix[7] + comboMatrix[6];
  this._planes[enums.frustum.plane.NEAR].c = comboMatrix[11] + comboMatrix[10];
  this._planes[enums.frustum.plane.NEAR].d = comboMatrix[15] + comboMatrix[14];

  // Far clipping plane
  this._planes[enums.frustum.plane.FAR].a = comboMatrix[3] - comboMatrix[2];
  this._planes[enums.frustum.plane.FAR].b = comboMatrix[7] - comboMatrix[6];
  this._planes[enums.frustum.plane.FAR].c = comboMatrix[11] - comboMatrix[10];
  this._planes[enums.frustum.plane.FAR].d = comboMatrix[15] - comboMatrix[14];

  for (var i = 0; i < 6; ++i) {
    this._planes[i].normalize();
  }

  //Sphere
  var fov = 1 / pMatrix[5];
  var near = -this._planes[enums.frustum.plane.NEAR].d;
  var far = this._planes[enums.frustum.plane.FAR].d;
  var view_length = far - near;
  var height = view_length * fov;
  var width = height;

  var P = [0, 0, near + view_length * 0.5];
  var Q = [width, height, near + view_length];
  var diff = vec3.subtract(P, Q);
  var diff_mag = vec3.length(diff);

  var look_v = [comboMatrix[3], comboMatrix[9], comboMatrix[10]];
  var look_mag = vec3.length(look_v);
  look_v = vec3.multiply(look_v, 1 / look_mag);

  this.sphere = new Sphere([camera.position[0], camera.position[1], camera.position[2]], diff_mag);
  this.sphere.position = vec3.add(this.sphere.position, vec3.multiply(look_v, view_length * 0.5));
  this.sphere.position = vec3.add(this.sphere.position, vec3.multiply(look_v, 1));

}; //Frustum::extract
Frustum.prototype.contains_sphere = function(sphere) {
  for (var i = 0; i < 6; ++i) {
    var p = this._planes[i];
    var normal = [p.a, p.b, p.c];
    var distance = vec3.dot(normal, sphere.position) + p.d;
    this.last_in[i] = 1;

    //OUT
    if (distance < -sphere.radius) {
      return -1;
    }

    //INTERSECT
    if (Math.abs(distance) < sphere.radius) {
      return 0;
    }

  } //for
  //IN
  return 1;
}; //Frustum::contains_sphere
Frustum.prototype.draw_on_map = function(map_canvas, map_context) {
  var mhw = map_canvas.width/2;
  var mhh = map_canvas.height/2;
  map_context.save();
  for (var pi = 0, l = this._planes.length; pi < l; ++pi) {
    if (pi === 2 || pi === 3) {continue;}
    map_context.strokeStyle = "#FF00FF";
    if (pi < this.last_in.length) {
      if (this.last_in[pi]) {
        map_context.strokeStyle = "#FFFF00";
      }
    } //if
    var p = this._planes[pi];
    var x1 = -mhw;
    var y1 = (-p.d - p.a * x1) / p.c;
    var x2 = mhw;
    var y2 = (-p.d - p.a * x2) / p.c;
    map_context.moveTo(mhw + x1, mhh + y1);
    map_context.lineTo(mhw + x2, mhh + y2);
    map_context.stroke();
  } //for
  map_context.strokeStyle = "#0000FF";
  map_context.beginPath();
  map_context.arc(mhw + this.sphere.position[0], mhh + this.sphere.position[2], this.sphere.radius, 0, Math.PI * 2, false);
  map_context.closePath();
  map_context.stroke();
  map_context.restore();
}; //Frustum::draw_on_map
Frustum.prototype.contains_box = function(bbox) {
  var total_in = 0;

  var points = [];
  points[0] = bbox[0];
  points[1] = [bbox[0][0], bbox[0][1], bbox[1][2]];
  points[2] = [bbox[0][0], bbox[1][1], bbox[0][2]];
  points[3] = [bbox[0][0], bbox[1][1], bbox[1][2]];
  points[4] = [bbox[1][0], bbox[0][1], bbox[0][2]];
  points[5] = [bbox[1][0], bbox[0][1], bbox[1][2]];
  points[6] = [bbox[1][0], bbox[1][1], bbox[0][2]];
  points[7] = bbox[1];

  for (var i = 0; i < 6; ++i) {
    var in_count = 8;
    var point_in = 1;

    for (var j = 0; j < 8; ++j) {
      if (this._planes[i].classify_point(points[j]) === -1) {
        point_in = 0;
        --in_count;
      } //if
    } //for j
    this.last_in[i] = point_in;

    //OUT
    if (in_count === 0) {
      return -1;
    }

    total_in += point_in;
  } //for i
  //IN
  if (total_in === 6) {
    return 1;
  }

  return 0;
}; //Frustum::contains_box

function Camera(width, height, fov, nearclip, farclip) {
  this.frustum = new Frustum();

  if (typeof(width)=='object') {
    this.position = width.position?width.position:[0, 0, 0];
    this.rotation = width.rotation?width.rotation:[0, 0, 0];
    this.target = width.target?width.target:[0, 0, 0];
    this.fov = width.fov?width.fov:60.0;
    this.nearclip = width.nearclip?width.nearclip:0.1;
    this.farclip = width.farclip?width.farclip:400.0;
    this.targeted = width.targeted?width.targeted:true;
    this.calc_nmatrix =  width.calcNormalMatrix?width.calcNormalMatrix:true;

    height = width.height?width.height:undef;
    width = width.width?width.width:undef;
  } else {
    this.position = [0, 0, 0];
    this.rotation = [0, 0, 0];
    this.target = [0, 0, 0];
    this.fov = (fov !== undef) ? fov : 60.0;
    this.nearclip = (nearclip !== undef) ? nearclip : 0.1;
    this.farclip = (farclip !== undef) ? farclip : 400.0;
    this.targeted = true;
    this.calc_nmatrix = true;
  }

  this.targetSceneObject = null;
  this.motion = null;
  this.transform = new Transform();

  this.manual = false;

  this.setDimensions((width !== undef) ? width : 512, (height !== undef) ? height : 512);

  this.mvMatrix = cubicvr_identity;
  this.pMatrix = null;
  this.calcProjection();
  
  this.ortho = false;
  this.ortho_view = {
    left:-1,
    right:1,
    bottom:-1,
    top:1
  };
}

Camera.prototype.setOrtho = function(left,right,bottom,top) {
  this.ortho = true;
  this.ortho_view.left = left;
  this.ortho_view.right = right;
  this.ortho_view.bottom = bottom;
  this.ortho_view.top = top;
}

Camera.prototype.control = function(controllerId, motionId, value) {
  if (controllerId === enums.motion.ROT) {
    this.rotation[motionId] = value;
  } else if (controllerId === enums.motion.POS) {
    this.position[motionId] = value;
  } else if (controllerId === enums.motion.FOV) {
    this.setFOV(value);
  } else if (controllerId === enums.motion.LENS) {
   this.setLENS(value);
  } else if (controllerId === enums.motion.NEARCLIP) {
   this.setClip(value,this.farclip);
  } else if (controllerId === enums.motion.FARCLIP) {
   this.setClip(this.nearclip,value);
  } 
};


Camera.prototype.makeFrustum = function(left, right, bottom, top, zNear, zFar) {
  var A = (right + left) / (right - left);
  var B = (top + bottom) / (top - bottom);
  var C = -(zFar + zNear) / (zFar - zNear);
  var D = -2.0 * zFar * zNear / (zFar - zNear);

  return [2.0 * zNear / (right - left), 0.0, 0.0, 0.0, 0.0, 2.0 * zNear / (top - bottom), 0.0, 0.0, A, B, C, -1.0, 0.0, 0.0, D, 0.0];
};


Camera.prototype.setTargeted = function(targeted) {
  this.targeted = targeted;
};

Camera.prototype.calcProjection = function() {
  var gl = GLCore.gl;
  
  
  if (this.ortho) {
    this.pMatrix = mat4.ortho(this.ortho_view.left,this.ortho_view.right,this.ortho_view.bottom,this.ortho_view.top,this.nearclip,this.farclip);
  } else {
    this.pMatrix = mat4.perspective(this.fov, this.aspect, this.nearclip, this.farclip);
  }
  
  if (!this.targeted) {
    this.transform.clearStack();
    //this.transform.translate(vec3.subtract([0,0,0],this.position)).pushMatrix().rotate(vec3.subtract([0,0,0],this.rotation)).getResult();
    this.transform.translate(-this.position[0], -this.position[1], -this.position[2]);
    this.transform.pushMatrix();
    this.transform.rotate(-this.rotation[2], 0, 0, 1);
    this.transform.rotate(-this.rotation[1], 0, 1, 0);
    this.transform.rotate(-this.rotation[0], 1, 0, 0);
    this.transform.pushMatrix();
    this.mvMatrix = this.transform.getResult();
    
    if (this.calc_nmatrix) {
      this.nMatrix = mat4.inverse_mat3(this.mvMatrix);
      mat3.transpose_inline(this.nMatrix);
    } else {
      this.nMatrix = cubicvr_identity;
    }
  }
  
  this.frustum.extract(this, this.mvMatrix, this.pMatrix);
};


Camera.prototype.setClip = function(nearclip, farclip) {
  this.nearclip = nearclip;
  this.farclip = farclip;
  this.calcProjection();
};


Camera.prototype.setDimensions = function(width, height) {
  this.width = width;
  this.height = height;

  this.aspect = width / height;
  this.calcProjection();
};

Camera.prototype.resize = function(width,height) {
  this.setDimensions(width,height);
}


Camera.prototype.setFOV = function(fov) {
  this.fov = fov;
  this.ortho = false;
  this.calcProjection();
};

Camera.prototype.setLENS = function(lens) {
  this.setFOV(2.0*Math.atan(16.0/lens)*(180.0/M_PI));
};

Camera.prototype.lookat = function(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ) {
  
  if (typeof(eyeX)=='object') {
    this.lookat(this.position[0],this.position[1],this.position[2],eyeX[0],eyeX[1],eyeX[2],0,1,0);
    return;
  }
  
  this.mvMatrix = mat4.lookat(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ);

  if (this.rotation[2]) {
    this.transform.clearStack();
    this.transform.rotate(-this.rotation[2], 0, 0, 1);
    this.transform.pushMatrix(this.mvMatrix);
    this.mvMatrix = this.transform.getResult();
  }

  if (this.calc_nmatrix) {
    this.nMatrix = mat4.inverse_mat3(this.mvMatrix);
    mat3.transpose_inline(this.nMatrix);
    } else {
      this.nMatrix = cubicvr_identity;
    }
  
  this.frustum.extract(this, this.mvMatrix, this.pMatrix);
  
};


Camera.prototype.unProject = function (winx, winy, winz) {

    var tmpClip = this.nearclip;
    
    if (tmpClip < 1.0) { this.nearclip = 1.0; this.calcProjection(); }

    var viewport = [0, 0, this.width, this.height];

    if (winz === undef) winz = this.farclip;

    var p = [(((winx - viewport[0]) / (viewport[2])) * 2) - 1, -((((winy - viewport[1]) / (viewport[3])) * 2) - 1), (winz - this.nearclip) / (this.farclip - this.nearclip), 1.0];

    var invp = mat4.vec4_multiply(mat4.vec4_multiply(p, mat4.inverse(this.pMatrix)), mat4.inverse(this.mvMatrix));

    if (tmpClip < 1.0) { this.nearclip = tmpClip; this.calcProjection(); }

    return [invp[0] / invp[3], invp[1] / invp[3], invp[2] / invp[3]];
}


Camera.prototype.project = function (objx, objy, objz) {

  var p = [objx,objy,objz,1.0];
  
  var mp = mat4.vec4_multiply(mat4.vec4_multiply(p,this.mvMatrix),this.pMatrix);
  
  return [((mp[0]/mp[3]+1.0)/2.0)*this.width,((-mp[1]/mp[3]+1.0)/2.0)*this.height,((mp[2]/mp[3]))*(this.farclip-this.nearclip)+this.nearclip];
  
}


/*** Auto-Cam Prototype ***/

function AutoCameraNode(pos) {
  this.position = (pos !== undef) ? pos : [0, 0, 0];
}

AutoCameraNode.prototype.control = function(controllerId, motionId, value) {
  if (controllerId === enums.motion.POS) {
    this.position[motionId] = value;
  }
};

function AutoCamera(start_position, target, bounds) {
  this.camPath = new Motion();
  this.targetPath = new Motion();

  this.start_position = (start_position !== undef) ? start_position : [8, 8, 8];
  this.target = (target !== undef) ? target : [0, 0, 0];

  this.bounds = (bounds !== undef) ? bounds : [[-15, 3, -15], [15, 20, 15]];

this.safe_bb = [];
this.avoid_sphere = [];

this.segment_time = 3.0;
this.buffer_time = 20.0;
this.start_time = 0.0;
this.current_time = 0.0;

this.path_time = 0.0;
this.path_length = 0;

this.min_distance = 2.0;
this.max_distance = 40.0;

this.angle_min = 40;
this.angle_max = 180;
}


AutoCamera.prototype.inBounds = function(pt) {
  if (! (pt[0] > this.bounds[0][0] && pt[1] > this.bounds[0][1] && pt[2] > this.bounds[0][2] && pt[0] < this.bounds[1][0] && pt[1] < this.bounds[1][1] && pt[2] < this.bounds[1][2])) {
    return false;
  }

  for (var i = 0, iMax = this.avoid_sphere.length; i < iMax; i++) {
    var l = vec3.length(pt, this.avoid_sphere[i][0]);
    if (l < this.avoid_sphere[i][1]) {
      return false;
    }
  }

  return true;
};

AutoCamera.prototype.findNextNode = function(aNode, bNode) {
  var d = [this.bounds[1][0] - this.bounds[0][0], this.bounds[1][1] - this.bounds[0][1], this.bounds[1][2] - this.bounds[0][2]];

  var nextNodePos = [0, 0, 0];
  var randVector = [0, 0, 0];
  var l = 0.0;
  var loopkill = 0;
  var valid = false;

  do {
    randVector[0] = Math.random() - 0.5;
    randVector[1] = Math.random() - 0.5;
    randVector[2] = Math.random() - 0.5;

    randVector = vec3.normalize(randVector);

    var r = Math.random();

    l = (r * (this.max_distance - this.min_distance)) + this.min_distance;

    nextNodePos = vec3.add(bNode.position, vec3.multiply(randVector, l));

    valid = this.inBounds(nextNodePos);

    loopkill++;

    if (loopkill > 30) {
      nextNodePos = bNode.position;
      break;
    }
  } while (!valid);

  return nextNodePos;
};

AutoCamera.prototype.run = function(timer) {
  this.current_time = timer;

  if (this.path_time === 0.0) {
    this.path_time = this.current_time;

    this.camPath.setKey(enums.motion.POS, enums.motion.X, this.path_time, this.start_position[0]);
    this.camPath.setKey(enums.motion.POS, enums.motion.Y, this.path_time, this.start_position[1]);
    this.camPath.setKey(enums.motion.POS, enums.motion.Z, this.path_time, this.start_position[2]);
  }

  while (this.path_time < this.current_time + this.buffer_time) {
    this.path_time += this.segment_time;

    var tmpNodeA = new AutoCameraNode();
    var tmpNodeB = new AutoCameraNode();

    if (this.path_length) {
      this.camPath.apply(this.path_time - (this.segment_time * 2.0), tmpNodeA);
    }

    this.camPath.apply(this.path_time - this.segment_time, tmpNodeB);

    var nextPos = this.findNextNode(tmpNodeA, tmpNodeB);

    this.camPath.setKey(enums.motion.POS, enums.motion.X, this.path_time, nextPos[0]);
    this.camPath.setKey(enums.motion.POS, enums.motion.Y, this.path_time, nextPos[1]);
    this.camPath.setKey(enums.motion.POS, enums.motion.Z, this.path_time, nextPos[2]);

    this.path_length++;
  }

  var tmpNodeC = new AutoCameraNode();

  this.camPath.apply(timer, tmpNodeC);

  return tmpNodeC.position;
};


AutoCamera.prototype.addSafeBound = function(min, max) {
  this.safe_bb.push([min, max]);
};

AutoCamera.prototype.addAvoidSphere = function(center, radius) {
  this.avoid_sphere.push([center, radius]);
};

function Scene(width, height, fov, nearclip, farclip, octree) {
  this.frames = 0;

  this.sceneObjects = [];
  this.sceneObjectsByName = [];
  this.sceneObjectsById = [];
  this.lights = [];
  this.global_lights = [];
  this.dynamic_lights = [];
  this.pickables = [];
  this.octree = octree;
  this.skybox = null;
  this.camera = new Camera(width, height, fov, nearclip, farclip);
  this._workers = null;
  this.stats = [];
  this.collect_stats = false;
}

Scene.prototype.attachOctree = function(octree) {
  this.octree = octree;
  if (octree.init) {
    octree.init(this);
  } //if

  // rebind any active lights
  var tmpLights = this.lights;
  this.lights = [];
  
  for (var l = 0, lMax = tmpLights.length; l < lMax; l++) {
    this.bindLight(tmpLights[l]);
  } //for

  var objs = this.sceneObjects;
  if (this.octree !== undef) {
    for (var i=0, l=objs.length; i<l; ++i) {
      var obj = objs[i];
      if (obj.obj === null) { continue; }
      if (obj.id < 0) {
        obj.id = scene_object_uuid;
        ++scene_object_uuid;
      } //if
      this.sceneObjectsById[obj.id] = obj;
      AABB_reset(obj.octree_aabb, obj.position);
      this.octree.insert(obj);
      if (obj.octree_common_root === undefined || obj.octree_common_root === null) {
        log("!!", obj.name, "octree_common_root is null");
      } //if
    } //for
  } //if
  
  
} //Scene::attachOctree

Scene.prototype.setSkyBox = function(skybox) {
  this.skybox = skybox;
  //this.bindSceneObject(skybox.scene_object, null, false);
};

Scene.prototype.getSceneObject = function(name) {
  return this.sceneObjectsByName[name];
};

Scene.prototype.bindSceneObject = function(sceneObj, pickable, use_octree) {
  if (this.sceneObjects.indexOf(sceneObj)!=-1) {
    return;
  }
  
  this.sceneObjects.push(sceneObj);
  if (pickable !== undef) {
    if (pickable) {
      this.pickables.push(sceneObj);
    }
  }

  if (sceneObj.name !== null) {
    this.sceneObjectsByName[sceneObj.name] = sceneObj;
  }

  if (this.octree !== undef && (use_octree === undef || use_octree === "true")) {
    if (sceneObj.id < 0) {
      sceneObj.id = scene_object_uuid;
      ++scene_object_uuid;
    } //if
    this.sceneObjectsById[sceneObj.id] = sceneObj;
    AABB_reset(sceneObj.octree_aabb, sceneObj.position);
    this.octree.insert(sceneObj);
  } //if
  
  if (sceneObj.children) {
    for (var i = 0, iMax = sceneObj.children.length; i < iMax; i++) {
      this.bindSceneObject(sceneObj.children[i], pickable, use_octree);
    }
  }
};

Scene.prototype.removeLight = function(light) {
  var idx;
    
  if ((idx = this.lights.indexOf(light)) >= 0) {
    this.lights.splice(idx,1);
  }

  // TODO: Remove from Octrees as well (global_lights, dynamic_lights).
 
};

Scene.prototype.removeSceneObject = function(sceneObj) {
  var idx;
    
  if ((idx = this.sceneObjects.indexOf(sceneObj)) >= 0) {
    this.sceneObjects.splice(idx,1);
  }
  
  if (idx = this.pickables.indexOf(sceneObj) >= 0) {
    if (pickable) {
      this.pickables.push(sceneObj);
    }
  }

  if (sceneObj.name !== null) {
    if (this.sceneObjectsByName[sceneObj.name] !== undef) {
     delete(this.sceneObjectsByName[sceneObj.name]); 
    }
  }

  if (sceneObj.children) {
    for (var i = 0, iMax = sceneObj.children.length; i < iMax; i++) {
      this.removeSceneObject(sceneObj.children[i]);
    }
  }
  
  //todo: remove from octree!

/*  if (this.octree !== undef && (use_octree === undef || use_octree === "true")) {
    if (sceneObj.id < 0) {
      sceneObj.id = scene_object_uuid;
      ++scene_object_uuid;
    } //if
    this.sceneObjectsById[sceneObj.id] = sceneObj;
    AABB_reset(sceneObj.octree_aabb, sceneObj.position);
    this.octree.insert(sceneObj);
  } //if */
};


Scene.prototype.bindLight = function(lightObj, use_octree) {
  this.lights.push(lightObj);
  if (this.octree !== undef && (use_octree === undef || use_octree === "true")) {
    if (lightObj.method === enums.light.method.GLOBAL) {
      this.global_lights.push(lightObj);
    }
    else {
      if (lightObj.method === enums.light.method.DYNAMIC) {
        this.dynamic_lights.push(lightObj);
      } //if
      this.octree.insert_light(lightObj);
    } //if
  } //if
  
  this.lights=this.lights.sort(cubicvr_lightPackTypes);  
};

Scene.prototype.bindCamera = function(cameraObj) {
  this.camera = cameraObj;
};


Scene.prototype.evaluate = function(index) {
  var i,iMax;

  for (i = 0, iMax = this.sceneObjects.length; i < iMax; i++) {
    if (!(this.sceneObjects[i].motion)) {
      continue;
    }
    this.sceneObjects[i].motion.apply(index, this.sceneObjects[i]);
  }

  if (this.camera.motion !== null) {
    if (this.camera.targetSceneObject !== null) {
      this.camera.target = this.camera.targetSceneObject.position;
    }

    this.camera.motion.apply(index, this.camera);
  }

  for (var i = 0, iMax = this.lights.length; i < iMax; i++) {
    var l = this.lights[i];
     
    if (l.motion !== null) {
      l.motion.apply(index, l);
    }
  }
};

Scene.prototype.renderSceneObjectChildren = function(sceneObj, camera, lights) {
  var gl = GLCore.gl;
  var sflip = false;

  for (var i = 0, iMax = sceneObj.children.length; i < iMax; i++) {
    if (sceneObj.children[i].visible === false) {
      continue;
    } //if
    
    try {
      sceneObj.children[i].doTransform(sceneObj.tMatrix);
    }catch(e){break;}

      var obj = sceneObj.children[i].obj;

      if (obj) {
        if (sceneObj.children[i].scale[0] < 0) {
          sflip = !sflip;
        }
        if (sceneObj.children[i].scale[1] < 0) {
          sflip = !sflip;
        }
        if (sceneObj.children[i].scale[2] < 0) {
          sflip = !sflip;
        }

        if (sflip) {
          gl.cullFace(gl.FRONT);
        }


        cubicvr_renderObject(obj, camera, sceneObj.children[i].tMatrix, lights);

        if (sflip) {
          gl.cullFace(gl.BACK);
        }
      }

      if (sceneObj.children[i].children !== null) {
        this.renderSceneObjectChildren(sceneObj.children[i], camera, lights);
      }
  }
};

function cubicvr_lightPackTypes(a,b) {
  return a.light_type - b.light_type;
}

Scene.prototype.updateShadows = function() {
  var gl = GLCore.gl;
  var sflip = false;

  this.updateCamera();
  
  // Begin experimental shadowing code..
  var has_shadow = false;
  var dims = gl.getParameter(gl.VIEWPORT);
  for (var l = 0, lMax = this.lights.length; l<lMax; l++) {
    var light = this.lights[l];

    if ((light.light_type == enums.light.type.SPOT_SHADOW)||(light.light_type == enums.light.type.AREA)) {
      has_shadow = true;
      var lDepthPack = new CubicVR.Light(enums.light.type.DEPTH_PACK);
      
      // shadow state depth
      if ((light.light_type === enums.light.type.AREA)) {
        light.areaCam = this.camera;
        light.updateAreaLight();
      }

      GLCore.shadow_near = light.dummyCam.nearclip;
      GLCore.shadow_far = light.dummyCam.farclip;

      light.shadowBegin();

      for (var i = 0, iMax = this.sceneObjects.length; i < iMax; i++) {
        var scene_object = this.sceneObjects[i];
        if (scene_object.parent !== null) {
          continue;
        } //if

        if (scene_object.visible === false) {
          continue;
        } //if

        scene_object.doTransform();

        if (scene_object.obj !== null) {
          if (scene_object.scale[0] < 0) {
            sflip = !sflip;
          }
          if (scene_object.scale[1] < 0) {
            sflip = !sflip;
          }
          if (scene_object.scale[2] < 0) {
            sflip = !sflip;
          }

          if (sflip) {
            gl.cullFace(gl.FRONT);
          }

          cubicvr_renderObject(scene_object.obj, light.dummyCam, scene_object.tMatrix, [lDepthPack]);

          if (sflip) {
            gl.cullFace(gl.BACK);
          }

          sflip = false;
        } //if

        if (scene_object.children !== null) {
          this.renderSceneObjectChildren(scene_object, light.dummyCam, [lDepthPack]);
        } //if
      } //for i
      light.shadowEnd();
    } //if shadowed
  } // for l

  if (has_shadow) {
    gl.viewport(dims[0], dims[1], dims[2], dims[3]);  
  }

  // End experimental shadow code..  
}

Scene.prototype.updateCamera = function() {
  var gl = GLCore.gl;
  if (this.camera.manual===false)
  {    
    if (this.camera.targeted) {
      this.camera.lookat(this.camera.position[0], this.camera.position[1], this.camera.position[2], this.camera.target[0], this.camera.target[1], this.camera.target[2], 0, 1, 0);
    } else {
      this.camera.calcProjection();
    }
  }
  
  GLCore.depth_alpha_near = this.camera.nearclip;
  GLCore.depth_alpha_far = this.camera.farclip;
}

Scene.prototype.resize = function(w_in, h_in) {
  if (this.camera) {
    this.camera.setDimensions(w_in,h_in);
  }
}

Scene.prototype.render = function() {
  ++this.frames;

  this.updateCamera();
  
  for (var i = 0, iMax = this.lights.length; i < iMax; i++) {
    this.lights[i].prepare(this.camera);
  }
  
  var gl = GLCore.gl;
  var frustum_hits;

  var use_octree = this.octree !== undef;
  var lights_rendered = 0;
  if (use_octree) {
    for (var i = 0, l = this.dynamic_lights.length; i < l; ++i) {
      var light = this.dynamic_lights[i];
      light.doTransform();
    } //for
    this.octree.reset_node_visibility();
    this.octree.cleanup();
    frustum_hits = this.octree.get_frustum_hits(this.camera);
    lights_rendered = frustum_hits.lights.length;
  } //if
  var sflip = false;
  var objects_rendered = 0;
  var lights_list = [];

  for (var i = 0, iMax = this.sceneObjects.length; i < iMax; i++) {

    var lights = this.lights;
    var scene_object = this.sceneObjects[i];
    if (scene_object.parent !== null) {
      continue;
    } //if

    scene_object.doTransform();

    if (use_octree) 
    {
      lights = [];
      if (scene_object.dirty && scene_object.obj !== null) {
        scene_object.adjust_octree();
      } //if

      if (scene_object.visible === false || (use_octree && (scene_object.ignore_octree || scene_object.drawn_this_frame === true || scene_object.culled === true))) {
        continue;
      } //if

      //lights = frustum_hits.lights;
      lights = scene_object.dynamic_lights;
      //lights = this.lights;
      
      lights = lights.concat(scene_object.static_lights);
      lights = lights.concat(this.global_lights);
      if (this.collect_stats) {
        lights_rendered = Math.max(lights.length, lights_rendered);
        if (lights_rendered === lights.length) {
          lights_list = lights;
        } //if
        ++objects_rendered;
      } //if

      if (lights.length === 0) {
        lights = [emptyLight];
      } else {
        lights = lights.sort(cubicvr_lightPackTypes)
      } //if

      scene_object.drawn_this_frame = true;
    }
    else if (scene_object.visible === false) {
      continue;
    } //if

    if (scene_object.obj !== null) {
      if (scene_object.scale[0] < 0) {
        sflip = !sflip;
      }
      if (scene_object.scale[1] < 0) {
        sflip = !sflip;
      }
      if (scene_object.scale[2] < 0) {
        sflip = !sflip;
      }

      if (sflip) {
        gl.cullFace(gl.FRONT);
      }
      
      cubicvr_renderObject(scene_object.obj, this.camera, scene_object.tMatrix, lights);

      if (sflip) {
        gl.cullFace(gl.BACK);
      }

      sflip = false;
    } //if
  
    if (scene_object.children !== null) {
      this.renderSceneObjectChildren(scene_object, this.camera, lights);
    } //if
  } //for
  
  if (this.collect_stats) {
    this.stats['objects.num_rendered'] = objects_rendered;
    this.stats['lights.num_rendered'] = lights_rendered;
    this.stats['lights.rendered'] = lights_list;
    this.stats['lights.num_global'] = this.global_lights.length;
    this.stats['lights.num_dynamic'] = this.dynamic_lights.length;
  } //if

  if (this.skybox !== null && this.skybox.ready === true) {
    gl.cullFace(gl.FRONT);
    var size = (this.camera.farclip * 2) / Math.sqrt(3.0);
    this.skybox.scene_object.position = [this.camera.position[0], this.camera.position[1], this.camera.position[2]];
    this.skybox.scene_object.scale = [size, size, size];
    this.skybox.scene_object.doTransform();
    cubicvr_renderObject(this.skybox.scene_object.obj, this.camera, this.skybox.scene_object.tMatrix, []);
    gl.cullFace(gl.BACK);
  } //if
};

Scene.prototype.bbRayTest = function(pos, ray, axisMatch) {
  var pt1, pt2;
  var selList = [];

  if (ray.length === 2) {
    ray = this.camera.unProject(ray[0], ray[1]);
  } else {
    ray = vec3.add(pos, ray);
  }

  pt1 = pos;
  pt2 = ray;

  for (var obj_i in this.pickables) {
    if (this.pickables.hasOwnProperty(obj_i)) {
      var obj = this.pickables[obj_i];
      if (obj.visible !== true) continue;

      var bb1, bb2;
      var aabb = obj.getAABB();
      bb1 = aabb[0];
      bb2 = aabb[1];
      
      var mindepth = 0.2;
      
      if (bb2[0]-bb1[0] < mindepth) {bb1[0] -= mindepth/2; bb2[0] += mindepth/2;}
      if (bb2[1]-bb1[1] < mindepth) {bb1[1] -= mindepth/2; bb2[1] += mindepth/2;}
      if (bb2[2]-bb1[2] < mindepth) {bb1[2] -= mindepth/2; bb2[2] += mindepth/2;}

      var center = vec3.multiply(vec3.add(bb1, bb2), 0.5);
      var testPt = vec3.get_closest_to(pt1, pt2, center);
      var testDist = vec3.length(vec3.subtract(testPt, center));

      var matches = 
      ((testPt[0] >= bb1[0] && testPt[0] <= bb2[0]) ? 1 : 0) + 
      ((testPt[1] >= bb1[1] && testPt[1] <= bb2[1]) ? 1 : 0) + 
      ((testPt[2] >= bb1[2] && testPt[2] <= bb2[2]) ? 1 : 0);

      if (matches >= axisMatch) {
        selList.push({dist:testDist, obj:obj});
      }
    }
  }

  if (selList.length) {
    selList.sort(function(a,b) { if (a.dist==b.dist) return 0; return (a.dist<b.dist) ?-1:1; });
  }

  return selList;
};

function cubicvr_loadMesh(meshUrl, prefix) {
  if (MeshPool[meshUrl] !== undef) {
    return MeshPool[meshUrl];
  }

  var i, j, p, iMax, jMax, pMax;

  var obj = new Mesh();
  var mesh = util.getXML(meshUrl);
  var pts_elem = mesh.getElementsByTagName("points");

  var pts_str = util.collectTextNode(pts_elem[0]);
  var pts = pts_str.split(" ");

  var texName, tex;

  for (i = 0, iMax = pts.length; i < iMax; i++) {
    pts[i] = pts[i].split(",");
    for (j = 0, jMax = pts[i].length; j < jMax; j++) {
      pts[i][j] = parseFloat(pts[i][j]);
    }
  }

  obj.addPoint(pts);

  var material_elem = mesh.getElementsByTagName("material");
  var mappers = [];


  for (i = 0, iMax = material_elem.length; i < iMax; i++) {
    var melem = material_elem[i];

    var matName = (melem.getElementsByTagName("name").length) ? (melem.getElementsByTagName("name")[0].firstChild.nodeValue) : null;
    var mat = new Material(matName);

    if (melem.getElementsByTagName("alpha").length) {
      mat.opacity = parseFloat(melem.getElementsByTagName("alpha")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("shininess").length) {
      mat.shininess = (parseFloat(melem.getElementsByTagName("shininess")[0].firstChild.nodeValue) / 100.0);
    }
    if (melem.getElementsByTagName("max_smooth").length) {
      mat.max_smooth = parseFloat(melem.getElementsByTagName("max_smooth")[0].firstChild.nodeValue);
    }

    if (melem.getElementsByTagName("color").length) {
      mat.color = util.floatDelimArray(melem.getElementsByTagName("color")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("ambient").length) {
      mat.ambient = util.floatDelimArray(melem.getElementsByTagName("ambient")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("diffuse").length) {
      mat.diffuse = util.floatDelimArray(melem.getElementsByTagName("diffuse")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("specular").length) {
      mat.specular = util.floatDelimArray(melem.getElementsByTagName("specular")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("texture").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.COLOR);
    }

    if (melem.getElementsByTagName("texture_luminosity").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_luminosity")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.AMBIENT);
    }

    if (melem.getElementsByTagName("texture_normal").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_normal")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.NORMAL);
    }

    if (melem.getElementsByTagName("texture_specular").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_specular")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.SPECULAR);
    }

    if (melem.getElementsByTagName("texture_bump").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_bump")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.BUMP);
    }

    if (melem.getElementsByTagName("texture_envsphere").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_envsphere")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.ENVSPHERE);
    }

    if (melem.getElementsByTagName("texture_alpha").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_alpha")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.ALPHA);
    }

    var uvSet = null;

    if (melem.getElementsByTagName("uvmapper").length) {
      var uvm = new UVMapper();
      var uvelem = melem.getElementsByTagName("uvmapper")[0];
      var uvmType = "";

      if (uvelem.getElementsByTagName("type").length) {
        uvmType = melem.getElementsByTagName("type")[0].firstChild.nodeValue;

        switch (uvmType) {
        case "uv":
          break;
        case "planar":
          uvm.projection_mode = enums.uv.projection.PLANAR;
          break;
        case "cylindrical":
          uvm.projection_mode = enums.uv.projection.CYLINDRICAL;
          break;
        case "spherical":
          uvm.projection_mode = enums.uv.projection.SPHERICAL;
          break;
        case "cubic":
          uvm.projection_mode = enums.uv.projection.CUBIC;
          break;
        }
      }

      if (uvmType === "uv") {
        if (uvelem.getElementsByTagName("uv").length) {
          var uvText = util.collectTextNode(melem.getElementsByTagName("uv")[0]);

          uvSet = uvText.split(" ");

          for (j = 0, jMax = uvSet.length; j < jMax; j++) {
            uvSet[j] = util.floatDelimArray(uvSet[j]);
          }
        }
      }

      if (uvelem.getElementsByTagName("axis").length) {
        var uvmAxis = melem.getElementsByTagName("axis")[0].firstChild.nodeValue;

        switch (uvmAxis) {
        case "x":
          uvm.projection_axis = enums.uv.axis.X;
          break;
        case "y":
          uvm.projection_axis = enums.uv.axis.Y;
          break;
        case "z":
          uvm.projection_axis = enums.uv.axis.Z;
          break;
        }

      }

      if (melem.getElementsByTagName("center").length) {
        uvm.center = util.floatDelimArray(melem.getElementsByTagName("center")[0].firstChild.nodeValue);
      }
      if (melem.getElementsByTagName("rotation").length) {
        uvm.rotation = util.floatDelimArray(melem.getElementsByTagName("rotation")[0].firstChild.nodeValue);
      }
      if (melem.getElementsByTagName("scale").length) {
        uvm.scale = util.floatDelimArray(melem.getElementsByTagName("scale")[0].firstChild.nodeValue);
      }

      if (uvmType !== "" && uvmType !== "uv") {
        mappers.push([uvm, mat]);
      }
    }


    var seglist = null;
    var triangles = null;

    if (melem.getElementsByTagName("segments").length) {
      seglist = util.intDelimArray(util.collectTextNode(melem.getElementsByTagName("segments")[0]), " ");
    }
    if (melem.getElementsByTagName("triangles").length) {
      triangles = util.intDelimArray(util.collectTextNode(melem.getElementsByTagName("triangles")[0]), " ");
    }


    if (seglist === null) {
      seglist = [0, parseInt((triangles.length) / 3, 10)];
    }

    var ofs = 0;

    if (triangles.length) {
      for (p = 0, pMax = seglist.length; p < pMax; p += 2) {
        var currentSegment = seglist[p];
        var totalPts = seglist[p + 1] * 3;

        obj.setSegment(currentSegment);
        obj.setFaceMaterial(mat);

        for (j = ofs, jMax = ofs + totalPts; j < jMax; j += 3) {
          var newFace = obj.addFace([triangles[j], triangles[j + 1], triangles[j + 2]]);
          if (uvSet) {
            obj.faces[newFace].setUV([uvSet[j], uvSet[j + 1], uvSet[j + 2]]);
          }
        }

        ofs += totalPts;
      }
    }
  }

  obj.calcNormals();

  for (i = 0, iMax = mappers.length; i < iMax; i++) {
    mappers[i][0].apply(obj, mappers[i][1]);
  }

  obj.compile();

  MeshPool[meshUrl] = obj;

  return obj;
}







function cubicvr_loadScene(sceneUrl, model_prefix, image_prefix) {
  if (model_prefix === undef) {
    model_prefix = "";
  }
  if (image_prefix === undef) {
    image_prefix = "";
  }

  var obj = new Mesh();
  var scene = util.getXML(sceneUrl);

  var sceneOut = new Scene();

  var parentingSet = [];

  var sceneobjs = scene.getElementsByTagName("sceneobjects");

  var tempNode;

  var position, rotation, scale;

  //  var pts_str = util.collectTextNode(pts_elem[0]);
  for (var i = 0, iMax = sceneobjs[0].childNodes.length; i < iMax; i++) {
    var sobj = sceneobjs[0].childNodes[i];

    if (sobj.tagName === "sceneobject") {

      var name = "unnamed";
      var parent = "";
      var model = "";

      tempNode = sobj.getElementsByTagName("name");
      if (tempNode.length) {
        name = util.collectTextNode(tempNode[0]);
      }

      tempNode = sobj.getElementsByTagName("parent");
      if (tempNode.length) {
        parent = util.collectTextNode(tempNode[0]);
      }

      tempNode = sobj.getElementsByTagName("model");
      if (tempNode.length) {
        model = util.collectTextNode(tempNode[0]);
      }

      position = null;
      rotation = null;
      scale = null;

      tempNode = sobj.getElementsByTagName("position");
      if (tempNode.length) {
        position = tempNode[0];
      }

      tempNode = sobj.getElementsByTagName("rotation");
      if (tempNode.length) {
        rotation = tempNode[0];
      }

      tempNode = sobj.getElementsByTagName("scale");
      if (tempNode.length) {
        scale = tempNode[0];
      }

      obj = null;

      if (model !== "") {
        obj = cubicvr_loadMesh(model_prefix + model, image_prefix);
      }

      var sceneObject = new SceneObject(obj, name);

      if (cubicvr_isMotion(position)) {
        if (!sceneObject.motion) {
          sceneObject.motion = new Motion();
        }
        cubicvr_nodeToMotion(position, enums.motion.POS, sceneObject.motion);
      } else if (position) {
        sceneObject.position = util.floatDelimArray(util.collectTextNode(position));
      }

      if (cubicvr_isMotion(rotation)) {
        if (!sceneObject.motion) {
          sceneObject.motion = new Motion();
        }
        cubicvr_nodeToMotion(rotation, enums.motion.ROT, sceneObject.motion);
      } else {
        sceneObject.rotation = util.floatDelimArray(util.collectTextNode(rotation));
      }

      if (cubicvr_isMotion(scale)) {
        if (!sceneObject.motion) {
          sceneObject.motion = new Motion();
        }
        cubicvr_nodeToMotion(scale, enums.motion.SCL, sceneObject.motion);
      } else {
        sceneObject.scale = util.floatDelimArray(util.collectTextNode(scale));

      }

      sceneOut.bindSceneObject(sceneObject);

      if (parent !== "") {
        parentingSet.push([sceneObject, parent]);
      }
    }
  }

  for (var j in parentingSet) {
    if (parentingSet.hasOwnProperty(j)) {
      sceneOut.getSceneObject(parentingSet[j][1]).bindChild(parentingSet[j][0]);
    }
  }

  var camera = scene.getElementsByTagName("camera");

  if (camera.length) {
    position = null;
    rotation = null;

    var target = "";

    tempNode = camera[0].getElementsByTagName("name");

    var cam = sceneOut.camera;

    var fov = null;

    if (tempNode.length) {
      target = tempNode[0].firstChild.nodeValue;
    }

    tempNode = camera[0].getElementsByTagName("target");
    if (tempNode.length) {
      target = tempNode[0].firstChild.nodeValue;
    }

    if (target !== "") {
      cam.targetSceneObject = sceneOut.getSceneObject(target);
    }

    tempNode = camera[0].getElementsByTagName("position");
    if (tempNode.length) {
      position = tempNode[0];
    }

    tempNode = camera[0].getElementsByTagName("rotation");
    if (tempNode.length) {
      rotation = tempNode[0];
    }

    tempNode = camera[0].getElementsByTagName("fov");
    if (tempNode.length) {
      fov = tempNode[0];
    }

    if (cubicvr_isMotion(position)) {
      if (!cam.motion) {
        cam.motion = new Motion();
      }
      cubicvr_nodeToMotion(position, enums.motion.POS, cam.motion);
    } else if (position) {
      cam.position = util.floatDelimArray(position.firstChild.nodeValue);
    }

    if (cubicvr_isMotion(rotation)) {
      if (!cam.motion) {
        cam.motion = new Motion();
      }
      cubicvr_nodeToMotion(rotation, enums.motion.ROT, cam.motion);
    } else if (rotation) {
      cam.rotation = util.floatDelimArray(rotation.firstChild.nodeValue);
    }

    if (cubicvr_isMotion(fov)) {
      if (!cam.motion) {
        cam.motion = new Motion();
      }
      cubicvr_nodeToMotion(fov, enums.motion.FOV, cam.motion);
    } else if (fov) {
      cam.fov = parseFloat(fov.firstChild.nodeValue);
    }

  }


  return sceneOut;
}


function RenderBuffer(width, height, depth_enabled) {
  this.createBuffer(width, height, depth_enabled);
}

RenderBuffer.prototype.createBuffer = function(width, height, depth_enabled) {
  this.fbo = null;
  this.depth = null;
  this.texture = null;
  this.width = parseInt(width, 10);
  this.height = parseInt(height, 10);

  var w = this.sizeParam(width);
  var h = this.sizeParam(height);

  var gl = GLCore.gl;

  this.fbo = gl.createFramebuffer();

  if (depth_enabled) {
    this.depth = gl.createRenderbuffer();
  }

  // configure fbo
  gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);

  if (depth_enabled) {
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.depth);

    if (navigator.appVersion.indexOf("Windows")!==-1)
    {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depth); 
    }
    else
    {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.depth); 
    }
  }


  // if (depth_enabled) {
  //   gl.bindRenderbuffer(gl.RENDERBUFFER, this.depth);
  //   gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
  // }

  //  GL_DEPTH_COMPONENT32 0x81A7
  //  if (depth_enabled) { gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT, w, h); }
  // if (depth_enabled) {
  //   gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depth);
  // }



  // init texture
  this.texture = new Texture();
  gl.bindTexture(gl.TEXTURE_2D, Textures[this.texture.tex_id]);

  // configure texture params
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  // clear buffer
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, Textures[this.texture.tex_id], 0);

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

RenderBuffer.prototype.destroyBuffer = function() {
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteRenderbuffer(this.depth);
  gl.deleteFramebuffer(this.fbo);
  gl.deleteTexture(Textures[this.texture.tex_id]);
  Textures[this.texture.tex_id] = null;
};

RenderBuffer.prototype.sizeParam = function(t) {
  return t;
  // var s = 32;
  //
  // while (t > s) s *= 2;
  //
  // return s;
};


RenderBuffer.prototype.use = function() {
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
  //  if (this.depth !== null) { gl.bindRenderbuffer(gl.RENDERBUFFER, this.depth); }
  //  gl.viewport(0, 0, this.width, this.height);
};



function PostProcessFX(width, height) {
  this.bloom = true;

  this.renderBuffer = new RenderBuffer(width, height, true);
  this.blurBuffer = new RenderBuffer(width, height, false);
  this.bloomBuffer = new RenderBuffer(parseInt(width / 6, 10), parseInt(height / 6, 10), false);

  this.copyShader = new Shader("attribute vec3 aVertex;\n" + "attribute vec2 aTex;\n" + "varying vec2 vTex;\n" + "void main(void)\n" + "{\n" + "vTex = aTex;\n" + "vec4 vPos = vec4(aVertex.xyz,1.0);\n" + "gl_Position = vPos;\n" + "}\n", "#ifdef GL_ES\nprecision highp float;\n#endif\n" + "uniform sampler2D srcTex;\n" + "varying vec2 vTex;\n" + "void main(void)\n" + "{\n" + "gl_FragColor = texture2D(srcTex, vTex);\n" + "}\n");


  this.copyShader.use();
  this.copyShader.addUVArray("aTex");
  this.copyShader.addVertexArray("aVertex");
  this.copyShader.addInt("srcTex", 0);

  this.fsQuad = this.makeFSQuad(width, height);

  this.bloomShader = new Shader("attribute vec3 aVertex;\n" + "attribute vec2 aTex;\n" + "varying vec2 vTex;\n" + "void main(void)\n" + "{\n" + "vTex = aTex;\n" + "vec4 vPos = vec4(aVertex.xyz,1.0);\n" + "gl_Position = vPos;\n" + "}\n",

  "#ifdef GL_ES\nprecision highp float;\n#endif\n" + "uniform sampler2D srcTex;\n" + "uniform vec3 texel_ofs;\n" + "varying vec2 vTex;\n" + "vec3 rangeValHDR(vec3 src)\n" + "{\n" + "return (src.r>0.90||src.g>0.90||src.b>0.90)?(src):vec3(0.0,0.0,0.0);\n" + "}\n" + "vec4 hdrSample(float rad)\n" + "{\n" + "vec3 accum;\n" + "float radb = rad*0.707106781;\n" + "accum =  rangeValHDR(texture2D(srcTex, vec2(vTex.s+texel_ofs.x*rad,  vTex.t)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s,          vTex.t+texel_ofs.y*rad)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s-texel_ofs.x*rad,  vTex.t)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s,          vTex.t-texel_ofs.y*rad)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s+texel_ofs.x*radb, vTex.t+texel_ofs.y*radb)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s-texel_ofs.x*radb, vTex.t-texel_ofs.y*radb)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s+texel_ofs.x*radb, vTex.t-texel_ofs.y*radb)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s-texel_ofs.x*radb, vTex.t+texel_ofs.y*radb)).rgb);\n" + "accum /= 8.0;\n" + "return vec4(accum,1.0);\n" + "}\n" + "void main(void)\n" + "{\n" + "vec4 color;\n" + "color = hdrSample(2.0);\n" + "color += hdrSample(8.0);\n" + "color += hdrSample(12.0);\n" + "gl_FragColor = color/2.0;\n" + "}\n");

  this.bloomShader.use();
  this.bloomShader.addUVArray("aTex");
  this.bloomShader.addVertexArray("aVertex");
  this.bloomShader.addInt("srcTex", 0);
  this.bloomShader.addVector("texel_ofs");
  this.bloomShader.setVector("texel_ofs", [1.0 / this.renderBuffer.sizeParam(width), 1.0 / this.renderBuffer.sizeParam(height), 0]);

  this.fsQuadBloom = this.makeFSQuad(this.bloomBuffer.width, this.bloomBuffer.height);

  this.blurShader = new Shader("attribute vec3 aVertex;\n" + "attribute vec2 aTex;\n" + "varying vec2 vTex;\n" + "void main(void)\n" + "{\n" + "vTex = aTex;\n" + "vec4 vPos = vec4(aVertex.xyz,1.0);\n" + "gl_Position = vPos;\n" + "}\n", "#ifdef GL_ES\nprecision highp float;\n#endif\n" + "uniform sampler2D srcTex;\n" + "varying vec2 vTex;\n" + "uniform float opacity;\n" + "void main(void)\n" + "{\n" + "gl_FragColor = vec4(texture2D(srcTex, vTex).rgb, opacity);\n" + "}\n");

  this.blurShader.use();
  this.blurShader.addUVArray("aTex");
  this.blurShader.addVertexArray("aVertex");
  this.blurShader.addInt("srcTex", 0);
  this.blurShader.addFloat("opacity");
  this.blurOpacity = 0.1;


  var gl = GLCore.gl;

  this.blurBuffer.use();
  gl.clear(gl.COLOR_BUFFER_BIT);
  this.end();
}

PostProcessFX.prototype.resize = function(width, height) {
  this.renderBuffer.destroyBuffer();
  this.blurBuffer.destroyBuffer();
  this.bloomBuffer.destroyBuffer();
  this.renderBuffer.createBuffer(width, height, true);
  this.blurBuffer.createBuffer(width, height, false);
  this.bloomBuffer.createBuffer(parseInt(width / 6, 10), parseInt(height / 6, 10), false);

  this.bloomShader.use();
  this.bloomShader.setVector("texel_ofs", [1.0 / this.renderBuffer.sizeParam(width), 1.0 / this.renderBuffer.sizeParam(height), 0]);

  this.destroyFSQuad(this.fsQuad);
  this.fsQuad = this.makeFSQuad(width, height);
  this.destroyFSQuad(this.fsQuadBloom);
  this.fsQuadBloom = this.makeFSQuad(this.bloomBuffer.width, this.bloomBuffer.height);
};

PostProcessFX.prototype.begin = function() {
  this.renderBuffer.use();
};

PostProcessFX.prototype.end = function() {
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  //  if (this.depth !== null) { gl.bindRenderbuffer(gl.RENDERBUFFER, null); }
};

PostProcessFX.prototype.makeFSQuad = function(width, height) {
  var gl = GLCore.gl;
  var fsQuad = []; // intentional empty object
  // var w = this.renderBuffer.sizeParam(width);
  // var h = this.renderBuffer.sizeParam(height);

  // var uscale = (width / w);
  // var vscale = (height / h);

  var uscale, vscale; 
  
  uscale=vscale=1;

  // fsQuad.addPoint([[-1,-1,0],[1, -1, 0],[1, 1, 0],[-1, 1, 0]]);
  // var faceNum = fsQuad.addFace([0,1,2,3]);
  // fsQuad.faces[faceNum].setUV([[0, 0],[uscale, 0],[uscale, vscale],[0, vscale]]);
  // fsQuad.triangulateQuads();
  // fsQuad.calcNormals();
  // fsQuad.compile();
  fsQuad.vbo_points = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0]);
  fsQuad.vbo_uvs = new Float32Array([0, 0, uscale, 0, uscale, vscale, 0, vscale, 0, 0, uscale, vscale]);

  fsQuad.gl_points = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, fsQuad.gl_points);
  gl.bufferData(gl.ARRAY_BUFFER, fsQuad.vbo_points, gl.STATIC_DRAW);

  fsQuad.gl_uvs = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, fsQuad.gl_uvs);
  gl.bufferData(gl.ARRAY_BUFFER, fsQuad.vbo_uvs, gl.STATIC_DRAW);


  return fsQuad;
};

PostProcessFX.prototype.destroyFSQuad = function(fsQuad) {
  var gl = GLCore.gl;

  gl.deleteBuffer(fsQuad.gl_points);
  gl.deleteBuffer(fsQuad.gl_uvs);
};

PostProcessFX.prototype.renderFSQuad = function(shader, fsq) {
  var gl = GLCore.gl;

  shader.use();

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  gl.bindBuffer(gl.ARRAY_BUFFER, fsq.gl_points);
  gl.vertexAttribPointer(shader.aVertex, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribPointer(shader.aVertex);
  gl.bindBuffer(gl.ARRAY_BUFFER, fsq.gl_uvs);
  gl.vertexAttribPointer(shader.aTex, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribPointer(shader.aTex);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

};

PostProcessFX.prototype.render = function() {
  var gl = GLCore.gl;

  gl.disable(gl.DEPTH_TEST);

  this.renderBuffer.texture.use(gl.TEXTURE0);
  this.copyShader.use();
  this.copyShader.setInt("srcTex", 0);

  this.renderFSQuad(this.copyShader, this.fsQuad);

  if (this.blur) {
    this.renderBuffer.texture.use(gl.TEXTURE0);
    this.blurShader.use();
    this.blurShader.setInt("srcTex", 0);
    this.blurShader.setFloat("opacity", this.blurOpacity);

    this.blurBuffer.use();
    gl.enable(gl.BLEND);
    gl.depthMask(0);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    this.renderFSQuad(this.blurShader, this.fsQuad);
    gl.disable(gl.BLEND);
    gl.depthMask(1);
    gl.blendFunc(gl.ONE, gl.ONE);
    this.end();

    this.blurBuffer.texture.use(gl.TEXTURE0);

    this.blurShader.setFloat("opacity", 0.5);

    gl.enable(gl.BLEND);
    gl.depthMask(0);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    this.renderFSQuad(this.blurShader, this.fsQuad);

    gl.disable(gl.BLEND);
    gl.depthMask(1);
    gl.blendFunc(gl.ONE, gl.ONE);
  }

  if (this.bloom) {
    this.renderBuffer.texture.use(gl.TEXTURE0);

    gl.viewport(0, 0, this.bloomBuffer.width, this.bloomBuffer.height);

    this.bloomShader.use();
    this.bloomShader.setInt("srcTex", 0);

    this.bloomBuffer.use();
    this.renderFSQuad(this.bloomShader, this.fsQuad);
    this.end();

    this.bloomBuffer.texture.use(gl.TEXTURE0);
    this.copyShader.use();
    this.copyShader.setInt("srcTex", 0);

    gl.viewport(0, 0, this.renderBuffer.width, this.renderBuffer.height);

    gl.enable(gl.BLEND);
    gl.depthMask(0);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);

    this.renderFSQuad(this.copyShader, this.fsQuadBloom);

    gl.disable(gl.BLEND);
    gl.depthMask(1);
    gl.blendFunc(gl.ONE, gl.ONE);

  }

  gl.enable(gl.DEPTH_TEST);
};

/*
    PostProcessShader:
    
    shaderInfo
    {
      enabled: enabled (default true)
      shader_vertex: id or url for vertex shader
      shader_fragment: id or url for fragment shader
      outputMode: method of output for this shader
      init: function to perform to initialize shader
      onresize: function to perform on resize; params ( shader, width, height )
      onupdate: function to perform on update; params ( shader )
      outputDivisor: use custom output buffer size, divisor of (outputDivisor) eg. 1 (default) = 1024x768, 2 = 512x384, 3 = 256x192
    }

  */

var postProcessDivisorBuffers = [];
var postProcessDivisorQuads = [];

function PostProcessShader(shaderInfo) {
  if (shaderInfo.shader_vertex === undef) {
    return null;
  }
  if (shaderInfo.shader_fragment === undef) {
    return null;
  }

  this.outputMode = (shaderInfo.outputMode === undef) ? enums.post.output.REPLACE : shaderInfo.outputMode;
  this.onresize = (shaderInfo.onresize === undef) ? null : shaderInfo.onresize;
  this.onupdate = (shaderInfo.onupdate === undef) ? null : shaderInfo.onupdate;
  this.init = (shaderInfo.init === undef) ? null : shaderInfo.init;
  this.enabled = (shaderInfo.enabled === undef) ? true : shaderInfo.enabled;
  this.outputDivisor = (shaderInfo.outputDivisor === undef) ? 1 : shaderInfo.outputDivisor;

  this.shader = new Shader(shaderInfo.shader_vertex, shaderInfo.shader_fragment);
  this.shader.use();

  // set defaults
  this.shader.addUVArray("aTex");
  this.shader.addVertexArray("aVertex");
  this.shader.addInt("srcTex", 0);
  this.shader.addInt("captureTex", 1);
  this.shader.addVector("texel");

  if (this.init !== null) {
    this.init(this.shader);
  }
}

/* New post-process shader chain -- to replace postProcessFX */

function PostProcessChain(width, height, accum) {
  var gl = GLCore.gl;

  this.width = width;
  this.height = height;
  this.accum = (accum === undef)?false:true;
  this.vTexel = [1.0 / this.width, 1.0 / this.height, 0];

  // buffers
  this.captureBuffer = new RenderBuffer(width, height, true);
  this.bufferA = new RenderBuffer(width, height, false);
  this.bufferB = new RenderBuffer(width, height, false);
  this.bufferC = new RenderBuffer(width, height, false);

  this.accumOpacity = 1.0;
  this.accumIntensity = 0.3;
  
  if (this.accum) {
    this.accumBuffer = new RenderBuffer(width, height, false);
    this.accumBuffer.use();

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    this.blur_shader = new PostProcessShader({
      shader_vertex: ["attribute vec3 aVertex;",
                      "attribute vec2 aTex;",
                      "varying vec2 vTex;",
                      "void main(void)",
                      "{",
                        "vTex = aTex;",
                        "vec4 vPos = vec4(aVertex.xyz,1.0);",
                        "gl_Position = vPos;",
                        "}"].join("\n"),
      shader_fragment: ["#ifdef GL_ES",
                        "precision highp float;",
                        "#endif",
                        "uniform sampler2D srcTex;",
                        "varying vec2 vTex;",
                        "uniform float opacity;",
                        "void main(void)",
                        "{ gl_FragColor = vec4(texture2D(srcTex, vTex).rgb, opacity);",
                        "}"].join("\n"),
      init: function(shader) {
        shader.addFloat("opacity");
        shader.setFloat("opacity",1.0);
      }});
  }

  this.bufferA.use();

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  this.bufferB.use();

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  this.end();

  // quad
  this.fsQuad = this.makeFSQuad(this.width, this.height);

  this.shaders = [];

  this.copy_shader = new PostProcessShader({
    shader_vertex: ["attribute vec3 aVertex;",
                "attribute vec2 aTex;",
                "varying vec2 vTex;",
                "void main(void) {",
                  "vTex = aTex;",
                  "vec4 vPos = vec4(aVertex.xyz,1.0);",
                  "gl_Position = vPos;",
                "}"].join("\n"),
    shader_fragment: [
      "#ifdef GL_ES",
      "precision highp float;",
      "#endif",
      "uniform sampler2D srcTex;",
      "varying vec2 vTex;",
      "void main(void) {",
        "gl_FragColor = texture2D(srcTex, vTex);",
      "}"].join("\n")
  });

  this.resize(width, height);
}

PostProcessChain.prototype.setBlurOpacity = function (opacity)
{  
  this.accumOpacity = opacity;
}

PostProcessChain.prototype.setBlurIntensity = function (intensity)
{  
  this.accumIntensity = intensity;
}


PostProcessChain.prototype.makeFSQuad = makeFSQuad = function(width, height) {
  var gl = GLCore.gl;
  var fsQuad = []; // intentional empty object
  var w = width;
  var h = height;

  var uscale = (width / w);
  var vscale = (height / h);

  fsQuad.vbo_points = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0]);
  fsQuad.vbo_uvs = new Float32Array([0, 0, uscale, 0, uscale, vscale, 0, vscale, 0, 0, uscale, vscale]);

  fsQuad.gl_points = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, fsQuad.gl_points);
  gl.bufferData(gl.ARRAY_BUFFER, fsQuad.vbo_points, gl.STATIC_DRAW);

  fsQuad.gl_uvs = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, fsQuad.gl_uvs);
  gl.bufferData(gl.ARRAY_BUFFER, fsQuad.vbo_uvs, gl.STATIC_DRAW);

  return fsQuad;
};

PostProcessChain.prototype.destroyFSQuad = destroyFSQuad = function(fsQuad) {
  var gl = GLCore.gl;

  gl.deleteBuffer(fsQuad.gl_points);
  gl.deleteBuffer(fsQuad.gl_uvs);
};

PostProcessChain.prototype.renderFSQuad = renderFSQuad = function(shader, fsq) {
  var gl = GLCore.gl;

  shader.use();

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  gl.bindBuffer(gl.ARRAY_BUFFER, fsq.gl_points);
  gl.vertexAttribPointer(shader.aVertex, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(shader.aVertex);
  gl.bindBuffer(gl.ARRAY_BUFFER, fsq.gl_uvs);
  gl.vertexAttribPointer(shader.aTex, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(shader.aTex);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

};


PostProcessChain.prototype.addShader = function(shader) {
  this.shaders[this.shaders.length] = shader;
  shader.shader.use();
  shader.shader.setVector("texel", this.vTexel);  

  if (shader.outputDivisor && shader.outputDivisor != 1)
  {
    if (postProcessDivisorBuffers[shader.outputDivisor] === undef)
    
    var divw = parseInt(this.width/shader.outputDivisor);
    var divh = parseInt(this.height/shader.outputDivisor);
    
    postProcessDivisorBuffers[shader.outputDivisor] = new RenderBuffer(divw, divh, false);  
    postProcessDivisorQuads[shader.outputDivisor] = this.makeFSQuad(divw, divh);
  
  }
};

PostProcessChain.prototype.resize = function(width, height) {
  var gl = GLCore.gl;

  this.width = width;
  this.height = height;

  this.vTexel = [1.0 / this.width, 1.0 / this.height, 0];

  this.captureBuffer.destroyBuffer();
  this.captureBuffer.createBuffer(this.width, this.height, true);

  this.bufferA.destroyBuffer();
  this.bufferA.createBuffer(this.width, this.height, false);

  this.bufferB.destroyBuffer();
  this.bufferB.createBuffer(this.width, this.height, false);

  this.bufferC.destroyBuffer();
  this.bufferC.createBuffer(this.width, this.height, false);

  if (this.accum) {
    this.accumBuffer.destroyBuffer();
    this.accumBuffer.createBuffer(this.width, this.height, false);
    this.accumBuffer.use();

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }

  for (var p in postProcessDivisorBuffers)
  {
    var divw = parseInt(this.width/p);
    var divh = parseInt(this.height/p);

    postProcessDivisorBuffers[p].destroyBuffer();
    postProcessDivisorBuffers[p].createBuffer(divw, divh, false); 

    this.destroyFSQuad(postProcessDivisorQuads[p]);
    postProcessDivisorQuads[p] = this.makeFSQuad(divw, divh);            
  }

  this.inputBuffer = this.bufferA;
  this.outputBuffer = this.bufferB;

  for (var i = 0, iMax = this.shaders.length; i < iMax; i++) {
    this.shaders[i].shader.use();
    this.shaders[i].shader.setVector("texel", this.vTexel);
    if (this.shaders[i].onresize !== null) {
      this.shaders[i].onresize(this.shaders[i].shader, this.width, this.height);
    }
  }

  this.destroyFSQuad(this.fsQuad);
  this.fsQuad = this.makeFSQuad(this.width, this.height);
};

PostProcessChain.prototype.swap = function() {
  var t = this.inputBuffer;

  this.inputBuffer = this.outputBuffer;
  this.outputBuffer = t;
};

PostProcessChain.prototype.begin = function() {
  this.captureBuffer.use();
};

PostProcessChain.prototype.end = function() {
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

PostProcessChain.prototype.render = function() {
  var gl = GLCore.gl;

  var initBuffer = null;

  this.captureBuffer.texture.use(gl.TEXTURE1);

  this.outputBuffer.use();
  this.captureBuffer.texture.use(gl.TEXTURE0);
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  this.renderFSQuad(this.copy_shader.shader, this.fsQuad);
  this.end();

  var c = 0;
  for (var i = 0, iMax = this.shaders.length; i < iMax; i++) {
    var s = this.shaders[i];
    if (!s.enabled) {
      continue;
    }
    this.swap();
    this.inputBuffer.texture.use(gl.TEXTURE0);

    var o_mode = s.outputMode;
    //switch (s.outputMode) {
    if (o_mode === enums.post.output.REPLACE) {
    //case enums.post.output.REPLACE:
      if (s.outputDivisor !== 1) {
        postProcessDivisorBuffers[s.outputDivisor].use();
      }
      else {
        this.outputBuffer.use();
      } //if
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      //break;
    }
    else if (o_mode === enums.post.output.ADD || o_mode === enums.post.output.BLEND) {
    //case enums.post.output.ADD:
    //case enums.post.output.BLEND:
      if (s.outputDivisor !== 1) {
        postProcessDivisorBuffers[s.outputDivisor].use();
      }
      else {
        this.bufferC.use();        
      } //if

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      //break;
    } //if

    if (s.onupdate !== null) {
      s.shader.use();
      s.onupdate(s.shader);
    } //if

    if (s.outputDivisor !== 1) {
      gl.viewport(0, 0, postProcessDivisorBuffers[s.outputDivisor].width, postProcessDivisorBuffers[s.outputDivisor].height);

      this.renderFSQuad(s.shader, postProcessDivisorQuads[s.outputDivisor]);

      if (s.outputMode === enums.post.output.REPLACE) {
        this.outputBuffer.use();

        postProcessDivisorBuffers[s.outputDivisor].texture.use(gl.TEXTURE0);

        gl.viewport(0, 0, this.width, this.height);

        this.renderFSQuad(this.copy_shader.shader, this.fsQuad);
      }
      else {
        gl.viewport(0, 0, this.width, this.height);        
      } //if
    }
    else {
      this.renderFSQuad(s.shader, this.fsQuad);      
    } //if

    //switch (s.outputMode) {
    
    //case enums.post.output.REPLACE:
    //  break;
    if (o_mode === enums.post.output.BLEND) {
    //case enums.post.output.BLEND:
      this.swap();
      this.outputBuffer.use();

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

      this.inputBuffer.texture.use(gl.TEXTURE0);

      if (s.outputDivisor !== 1) {
        postProcessDivisorBuffers[s.outputDivisor].texture.use(gl.TEXTURE0);
      }
      else {
        this.bufferC.texture.use(gl.TEXTURE0);
      } //if

      this.renderFSQuad(this.copy_shader.shader, this.fsQuad);

      gl.disable(gl.BLEND);
      //break;
    }
    else if (o_mode === enums.post.output.ADD) {
    //case enums.post.output.ADD:
      this.swap();
      this.outputBuffer.use();

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE);

      if (s.outputDivisor !== 1) {
        postProcessDivisorBuffers[s.outputDivisor].texture.use(gl.TEXTURE0);
      }
      else {
        this.bufferC.texture.use(gl.TEXTURE0);
      } //if

      this.renderFSQuad(this.copy_shader.shader, this.fsQuad);

      gl.disable(gl.BLEND);
      //break;
    } //if

    this.end();
    c++;
  } //for

  if (c === 0) {
    this.captureBuffer.texture.use(gl.TEXTURE0);
  } else {
    this.outputBuffer.texture.use(gl.TEXTURE0);
  } //if

  if (this.accum && this.accumOpacity !== 1.0)
  {
    this.blur_shader.shader.use();
    this.blur_shader.shader.setFloat("opacity",this.accumOpacity);

    this.accumBuffer.use();

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);

    this.renderFSQuad(this.blur_shader.shader, this.fsQuad);

    this.end();

    gl.disable(gl.BLEND);

    this.renderFSQuad(this.copy_shader.shader, this.fsQuad);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
    
    this.blur_shader.shader.use();
    this.blur_shader.shader.setFloat("opacity",this.accumIntensity);
    
    this.accumBuffer.texture.use(gl.TEXTURE0);
    
    this.renderFSQuad(this.blur_shader.shader, this.fsQuad);
    
    gl.disable(gl.BLEND);
  }
  else
  {
    this.renderFSQuad(this.copy_shader.shader, this.fsQuad);    
  }

};



  function NormalMapGen(inTex,width,height)
  {
    var gl = GLCore.gl;

    this.width = width;
    this.height = height;
    this.srcTex = inTex;      
    this.outTex = new RenderBuffer(width,height);
    
     var tw = width, th = height;

     var isPOT = true;

     if (tw===1||th===1) {
       isPOT = false;
     } else {
       if (tw !== 1) { while ((tw % 2) === 0) { tw /= 2; } }
       if (th !== 1) { while ((th % 2) === 0) { th /= 2; } }
       if (tw > 1) { isPOT = false; }
       if (th > 1) { isPOT = false; }       
     }

      var vTexel = [1.0/width,1.0/height,0];

    // buffers
    this.outputBuffer = new RenderBuffer(width,height,false);

    // quads
    this.fsQuad = PostProcessChain.prototype.makeFSQuad(width,height);
    
    var vs = ["attribute vec3 aVertex;",
    "attribute vec2 aTex;",
    "varying vec2 vTex;",
    "void main(void)",
    "{",
    "  vTex = aTex;",
    "  vec4 vPos = vec4(aVertex.xyz,1.0);",
    "  gl_Position = vPos;",
    "}"].join("\n");
  

    // simple convolution test shader
    shaderNMap = new Shader(vs,      
    ["#ifdef GL_ES",
    "precision highp float;",
    "#endif",
    "uniform sampler2D srcTex;",
    "varying vec2 vTex;",
    "uniform vec3 texel;",
    "void main(void)",
    "{",
    " vec3 color;",
    " color.r = (texture2D(srcTex,vTex + vec2(texel.x,0)).r-texture2D(srcTex,vTex + vec2(-texel.x,0)).r)/2.0 + 0.5;",
    " color.g = (texture2D(srcTex,vTex + vec2(0,-texel.y)).r-texture2D(srcTex,vTex + vec2(0,texel.y)).r)/2.0 + 0.5;",
    " color.b = 1.0;",
    " gl_FragColor.rgb = color;",
    " gl_FragColor.a = 1.0;",
    "}"].join("\n"));
    
    shaderNMap.use();      
    shaderNMap.addUVArray("aTex");
    shaderNMap.addVertexArray("aVertex");
    shaderNMap.addInt("srcTex",0);
    shaderNMap.addVector("texel");
    shaderNMap.setVector("texel",vTexel);      

    this.shaderNorm = shaderNMap;

    // bind functions to "subclass" a texture
    this.setFilter=this.outputBuffer.texture.setFilter;
    this.clear=this.outputBuffer.texture.clear;
    this.use=this.outputBuffer.texture.use;
    this.tex_id=this.outputBuffer.texture.tex_id;
    this.filterType=this.outputBuffer.texture.filterType;

    this.outTex.use(gl.TEXTURE0);
    // 
    // if (!isPOT) {
    //    this.setFilter(enums.texture.filter.LINEAR);
    //    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    //    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);    
    //  } else {
       this.setFilter(enums.texture.filter.LINEAR);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    //  }
    
  }
  
  
  
  NormalMapGen.prototype.update = function()
  {
    var gl = GLCore.gl;

    var dims = gl.getParameter(gl.VIEWPORT);

    this.outputBuffer.use();
    
    gl.viewport(0, 0, this.width, this.height);
    
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    this.srcTex.use(gl.TEXTURE0);

    PostProcessChain.prototype.renderFSQuad(this.shaderNorm,this.fsQuad);  // copy the output buffer to the screen via fullscreen quad

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    
    gl.viewport(dims[0], dims[1], dims[2], dims[3]);
  }



 function DeferredBin()
 {
   this.meshBin = {};
   this.imageBin = {};
   
   this.meshMap = {};
   this.imageMap = {};
   
   this.imageBinPtr = {};
   this.meshBinPtr = {};
 }
 
 DeferredBin.prototype.addMesh = function(binId,meshId,meshObj) {
   if (this.meshBin[binId] === undef)
   {
     this.meshBin[binId] = [];
     if (this.meshBinPtr[binId]===undef) {
       this.meshBinPtr[binId] = 0;       
     }
   }

   if (this.meshMap[meshId] === undef)
   {
     this.meshMap[meshId] = meshObj;
     this.meshBin[binId].push(meshObj);
   }
 }
 
 DeferredBin.prototype.addImage = function(binId,imageId,imageObj) {
   if (this.imageBin[binId] === undef)
   {
     this.imageBin[binId] = [];
     if (this.imageBinPtr[binId]===undef) {
       this.imageBinPtr[binId] = 0;       
     }
   }
   
   if (this.imageMap[imageId] === undef)
   {
     this.imageMap[imageId] = imageObj;
     this.imageBin[binId].push(imageObj);
   }
 };
 
 DeferredBin.prototype.getMeshes = function(binId) {
   return this.meshBin[binId];
 };

 DeferredBin.prototype.getImages = function(binId) {
   return this.imageBin[binId];
 };
 
 DeferredBin.prototype.rewindMeshes = function(binId) {
   this.meshBinPtr[binId] = 0;
 };
 
 DeferredBin.prototype.rewindImages = function(binId) {
   this.imageBinPtr[binId] = 0;
 };
 
 DeferredBin.prototype.getNextMesh = function(binId) {
   var cBin = this.meshBinPtr[binId];

   if (cBin<this.meshBin[binId].length)
   {
     this.meshBinPtr[binId]++;
     return this.meshBin[binId][cBin];
   }
   
   return null;
 };
 
 DeferredBin.prototype.loadNextMesh = function(binId)
 {
   var mesh = this.getNextMesh(binId);
   
   if (mesh !== null)
   {
     if (mesh.compiled===null)
     {
       mesh.triangulateQuads();
       mesh.compile();
       mesh.clean();
     }
     
     return true;
   }

   return false;
 };

 DeferredBin.prototype.isMeshBinEmpty = function(binId) {
   //console.log('isMeshBinEmpty[' + binId + '] = ' + (this.meshBinPtr[binId] === this.meshBin[binId].length) + ' meshBinPtr = ' + this.meshBinPtr[binId] + ' meshBin.length = ' + this.meshBin[binId].length);
   return this.meshBinPtr[binId] === this.meshBin[binId].length;
 };

 DeferredBin.prototype.loadNextImage = function(binId)
 {
   var img = this.getNextImage(binId);
   
   if (img !== null) {
     img.src = img.deferredSrc;
//     return true;
   }

//   return false;
 };
 
 
 DeferredBin.prototype.getNextImage = function(binId) {
   var cBin = this.imageBinPtr[binId];
   
   if (cBin<this.imageBin[binId].length)
   {
     this.imageBinPtr[binId]++;
     return this.imageBin[binId][cBin];
   }
   
   return null;
 };

 DeferredBin.prototype.isImageBinEmpty = function(binId) {
   //console.log('isImageBinEmpty[' + binId + '] = ' + (this.imageBinPtr[binId] === this.imageBin[binId].length));
   return this.imageBinPtr[binId] === this.imageBin[binId].length ;
 };
 
function cubicvr_loadColladaWorker(meshUrl, prefix, callback, deferred_bin) {
  var worker;
  try {
    worker = new Worker(SCRIPT_LOCATION + 'collada.js');
  }
  catch(e) {
    throw new Error("Can't find collada.js");
  } //try

  var materials_map = [];
  var meshes_map = [];

  worker.onmessage = function(e) {

    function copyObjectFromJSON(json, obj) {
      for (var i in json) {
        obj[i] = json[i];
      } //for
    } //new_obj

    var message = e.data.message;
    if (message == 'materials') {
      var mats = JSON.parse(e.data.data);
      for (var i=0, maxI=mats.length; i<maxI; ++i) {
        var new_mat = new Material(mats[i].name);
        var mat_id = new_mat.material_id;
        copyObjectFromJSON(mats[i], new_mat);
        new_mat.material_id = mat_id;
        materials_map[mats[i].material_id] = mat_id;
        for (var j=0, maxJ=mats[i].textures.length; j<maxJ; ++j) {
          var dt = mats[i].textures[j];
          if (dt) {
            var stored_tex = Texture_ref[dt.img_path];

            if (stored_tex === undefined) {
              var t = new Texture(dt.img_path, dt.filter_type, deferred_bin, meshUrl);
              new_mat.textures[j] = t;
            }
            else {
              new_mat.textures[j] = Textures_obj[stored_tex];
            } //if
          }
          else {
            new_mat.textures[j] = 0;
          } //if
        } //for
      } //for
    }
    else if (message == 'scene') {
      var scene = JSON.parse(e.data.data);

      function reassembleMotion(obj) {
        //reassemble linked-list for sceneObject motion envelope keys
        if (obj.motion) {
          var co = obj.motion.controllers;
          var new_controllers = [];
          for (var j=0, maxJ=co.length; j<maxJ; ++j) {
            var con = co[j];
            if (!con) {
              co[j] = undefined;
              continue;
            }
            var new_con = [];
            for (var k=0, maxK=con.length; k<maxK; ++k) {
              var env = con[k];
              if (!env) {
                con[k] = undefined;
                continue;
              }
              var keys = env.keys[0];
              if (env.keys.length > 1) {
                keys.prev = null;
                keys.next = env.keys[1];
                keys = env.keys[1];
              } //if
              for (var keyI=1,maxKeyI=env.keys.length-1; keyI<maxKeyI; ++keyI) {
                keys.prev = env.keys[keyI-1];
                keys.next = env.keys[keyI+1];
                keys = env.keys[keyI+1];
              } //for keyI
              if (env.keys.length > 1) {
                keys = env.keys[env.keys.length-1];
                keys.prev = env.keys[env.keys.length-2];
                keys.next = null;
              } //if
              env.firstKey = env.keys[0];
              env.lastKey = env.keys[env.keys.length-1];
              env.keys = env.firstKey;

              var envelope = new Envelope();
              copyObjectFromJSON(env, envelope);
              new_con[k]=envelope;
            } //for k
            new_controllers[j] = new_con;
          } //for j
          obj.motion.controllers = new_controllers;
          var motion = new Motion();
          copyObjectFromJSON(obj.motion, motion);
          obj.motion = motion;
        } //if
      } //reassembleMotion

      for (var i=0, maxI=scene.sceneObjects.length; i<maxI; ++i) {
        var so = scene.sceneObjects[i];

        if (so.obj !== null) {
         nop();
        } //if

        if (so.reassembled === undefined) {
          reassembleMotion(so);
          so.reassembled = true;
        } //if

        function createSceneObject(scene_obj) {
          var sceneObject = new SceneObject();
          copyObjectFromJSON(scene_obj, sceneObject);
          if (scene_obj.obj !== null) {
            var stored_mesh = meshes_map[scene_obj.obj.id];
            if (stored_mesh === undefined) {
              var mesh = new Mesh();
              copyObjectFromJSON(scene_obj.obj, mesh);
              sceneObject.obj = mesh;
              meshes_map[scene_obj.obj.id] = mesh;
              if (deferred_bin) {
                if (mesh.points.length > 0) {
                  deferred_bin.addMesh(meshUrl,meshUrl+":"+mesh.id,mesh) 
                  for (var f=0,maxF=mesh.faces.length; f<maxF; ++f) {
                    var face = mesh.faces[f];
                    var m_index = face.material;
                    var mapped = materials_map[m_index];
                    if (mapped !== undefined) {
                      face.material = materials_map[m_index];
                    }
                    else {
                      face.material = 0;
                    } //if
                  } //for
                } //if
              }
              else {
                sceneObject.obj.triangulateQuads();
                sceneObject.obj.calcNormals();
                sceneObject.obj.compile();
                sceneObject.obj.clean();
              } //if
            }
            else {
              sceneObject.obj = stored_mesh;
            } //if
          } //if
          
          sceneObject.trans = new Transform();

          if (scene_obj.children && scene_obj.children.length > 0) {
            sceneObject.children = [];
            createChildren(scene_obj, sceneObject);
          } //if

          return sceneObject;
        } //createSceneObject

        function createChildren(scene_obj, sceneObject) {
          if (scene_obj.children) {
            for (var j=0, maxJ=scene_obj.children.length; j<maxJ; ++j) {
              var child = createSceneObject(scene_obj.children[j]);
              sceneObject.bindChild(child);
            } //for
          } //if
        } //createChildren

        scene.sceneObjects[i] = createSceneObject(so);

      } //for i

      var new_scene = new Scene();
      // place parsed scene elements into new scene (since parse scene has no prototype)
      var camera = new_scene.camera;
      var camera_transform = camera.transform;
      copyObjectFromJSON(scene.camera, camera);
      copyObjectFromJSON(scene.camera.transform, camera_transform);
      reassembleMotion(camera);
      new_scene.camera = camera;
      new_scene.camera.transform = camera_transform;
      new_scene.camera.frustum = new Frustum();

      for (var i=0, maxI=scene.sceneObjects.length; i<maxI; ++i) {
        var o = scene.sceneObjects[i];
        new_scene.bindSceneObject(o);
        try {
          o.getAABB();
        }
        catch(e) {
          //console.log(o);
        } //try
        
      } //for

      for (var i=0, maxI=scene.lights.length; i<maxI; ++i) {
        var l = new Light();
        copyObjectFromJSON(scene.lights[i], l);
        l.trans = new Transform();
        reassembleMotion(l);
        new_scene.bindLight(l);
      } //for

      callback(new_scene);
    }
    else {
      console.log("message from collada worker:", e.data.message);
    } //if
  } //onmessage

  worker.onerror = function(e) {
    console.log("error from collada worker:", e.message);
  } //onerror

  worker.postMessage({message:'start', params: {meshUrl: meshUrl, prefix: prefix, rootDir: SCRIPT_LOCATION}});
} //cubicvr_loadColladaWorker


function xml2badgerfish(xmlDoc) {
    var jsonData = {};
    var nodeStack = [];

    var i, iMax, iMin;

    var n = xmlDoc;
    var j = jsonData;
    var cn, tn;
    var regEmpty = /^\s+|\s+$/g;

    xmlDoc.jsonParent = j;
    nodeStack.push(xmlDoc);

    while (nodeStack.length) {
        var n = nodeStack.pop();
        var tagGroup = null;

        j = n.jsonParent;

        for (i = 0, iMax = n.childNodes.length; i < iMax; i++) {
            cn = n.childNodes[i];
            tn = cn.tagName;

            if (tn !== undef) {
                tagGroup = tagGroup || {};
                tagGroup[tn] = tagGroup[tn] || 0;
                tagGroup[tn]++;
            }
        }

        if (n.attributes) if (n.attributes.length) {
            for (i = 0, iMax = n.attributes.length; i < iMax; i++) {
                var att = n.attributes[i];

                j["@" + att.name] = att.value;
            }
        }

        for (i = 0, iMax = n.childNodes.length; i < iMax; i++) {
            cn = n.childNodes[i];
            tn = cn.tagName;

            if (cn.nodeType === 1) {
                if (tagGroup[tn] > 1) {
                    j[tn] = j[tn] || [];
                    j[tn].push({});
                    cn.jsonParent = j[tn][j[tn].length - 1];
                } else {
                    j[tn] = j[tn] || {};
                    cn.jsonParent = j[tn];
                }
                nodeStack.push(cn);
            } else if (cn.nodeType === 3) {
                if (cn.nodeValue.replace(regEmpty, "") !== "") {
                    j.$ = j.$ || "";
                    j.$ += cn.nodeValue;
                }
            }
        }
    }

    return jsonData;
}

var collada_tools = {
    fixuaxis: function (up_axis, v) {
        if (up_axis === 0) { // untested
            return [v[1], v[0], v[2]];
        } else if (up_axis === 1) {
            return v;
        } else if (up_axis === 2) {
            return [v[0], v[2], -v[1]];
        }
    },
    fixscaleaxis: function (up_axis, v) {
        if (up_axis === 0) { // untested
            return [v[1], v[0], v[2]];
        } else if (up_axis === 1) {
            return v;
        } else if (up_axis === 2) {
            return [v[0], v[2], v[1]];
        }
    },
    fixukaxis: function (up_axis, mot, chan, val) {
        // if (mot === enums.motion.POS && chan === enums.motion.Y && up_axis === enums.motion.Z) return -val;
        if (mot === enums.motion.POS && chan === enums.motion.Z && up_axis === enums.motion.Z) {
            return -val;
        }
        return val;
    },
    getAllOf: function (root_node, leaf_name) {
        var nStack = [root_node];
        var results = [];

        while (nStack.length) {
            var n = nStack.pop();

            for (var i in n) {
                if (!n.hasOwnProperty(i)) continue;

                if (i === leaf_name) {
                    if (n[i].length) {
                        for (var p = 0, pMax = n[i].length; p < pMax; p++) {
                            results.push(n[i][p]);
                        }
                    } else {
                        results.push(n[i]);
                    }
                }
                if (typeof(n[i]) == 'object') {
                    if (n[i].length) {
                        for (var p = 0, pMax = n[i].length; p < pMax; p++) {
                            nStack.push(n[i][p]);
                        }
                    } else {
                        nStack.push(n[i]);
                    }
                }
            }
        }

        return results;
    },
    quaternionFilterZYYZ: function (rot, ofs) {
        var r = rot;
        var temp_q = new Quaternion();

        if (ofs !== undef) {
            r = vec3.add(rot, ofs);
        }

        temp_q.fromEuler(r[0], r[2], -r[1]);

        return temp_q.toEuler();
    },
    cl_getInitalTransform: function (up_axis, scene_node) {
        var retObj = {
            position: [0, 0, 0],
            rotation: [0, 0, 0],
            scale: [1, 1, 1]
        };

        var translate = scene_node.translate;
        var rotate = scene_node.rotate;
        var scale = scene_node.scale;

        if (translate) {
            retObj.position = collada_tools.fixuaxis(up_axis, util.floatDelimArray(translate.$, " "));
        }


        if (rotate) {
            for (var r = 0, rMax = rotate.length; r < rMax; r++) {
                var cl_rot = rotate[r];

                var rType = cl_rot["@sid"];

                var rVal = util.floatDelimArray(cl_rot.$, " ");

                if (rType == "rotateX" || rType == "rotationX") {
                    retObj.rotation[0] = rVal[3];
                } else if (rType == "rotateY" || rType == "rotationY") {
                    retObj.rotation[1] = rVal[3];
                } else if (rType == "rotateZ" || rType == "rotationZ") {
                    retObj.rotation[2] = rVal[3];
                } //if
            } //for
        } //if
        if (scale) {
            retObj.scale = collada_tools.fixscaleaxis(up_axis, util.floatDelimArray(scale.$, " "));
        }

        // var cl_matrix = scene_node.getElementsByTagName("matrix");
        // 
        // if (cl_matrix.length)
        // {
        //   console.log(util.collectTextNode(cl_matrix[0]));
        // }
        return retObj;
    }
};



function cubicvr_parseCollada(meshUrl, prefix, deferred_bin) {
    //  if (MeshPool[meshUrl] !== undef) return MeshPool[meshUrl];
    var obj = new Mesh();
    var scene = new Scene();
    var cl = util.getXML(meshUrl);
    var tech;
    var sourceId;
    var materialRef, nameRef, nFace, meshName;

    var norm, vert, uv, mapLen, computedLen;

    var i, iCount, iMax, iMod, mCount, mMax, k, kMax, cCount, cMax, sCount, sMax, pCount, pMax, j, jMax;

    var cl_source = xml2badgerfish(cl);

    cl = null;

    if (!cl_source.COLLADA) {
        throw new Error(meshUrl + " does not appear to be a valid COLLADA file.");
    }

    cl_source = cl_source.COLLADA;

    var clib = {
        up_axis: 1,
        images: [],
        effects: [],
        materials: [],
        meshes: [],
        scenes: [],
        lights: [],
        cameras: [],
        animations: []
    };


    // var up_axis = 1; // Y
    if (cl_source.asset) {
        var sAxis = cl_source.asset.up_axis.$;
        if (sAxis === "X_UP") {
            clib.up_axis = 0;
        } else if (sAxis === "Y_UP") {
            clib.up_axis = 1;
        } else if (sAxis === "Z_UP") {
            clib.up_axis = 2;
        }
    }

    var up_axis = clib.up_axis;


    if (cl_source.library_images) {
      if (cl_source.library_images.image && !cl_source.library_images.image.length) cl_source.library_images.image = [cl_source.library_images.image];
      if (cl_source.library_images.image.length) {
        var cl_images = cl_source.library_images.image;
        for (var imgCount = 0, imgCountMax = cl_images.length; imgCount < imgCountMax; imgCount++) {
            var cl_img = cl_images[imgCount];
            var imageId = cl_img["@id"];
            var imageName = cl_img["@name"];
            var cl_imgsrc = cl_img.init_from;

            if (cl_imgsrc.$) {
                var imageSource = cl_imgsrc.$;

                if (prefix !== undef && (imageSource.lastIndexOf("/") !== -1)) {
                    imageSource = imageSource.substr(imageSource.lastIndexOf("/") + 1);
                }
                if (prefix !== undef && (imageSource.lastIndexOf("\\") !== -1)) {
                    imageSource = imageSource.substr(imageSource.lastIndexOf("\\") + 1);
                }
                // console.log("Image reference: "+imageSource+" @"+imageId+":"+imageName);
                clib.images[imageId] = {
                    source: imageSource,
                    id: imageId,
                    name: imageName
                };
            }
          }
        }
    }

    // Effects
    var effectId;
    var effectCount, effectMax;
    var tCount, tMax, inpCount, inpMax;
    var cl_params, cl_inputs, cl_input, cl_inputmap, cl_samplers, cl_camera, cl_cameras, cl_scene;
    var ofs;


    if (cl_source.library_effects) {
        var cl_effects = cl_source.library_effects.effect;

        if (cl_effects && !cl_effects.length) cl_effects = [cl_effects];

        for (effectCount = 0, effectMax = cl_effects.length; effectCount < effectMax; effectCount++) {
            var cl_effect = cl_effects[effectCount];

            effectId = cl_effect["@id"];

            var effect = {};

            effect.id = effectId;

            effect.surfaces = [];
            effect.samplers = [];

            cl_params = cl_effect.profile_COMMON.newparam;

            if (cl_params && !cl_params.length) {
                cl_params = [cl_params];
            };

            var params = [];

            var cl_init;

            if (cl_params) {
                for (pCount = 0, pMax = cl_params.length; pCount < pMax; pCount++) {
                    var cl_param = cl_params[pCount];

                    var paramId = cl_param["@sid"];

                    if (cl_param.surface) {
                        effect.surfaces[paramId] = {};

                        var initFrom = cl_param.surface.init_from.$;

                        if (typeof(clib.images[initFrom]) === 'object') {

                            var img_path = prefix + "/" + clib.images[initFrom].source;
                            effect.surfaces[paramId].source = img_path;
                            //                console.log(prefix+"/"+clib.images[initFrom].source);
                        }
                    } else if (cl_param.sampler2D) {
                        effect.samplers[paramId] = {};

                        effect.samplers[paramId].source = cl_param.sampler2D.source.$;

                        if (cl_param.sampler2D.minfilter) {
                            effect.samplers[paramId].minfilter = cl_param.sampler2D.minfilter.$;
                        }

                        if (cl_param.sampler2D.magfilter) {
                            effect.samplers[paramId].magfiter = cl_param.sampler2D.magfilter.$;
                        }
                    }

                }
            }

            var cl_technique = cl_effect.profile_COMMON.technique;

            if (cl_technique && !cl_technique.length) cl_technique = [cl_technique];

            var getColorNode = (function () {
                return function (n) {
                    var el = n.color;
                    if (!el) {
                        return false;
                    }

                    var cn = n.color;
                    var ar = cn ? util.floatDelimArray(cn.$, " ") : false;

                    return ar;
                };
            }());

            var getFloatNode = (function () {
                return function (n) {
                    var el = n['float'];
                    if (!el) {
                        return false;
                    }

                    var cn = n['float'];
                    cn = cn ? parseFloat(cn.$) : 0;

                    return cn;
                };
            }());

            var getTextureNode = (function () {
                return function (n) {
                    var el = n.texture;
                    if (!el) {
                        return false;
                    }

                    var cn = n.texture["@texture"];

                    return cn;
                };
            }());

            //            effect.material = new Material(effectId);
            effect.material = {
                textures_ref: []
            }

            for (tCount = 0, tMax = cl_technique.length; tCount < tMax; tCount++) {
                //        if (cl_technique[tCount].getAttribute("sid") === 'common') {
                tech = cl_technique[tCount].blinn;

                if (!tech) {
                    tech = cl_technique[tCount].phong;
                }
                if (!tech) {
                    tech = cl_technique[tCount].lambert;
                }

                if (tech) {
                    // for (var eCount = 0, eMax = tech[0].childNodes.length; eCount < eMax; eCount++) {
                    //   var node = tech[0].childNodes[eCount];
                    for (var tagName in tech) {
                        var node = tech[tagName];

                        var c = getColorNode(node);
                        var f = getFloatNode(node);
                        var t = getTextureNode(node);

                        if (c !== false) {
                            if (c.length > 3) {
                                c.pop();
                            }
                        }

                        if (tagName == "emission") {
                            if (c !== false) {
                                effect.material.ambient = c;
                            }
                        } else if (tagName == "ambient") {} else if (tagName == "diffuse") {
                            if (c !== false) {
                                effect.material.color = c;
                            }
                        } else if (tagName == "specular") {
                            if (c !== false) {
                                effect.material.specular = c;
                            }
                        } else if (tagName == "shininess") {
                            if (f !== false) {
                                effect.material.shininess = f;
                            }
                        } else if (tagName == "reflective") {
                          nop();
                        } else if (tagName == "reflectivity") {
                          nop();
                        } else if (tagName == "transparent") {
                          nop();
                        } else if (tagName == "index_of_refraction") {
                          nop();
                        }

                        // case "transparency": if (f!==false) effect.material.opacity = 1.0-f; break;
                        if (t !== false) {
                            var srcTex = effect.surfaces[effect.samplers[t].source].source;
                            if (tagName == "emission") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.AMBIENT
                                });
                            } else if (tagName == "ambient") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.AMBIENT
                                });
                            } else if (tagName == "diffuse") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.COLOR
                                });
                            } else if (tagName == "specular") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.SPECULAR
                                });
                            } else if (tagName == "shininess") {} else if (tagName == "reflective") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.REFLECT
                                });
                            } else if (tagName == "reflectivity") {} else if (tagName == "transparent") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.ALPHA
                                });
                            } else if (tagName == "transparency") {
                              nop();
                            } else if (tagName == "index_of_refraction") {
                              nop();
                            }
                        }
                    }
                }

                clib.effects[effectId] = effect;
            }
        }
    }

    // End Effects

    var cl_lib_mat_inst = collada_tools.getAllOf(cl_source.library_visual_scenes, "instance_material");
    var materialMap = [];

    if (cl_lib_mat_inst.length) {
        for (i = 0, iMax = cl_lib_mat_inst.length; i < iMax; i++) {
            var cl_mat_inst = cl_lib_mat_inst[i];

            var symbolId = cl_mat_inst["@symbol"];
            var targetId = cl_mat_inst["@target"].substr(1);

            materialMap[symbolId] = targetId;
        }
    }


    var cl_lib_materials = cl_source.library_materials;

    if (cl_lib_materials.material) {
        var cl_materials = cl_lib_materials.material;
        if (cl_materials && !cl_materials.length) cl_materials = [cl_materials];

        for (mCount = 0, mMax = cl_materials.length; mCount < mMax; mCount++) {
            var cl_material = cl_materials[mCount];

            var materialId = cl_material["@id"];
            var materialName = cl_material["@name"];

            var cl_einst = cl_material.instance_effect;

            if (cl_einst) {
                effectId = cl_einst["@url"].substr(1);
                clib.materials.push({
                    id: materialId,
                    name: materialName,
                    mat: clib.effects[effectId].material
                });
            }
        }
    }

    var cl_lib_geo = cl_source.library_geometries;

    if (cl_lib_geo) {
        var cl_geo_node = cl_lib_geo.geometry;

        if (cl_geo_node && !cl_geo_node.length) cl_geo_node = [cl_geo_node];

        if (cl_geo_node.length) {
            for (var meshCount = 0, meshMax = cl_geo_node.length; meshCount < meshMax; meshCount++) {
                var meshData = {
                    id: undef,
                    points: [],
                    parts: []
                };

                var currentMaterial;

                var cl_geomesh = cl_geo_node[meshCount].mesh;

                // console.log("found "+meshUrl+"@"+meshName);
                if (cl_geomesh) {
                    var meshId = cl_geo_node[meshCount]["@id"];
                    meshName = cl_geo_node[meshCount]["@name"];

                    //                    MeshPool[meshUrl + "@" + meshName] = newObj;
                    var cl_geosources = cl_geomesh.source;
                    if (cl_geosources && !cl_geosources.length) cl_geosources = [cl_geosources];

                    var geoSources = [];

                    for (var sourceCount = 0, sourceMax = cl_geosources.length; sourceCount < sourceMax; sourceCount++) {
                        var cl_geosource = cl_geosources[sourceCount];

                        sourceId = cl_geosource["@id"];
                        var sourceName = cl_geosource["@name"];
                        var cl_floatarray = cl_geosource.float_array;


                        if (cl_floatarray) {
                            geoSources[sourceId] = {
                                id: sourceId,
                                name: sourceName,
                                data: util.floatDelimArray(cl_floatarray.$?cl_floatarray.$:"", " ")
                            };
                        }

                        var cl_accessor = cl_geosource.technique_common.accessor;

                        if (cl_accessor) {
                            geoSources[sourceId].count = parseInt(cl_accessor["@count"]);
                            geoSources[sourceId].stride = parseInt(cl_accessor["@stride"]);
                            if (geoSources[sourceId].count) {
                                geoSources[sourceId].data = util.repackArray(geoSources[sourceId].data, geoSources[sourceId].stride, geoSources[sourceId].count);
                            }
                        }
                    }

                    var geoVerticies = [];

                    var cl_vertices = cl_geomesh.vertices;

                    var pointRef = null;
                    var pointRefId = null;
                    var triangleRef = null;
                    var normalRef = null;
                    var uvRef = null;


                    if (cl_vertices) {
                        pointRefId = cl_vertices["@id"];
                        cl_inputs = cl_vertices.input;

                        if (cl_inputs && !cl_inputs.length) cl_inputs = [cl_inputs];

                        if (cl_inputs) {
                            for (inpCount = 0, inpMax = cl_inputs.length; inpCount < inpMax; inpCount++) {
                                cl_input = cl_inputs[inpCount];

                                if (cl_input["@semantic"] === "POSITION") {
                                    pointRef = cl_input["@source"].substr(1);
                                }
                            }
                        }
                    }

                    var CL_VERTEX = 0,
                        CL_NORMAL = 1,
                        CL_TEXCOORD = 2,
                        CL_OTHER = 3;


                    var cl_triangles = cl_geomesh.triangles;
                    if (cl_triangles && !cl_triangles.length) cl_triangles = [cl_triangles];

                    var v_c = false,
                        n_c = false,
                        u_c = false;

                    if (cl_triangles) {
                        for (tCount = 0, tMax = cl_triangles.length; tCount < tMax; tCount++) {
                            var meshPart = {
                                material: 0,
                                faces: [],
                                normals: [],
                                texcoords: []
                            }

                            var cl_trianglesCount = parseInt(cl_triangles[tCount]["@count"], 10);
                            cl_inputs = cl_triangles[tCount].input;
                            if (cl_inputs && !cl_inputs.length) cl_inputs = [cl_inputs];

                            cl_inputmap = [];

                            if (cl_inputs.length) {
                                for (inpCount = 0, inpMax = cl_inputs.length; inpCount < inpMax; inpCount++) {
                                    cl_input = cl_inputs[inpCount];

                                    ofs = parseInt(cl_input["@offset"], 10);
                                    nameRef = cl_input["@source"].substr(1);

                                    if (cl_input["@semantic"] === "VERTEX") {
                                        if (nameRef === pointRefId) {
                                            nameRef = triangleRef = pointRef;
                                        } else {
                                            triangleRef = nameRef;
                                        }
                                        v_c = true;
                                        cl_inputmap[ofs] = CL_VERTEX;
                                    } else if (cl_input["@semantic"] === "NORMAL") {
                                        normalRef = nameRef;
                                        if (geoSources[normalRef].count) {
                                            cl_inputmap[ofs] = CL_NORMAL;
                                        }
                                        n_c = true;
                                    } else if (cl_input["@semantic"] === "TEXCOORD") {
                                        uvRef = nameRef;
                                        if (geoSources[uvRef].count) {
                                            cl_inputmap[ofs] = CL_TEXCOORD;
                                        }
                                        u_c = true;
                                    } else {
                                        cl_inputmap[ofs] = CL_OTHER;
                                    }
                                }
                            }
                            mapLen = cl_inputmap.length;

                            materialRef = cl_triangles[tCount]["@material"];

                            if (materialRef === null) {
                                meshPart.material = 0;
                            } else {
                                if (materialMap[materialRef] === undef) {
                                    log("missing material [" + materialRef + "]@" + meshName + "?");
                                    meshPart.material = 0;
                                } else {
                                    meshPart.material = materialMap[materialRef];
                                }
                            }


                            var cl_triangle_source = cl_triangles[tCount].p;

                            var triangleData = [];

                            if (cl_triangle_source) {
                                triangleData = util.intDelimArray(cl_triangle_source.$, " ");
                            }

                            if (triangleData.length) {
                                computedLen = ((triangleData.length) / cl_inputmap.length) / 3;

                                if (computedLen !== cl_trianglesCount) {
                                    //                console.log("triangle data doesn't add up, skipping object load: "+computedLen+" !== "+cl_trianglesCount);
                                } else {
                                    if (meshData.points.length === 0) {
                                        meshData.points = geoSources[pointRef].data;
                                    }

                                    ofs = 0;

                                    for (i = 0, iMax = triangleData.length, iMod = cl_inputmap.length; i < iMax; i += iMod * 3) {
                                        norm = [];
                                        vert = [];
                                        uv = [];

                                        for (j = 0; j < iMod * 3; j++) {
                                            var jMod = j % iMod;

                                            if (cl_inputmap[jMod] === CL_VERTEX) {
                                                vert.push(triangleData[i + j]);
                                            } else if (cl_inputmap[jMod] === CL_NORMAL) {
                                                norm.push(triangleData[i + j]);
                                            } else if (cl_inputmap[jMod] === CL_TEXCOORD) {
                                                uv.push(triangleData[i + j]);
                                            }
                                        }

                                        if (vert.length) {
                                            meshPart.faces.push(vert);

                                            if (norm.length === 3) {
                                                meshPart.normals.push([collada_tools.fixuaxis(clib.up_axis, geoSources[normalRef].data[norm[0]]), collada_tools.fixuaxis(clib.up_axis, geoSources[normalRef].data[norm[1]]), collada_tools.fixuaxis(clib.up_axis, geoSources[normalRef].data[norm[2]])]);
                                            }


                                            if (uv.length === 3) {
                                                meshPart.texcoords.push([geoSources[uvRef].data[uv[0]], geoSources[uvRef].data[uv[1]], geoSources[uvRef].data[uv[2]]]);
                                            }
                                        }
                                    }
                                }
                            }
                            
                            meshData.parts.push(meshPart);
                        }
                    }


                    var cl_polylist = cl_geomesh.polylist;
                    if (!cl_polylist) {
                        cl_polylist = cl_geomesh.polygons; // try polygons                
                    }

                    if (cl_polylist && !cl_polylist.length) cl_polylist = [cl_polylist];

                    if (cl_polylist) {
                        for (tCount = 0, tMax = cl_polylist.length; tCount < tMax; tCount++) {
                            var meshPart = {
                                material: 0,
                                faces: [],
                                normals: [],
                                texcoords: []
                            }

                            var cl_polylistCount = parseInt(cl_polylist[tCount]["@count"], 10);

                            cl_inputs = cl_polylist[tCount].input;

                            if (cl_inputs && !cl_inputs.length) cl_inputs = [cl_inputs];

                            cl_inputmap = [];

                            if (cl_inputs.length) {
                                for (inpCount = 0, inpMax = cl_inputs.length; inpCount < inpMax; inpCount++) {
                                    cl_input = cl_inputs[inpCount];

                                    var cl_ofs = cl_input["@offset"];

                                    if (cl_ofs === null) {
                                        cl_ofs = cl_input["@idx"];
                                    }

                                    ofs = parseInt(cl_ofs, 10);
                                    nameRef = cl_input["@source"].substr(1);

                                    if (cl_input["@semantic"] === "VERTEX") {
                                        if (nameRef === pointRefId) {
                                            nameRef = triangleRef = pointRef;

                                        } else {
                                            triangleRef = nameRef;
                                        }
                                        cl_inputmap[ofs] = CL_VERTEX;
                                    } else if (cl_input["@semantic"] === "NORMAL") {
                                        normalRef = nameRef;
                                        cl_inputmap[ofs] = CL_NORMAL;
                                    } else if (cl_input["@semantic"] === "TEXCOORD") {
                                        uvRef = nameRef;
                                        cl_inputmap[ofs] = CL_TEXCOORD;
                                    } else {
                                        cl_inputmap[ofs] = CL_OTHER;
                                    }
                                }
                            }


                            var cl_vcount = cl_polylist[tCount].vcount;
                            var vcount = [];

                            if (cl_vcount) {
                                vcount = util.intDelimArray(cl_vcount.$, " ");
                            }

                            materialRef = cl_polylist[tCount]["@material"];

                            if (materialRef === undef) {
                                meshPart.material = 0;
                            } else {
                                meshPart.material = materialMap[materialRef];
                            }

                            var cl_poly_source = cl_polylist[tCount].p;

                            mapLen = cl_inputmap.length;

                            var polyData = [];

                            if ((cl_poly_source.length > 1) && !vcount.length) // blender 2.49 style
                            {
                                var pText = "";
                                for (pCount = 0, pMax = cl_poly_source.length; pCount < pMax; pCount++) {
                                    var tmp = util.intDelimArray(cl_poly_source[pCount].$, " ");

                                    vcount[pCount] = parseInt(tmp.length / mapLen, 10);

                                    polyData.splice(polyData.length, 0, tmp);
                                }
                            } else {
                                if (cl_poly_source) {
                                    polyData = util.intDelimArray(cl_poly_source.$, " ");
                                }
                            }

                            if (polyData.length) {
                                computedLen = vcount.length;

                                if (computedLen !== cl_polylistCount) {
                                    log("poly vcount data doesn't add up, skipping object load: " + computedLen + " !== " + cl_polylistCount);
                                } else {
                                    if (meshData.points.length === 0) {
                                        meshData.points = geoSources[pointRef].data;
                                    }

                                    ofs = 0;

                                    for (i = 0, iMax = vcount.length; i < iMax; i++) {
                                        norm = [];
                                        vert = [];
                                        uv = [];

                                        for (j = 0, jMax = vcount[i] * mapLen; j < jMax; j++) {
                                            if (cl_inputmap[j % mapLen] === CL_VERTEX) {
                                                vert.push(polyData[ofs]);
                                                ofs++;
                                            } else if (cl_inputmap[j % mapLen] === CL_NORMAL) {
                                                norm.push(polyData[ofs]);
                                                ofs++;
                                            } else if (cl_inputmap[j % mapLen] === CL_TEXCOORD) {
                                                uv.push(polyData[ofs]);
                                                ofs++;
                                            }
                                        }


                                        if (vert.length) {
                                            // if (up_axis !== 1)
                                            // {
                                            //   vert.reverse();
                                            // }
                                            // nFace = newObj.addFace(vert);
                                            meshPart.faces.push(vert);

                                            if (norm.length) {
                                                var nlist = [];
                                                for (k = 0, kMax = norm.length; k < kMax; k++) {
                                                    // newObj.faces[nFace].point_normals[k] = fixuaxis(geoSources[normalRef].data[norm[k]]);
                                                    nlist.push(collada_tools.fixuaxis(clib.up_axis, geoSources[normalRef].data[norm[k]]));
                                                }
                                                meshPart.normals.push(nlist);
                                            }

                                            if (uv.length) {
                                                var tlist = [];
                                                for (k = 0, kMax = uv.length; k < kMax; k++) {
                                                    // newObj.faces[nFace].uvs[k] = geoSources[uvRef].data[uv[k]];
                                                    tlist.push(geoSources[uvRef].data[uv[k]]);
                                                }
                                                meshPart.texcoords.push(tlist);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (up_axis !== 1) {
                        for (i = 0, iMax = meshData.points.length; i < iMax; i++) {
                            meshData.points[i] = collada_tools.fixuaxis(clib.up_axis, meshData.points[i]);
                        }
                    }



                    meshData.id = meshId;
                    clib.meshes.push(meshData);

                }
            }
        }
    }





    var cl_lib_cameras = cl_source.library_cameras;
    var camerasBoundRef = [];

    if (cl_lib_cameras) {
        cl_cameras = cl_lib_cameras.camera;
        if (cl_cameras && !cl_cameras.length) cl_cameras = [cl_cameras];

        for (cCount = 0, cMax = cl_cameras.length; cCount < cMax; cCount++) {
            cl_camera = cl_cameras[cCount];

            var cameraId = cl_camera["@id"];
            var cameraName = cl_camera["@name"];

            //      var cl_perspective = cl_camera.getElementsByTagName("perspective");
            // if (cl_perspective.length) {
            //   var perspective = cl_perspective[0];
            var cl_yfov = 0;
            var cl_znear = 0;
            var cl_zfar = 0;

            if (cl_camera.optics) if (cl_camera.optics.technique_common) if (cl_camera.optics.technique_common.perspective) {
                cl_yfov = cl_camera.optics.technique_common.perspective.yfov;
                cl_znear = cl_camera.optics.technique_common.perspective.znear;
                cl_zfar = cl_camera.optics.technique_common.perspective.zfar;
            }


            var yfov;
            var znear;
            var zfar;

            if (!cl_yfov && !cl_znear && !cl_zfar) {
                cl_params = cl_camera.param;
                if (cl_params && !cl_params.length) cl_params = [cl_params];

                for (i = 0, iMax = cl_params.length; i < iMax; i++) {
                    var txt = cl_params[i].$;
                    var pName = cl_params[i]["@name"];
                    if (pName == "YFOV") {
                        yfov = parseFloat(txt);
                    } else if (pName == "ZNEAR") {
                        znear = parseFloat(txt);
                    } else if (pName == "ZFAR") {
                        zfar = parseFloat(txt);
                    }
                }
            } else {
                yfov = cl_yfov ? parseFloat(cl_yfov.$) : 60;
                znear = cl_znear ? parseFloat(cl_znear.$) : 0.1;
                zfar = cl_zfar ? parseFloat(cl_zfar.$) : 1000.0;
            }

            clib.cameras.push({
                id: cameraId,
                targeted: false,
                fov: parseFloat(yfov),
                nearclip: parseFloat(znear),
                farclip: parseFloat(zfar)
            });
        }
    }


    var cl_lib_lights = cl_source.library_lights;

    if (cl_lib_lights) {
        var cl_lights = cl_lib_lights.light;
        if (cl_lights && !cl_lights.length) cl_lights = [cl_lights];

        if (cl_lights) for (var lightCount = 0, lightMax = cl_lights.length; lightCount < lightMax; lightCount++) {

            var cl_light = cl_lights[lightCount];

            var cl_point = cl_light.technique_common.point;
            var cl_pointLight = cl_point ? cl_point : null;

            var lightId = cl_light["@id"];
            var lightName = cl_light["@name"];

            if (cl_pointLight !== null) {

                var cl_intensity = cl_pointLight.intensity;
                var intensity = cl_intensity ? parseFloat(cl_intensity.$) : 1.0;
                var cl_distance = cl_pointLight.distance;
                var distance = cl_distance ? parseFloat(cl_distance.$) : 10.0;

                var cl_color = cl_pointLight.color;
                var color = [1, 1, 1];

                if (cl_color) {
                    color = util.floatDelimArray(cl_color.$, " ");
                }

                clib.lights.push({
                    id: lightId,
                    name: lightId,
                    type: enums.light.type.POINT,
                    method: enums.light.method.STATIC,
                    diffuse: color,
                    specular: [0, 0, 0],
                    distance: distance,
                    intensity: intensity
                });
            }
        }
    }

    var cl_lib_scenes = cl_source.library_visual_scenes;

    if (cl_lib_scenes) {
        var cl_scenes = null;

        cl_scenes = cl_lib_scenes.visual_scene;
        if (cl_scenes && !cl_scenes.length) cl_scenes = [cl_scenes];

        for (var sceneCount = 0, sceneMax = cl_scenes.length; sceneCount < sceneMax; sceneCount++) {

            cl_scene = cl_scenes[sceneCount];

            var sceneId = cl_scene["@id"];
            var sceneName = cl_scene["@name"];

            var sceneData = {
                id: sceneId,
                sceneObjects: [],
                cameras: [],
                lights: [],
                parentMap: []
            };

            var nodeMap = {};

            var cl_nodes = [];
            var cl_stack = [cl_scene];

            while (cl_stack.length) {
                var ntemp = cl_stack.pop();
                if (ntemp.node) {
                    var nlist = ntemp.node;
                    if (nlist && !nlist.length) nlist = [nlist];

                    if (nlist) {
                        for (var i = 0, iMax = nlist.length; i < iMax; i++) {
                            nlist[i].parentNode = ntemp;
                            cl_nodes.push(nlist[i]);
                            cl_stack.push(nlist[i]);
                        }
                    }
                }
            }

            if (cl_nodes.length) {
                for (var nodeCount = 0, nodeMax = cl_nodes.length; nodeCount < nodeMax; nodeCount++) {
                    var cl_node = cl_nodes[nodeCount];

                    var cl_geom = cl_node.instance_geometry;
                    var cl_light = cl_nodes[nodeCount].instance_light;
                    cl_camera = cl_nodes[nodeCount].instance_camera;

                    var nodeId = cl_node["@id"];
                    var nodeName = cl_node["@name"];

                    var it = collada_tools.cl_getInitalTransform(clib.up_axis, cl_node);

                    if (up_axis === 2) {
                        it.rotation = collada_tools.quaternionFilterZYYZ(it.rotation, (cl_camera) ? [-90, 0, 0] : undef);
                    }

                    var sceneObject = {};

                    if (cl_geom) {
                        meshName = cl_geom["@url"].substr(1);

                        sceneObject.name = sceneObject.id = (nodeName) ? nodeName : nodeId;

                        sceneObject.position = it.position;
                        sceneObject.rotation = it.rotation;
                        sceneObject.scale = it.scale;
                        sceneObject.meshId = meshId;
                        sceneObject.meshName = meshName;

                        sceneData.sceneObjects.push(sceneObject);

                        nodeMap[sceneObject.id] = true;;

                        if (cl_node.parentNode) {
                            var parentNodeId = cl_node.parentNode["@id"];
                            var parentNodeName = cl_node.parentNode["@name"];
                            if (parentNodeId) {

                                if (nodeMap[parentNodeId]) {
                                    sceneData.parentMap.push({
                                        parent: parentNodeId,
                                        child: sceneObject.id
                                    });
                                }
                            }
                        }
                    } else if (cl_camera) {
                        var cam_instance = cl_camera;

                        var camRefId = cam_instance["@url"].substr(1);

                        sceneData.cameras.push({
                            name: (nodeName) ? nodeName : nodeId,
                            id: (nodeName) ? nodeName : nodeId,
                            source: camRefId,
                            position: it.position,
                            rotation: it.rotation
                        });


                    } else if (cl_light) {

                        var lightRefId = cl_light["@url"].substr(1);

                        sceneData.lights.push({
                            name: (nodeName) ? nodeName : nodeId,
                            id: (nodeName) ? nodeName : nodeId,
                            source: lightRefId,
                            position: it.position
                        });

                    } else {
                        sceneData.sceneObjects.push({
                            id: (nodeName !== null) ? nodeName : nodeId,
                            name: (nodeName !== null) ? nodeName : nodeId,
                            position: it.position,
                            rotation: it.rotation,
                            scale: it.scale
                        });

                    }

                }
            }

            clib.scenes.push(sceneData);
        }
    }


    var cl_lib_anim = cl_source.library_animations;

    var animId;
    if (cl_lib_anim) {
        var cl_anim_sources = cl_lib_anim.animation;
        if (cl_anim_sources && !cl_anim_sources.length) cl_anim_sources = [cl_anim_sources];

        if (cl_anim_sources) {
            for (var aCount = 0, aMax = cl_anim_sources.length; aCount < aMax; aCount++) {
                var cl_anim = cl_anim_sources[aCount];

                animId = cl_anim["@id"];
                var animName = cl_anim["@name"];

                clib.animations[animId] = {};
                clib.animations[animId].sources = [];

                var cl_sources = cl_anim.source;
                if (cl_sources && !cl_sources.length) cl_sources = [cl_sources];

                if (cl_sources.length) {
                    for (sCount = 0, sMax = cl_sources.length; sCount < sMax; sCount++) {
                        var cl_csource = cl_sources[sCount];

                        sourceId = cl_csource["@id"];


                        var tech_common = cl_csource.technique_common;

                        var name_array = null;
                        var float_array = null;
                        var data = null;

                        if (cl_csource.name_array) {
                            name_array = util.textDelimArray(cl_csource.name_array.$, " ");
                        } else if (cl_csource.Name_array) {
                            name_array = util.textDelimArray(cl_csource.Name_array.$, " ");
                        } else if (cl_csource.float_array) {
                            float_array = util.floatDelimArray(cl_csource.float_array.$, " ");
                        }

                        var acCount = 0;
                        var acSource = "";
                        var acStride = 1;

                        if (tech_common) {
                            tech = tech_common;
                            var acc = tech.accessor;

                            acCount = parseInt(acc["@count"], 10);
                            acSource = acc["@source"].substr(1);
                            var aStride = acc["@stride"];

                            if (aStride) {
                                acStride = parseInt(aStride, 10);
                            }
                        }

                        clib.animations[animId].sources[sourceId] = {
                            data: name_array ? name_array : float_array,
                            count: acCount,
                            source: acSource,
                            stride: acStride
                        };

                        if (acStride !== 1) {
                            clib.animations[animId].sources[sourceId].data = util.repackArray(clib.animations[animId].sources[sourceId].data, acStride, acCount);
                        }
                    }
                }

                cl_samplers = cl_anim.sampler;
                if (cl_samplers && !cl_samplers.length) cl_samplers = [cl_samplers];

                if (cl_samplers) {
                    clib.animations[animId].samplers = [];

                    for (sCount = 0, sMax = cl_samplers.length; sCount < sMax; sCount++) {
                        var cl_sampler = cl_samplers[sCount];

                        var samplerId = cl_sampler["@id"];

                        cl_inputs = cl_sampler.input;

                        if (cl_inputs && !cl_inputs.length) cl_inputs = [cl_inputs];

                        if (cl_inputs) {
                            var inputs = [];

                            for (iCount = 0, iMax = cl_inputs.length; iCount < iMax; iCount++) {
                                cl_input = cl_inputs[iCount];

                                var semanticName = cl_input["@semantic"];

                                inputs[semanticName] = cl_input["@source"].substr(1);
                            }

                            clib.animations[animId].samplers[samplerId] = inputs;
                        }
                    }
                }

                var cl_channels = cl_anim.channel;
                if (cl_channels && !cl_channels.length) cl_channels = [cl_channels];


                if (cl_channels) {
                    clib.animations[animId].channels = [];

                    for (cCount = 0, cMax = cl_channels.length; cCount < cMax; cCount++) {
                        var channel = cl_channels[cCount];

                        var channelSource = channel["@source"].substr(1);
                        var channelTarget = channel["@target"];

                        var channelSplitA = channelTarget.split("/");
                        var channelTargetName = channelSplitA[0];
                        var channelSplitB = channelSplitA[1].split(".");
                        var channelParam = channelSplitB[0];
                        var channelType = channelSplitB[1];

                        clib.animations[animId].channels.push({
                            source: channelSource,
                            target: channelTarget,
                            targetName: channelTargetName,
                            paramName: channelParam,
                            typeName: channelType
                        });
                    }
                }
            }
        }
    }

    var cl_lib_scene = cl_source.scene;

    if (cl_lib_scene) {
        cl_scene = cl_lib_scene.instance_visual_scene;

        if (cl_scene) {
            var sceneUrl = cl_scene["@url"].substr(1);
            clib.scene = sceneUrl;
        }
    }


    return clib;
}


function cubicvr_loadCollada(meshUrl, prefix, deferred_bin) {

    var clib = cubicvr_parseCollada(meshUrl, prefix, deferred_bin);

    var up_axis = clib.up_axis;

    var materialRef = [];

    for (var m = 0, mMax = clib.materials.length; m < mMax; m++) {

        var material = clib.materials[m];
        var newMaterial = new Material(material.mat);

        for (var t = 0, tMax = material.mat.textures_ref.length; t < tMax; t++) {
            var tex = material.mat.textures_ref[t];

            var texObj = null;

            if (Texture_ref[tex.image] === undefined) {
                texObj = new Texture(tex.image, GLCore.default_filter, deferred_bin, meshUrl);
            } else {
                texObj = Textures_obj[Texture_ref[tex.image]];
            }

            newMaterial.setTexture(texObj, tex.type);
        }

        materialRef[material.id] = newMaterial;
    }


    var meshRef = [];

    for (var m = 0, mMax = clib.meshes.length; m < mMax; m++) {

        var meshData = clib.meshes[m];

        var newObj = new Mesh(meshData.id);

        newObj.points = meshData.points;

        for (var mp = 0, mpMax = meshData.parts.length; mp < mpMax; mp++) {
            var part = meshData.parts[mp];

            if (part.material !== 0) {
                newObj.setFaceMaterial(materialRef[part.material]);
            }

            var bNorm = part.normals.length ? true : false;
            var bTex = part.texcoords.length ? true : false;

            for (var p = 0, pMax = part.faces.length; p < pMax; p++) {
                var faceNum = newObj.addFace(part.faces[p]);
                if (bNorm) newObj.faces[faceNum].point_normals = part.normals[p];
                if (bTex) newObj.faces[faceNum].uvs = part.texcoords[p];
            }
        }

        // newObj.calcNormals();
        if (!deferred_bin) {
            newObj.triangulateQuads();
            newObj.compile();
        } else {
            deferred_bin.addMesh(meshUrl, meshUrl + ":" + meshId, newObj);
        }

        meshRef[meshData.id] = newObj;
    }


    var camerasRef = [];

    for (var c = 0, cMax = clib.cameras.length; c < cMax; c++) {
        camerasRef[clib.cameras[c].id] = clib.cameras[c];
    }


    var lightsRef = [];

    for (var l = 0, lMax = clib.lights.length; l < lMax; l++) {
        lightsRef[clib.lights[l].id] = clib.lights[l];
    }



    var sceneObjectMap = {};
    var sceneLightMap = {};
    var sceneCameraMap = {};

    var scenesRef = {};

    for (var s = 0, sMax = clib.scenes.length; s < sMax; s++) {
        var scn = clib.scenes[s];

        var newScene = new CubicVR.Scene();

        for (var so = 0, soMax = scn.sceneObjects.length; so < soMax; so++) {
            var sceneObj = scn.sceneObjects[so];
            var newSceneObject = new SceneObject(sceneObj);
            var srcMesh = (meshRef[sceneObj.meshName]?meshRef[sceneObj.meshName]:meshRef[sceneObj.meshId]) || null;
            newSceneObject.obj = srcMesh;

            sceneObjectMap[sceneObj.id] = newSceneObject;
            newScene.bindSceneObject(newSceneObject);
        }

        for (var l = 0, lMax = scn.lights.length; l < lMax; l++) {
            var lt = scn.lights[l];

            var newLight = new Light(lightsRef[lt.source]);
            newLight.position = lt.position;

            sceneLightMap[lt.id] = newLight;
            newScene.bindLight(newLight);
        }

        if (scn.cameras.length) { // single camera for the moment until we support it
            var cam = scn.cameras[0];
            var newCam = new Camera(camerasRef[cam.source]);
            newCam.position = cam.position;
            newCam.rotation = cam.rotation;

            sceneCameraMap[cam.id] = newCam;
            newScene.camera = newCam;
        }
        for (var p = 0, pMax = scn.parentMap.length; p < pMax; p++) {
            var pmap = scn.parentMap[p];
            sceneObjectMap[pmap.parent].bindChild(sceneObjectMap[pmap.child]);
        }

        scenesRef[scn.id] = newScene;
    }



    for (animId in clib.animations) {
        if (clib.animations.hasOwnProperty(animId)) {
            var anim = clib.animations[animId];

            if (anim.channels.length) {
                for (cCount = 0, cMax = anim.channels.length; cCount < cMax; cCount++) {
                    var chan = anim.channels[cCount];
                    var sampler = anim.samplers[chan.source];
                    var samplerInput = anim.sources[sampler["INPUT"]];
                    var samplerOutput = anim.sources[sampler["OUTPUT"]];
                    var samplerInterp = anim.sources[sampler["INTERPOLATION"]];
                    var samplerInTangent = anim.sources[sampler["IN_TANGENT"]];
                    var samplerOutTangent = anim.sources[sampler["OUT_TANGENT"]];
                    var hasInTangent = (sampler["IN_TANGENT"] !== undef);
                    var hasOutTangent = (sampler["OUT_TANGENT"] !== undef);
                    var mtn = null;

                    var targetSceneObject = sceneObjectMap[chan.targetName];
                    var targetCamera = sceneCameraMap[chan.targetName];
                    var targetLight = sceneLightMap[chan.targetName];

                    if (targetSceneObject) {
                        if (targetSceneObject.motion === null) {
                            targetSceneObject.motion = new Motion();
                        }
                        mtn = targetSceneObject.motion;
                    } else if (targetCamera) {
                        if (targetCamera.motion === null) {
                            targetCamera.motion = new Motion();
                        }

                        mtn = targetCamera.motion;
                    } else if (targetLight) {
                        if (targetLight.motion === null) {
                            targetLight.motion = new Motion();
                        }

                        mtn = targetLight.motion;
                    }
                    // else
                    // {
                    //   console.log("missing",chan.targetName);
                    //   console.log("missing",chan.paramName);
                    // }
                    if (mtn === null) {
                        continue;
                    }

                    var controlTarget = enums.motion.POS;
                    var motionTarget = enums.motion.X;

                    if (up_axis === 2) {
                        mtn.yzflip = true;
                    }

                    var pName = chan.paramName;

                    if (pName === "rotateX" || pName === "rotationX") {
                        controlTarget = enums.motion.ROT;
                        motionTarget = enums.motion.X;
                    } else if (pName === "rotateY" || pName === "rotationY") {
                        controlTarget = enums.motion.ROT;
                        motionTarget = enums.motion.Y;
                    } else if (pName === "rotateZ" || pName === "rotationZ") {
                        controlTarget = enums.motion.ROT;
                        motionTarget = enums.motion.Z;
                    } else if (pName === "location") {
                        controlTarget = enums.motion.POS;
                        if (chan.typeName === "X") {
                            motionTarget = enums.motion.X;
                        }
                        if (chan.typeName === "Y") {
                            motionTarget = enums.motion.Y;
                        }
                        if (chan.typeName === "Z") {
                            motionTarget = enums.motion.Z;
                        }
                    } else if (pName === "translate") {
                        controlTarget = enums.motion.POS;
                        if (chan.typeName === "X") {
                            motionTarget = enums.motion.X;
                        }
                        if (chan.typeName === "Y") {
                            motionTarget = enums.motion.Y;
                        }
                        if (chan.typeName === "Z") {
                            motionTarget = enums.motion.Z;
                        }
                    } else if (pName === "LENS") {
                        // controlTarget = enums.motion.LENS;
                        // motionTarget = 4;
                        controlTarget = 10;
                        motionTarget = 10;
                        continue; // disabled, only here for temporary collada files
                    } else if (pName === "FOV") {
                        controlTarget = enums.motion.FOV;
                        motionTarget = 3; // ensure no axis fixes are applied
                    } else if (pName === "ZNEAR") {
                        controlTarget = enums.motion.NEARCLIP;
                        motionTarget = 3; // ensure no axis fixes are applied
                    } else if (pName === "ZFAR") {
                        controlTarget = enums.motion.FARCLIP;
                        motionTarget = 3; // ensure no axis fixes are applied
                    } else if (pName === "intensity") {
                        controlTarget = enums.motion.INTENSITY;
                        motionTarget = 3; // ensure no axis fixes are applied
                    }

                    if (targetLight && controlTarget < 3) targetLight.method = enums.light.method.DYNAMIC;

                    // if (up_axis === 2 && motionTarget === enums.motion.Z) motionTarget = enums.motion.Y;
                    // else if (up_axis === 2 && motionTarget === enums.motion.Y) motionTarget = enums.motion.Z;
                    // 
                    var ival;
                    for (mCount = 0, mMax = samplerInput.data.length; mCount < mMax; mCount++) { // in the process of being deprecated
                        k = null;

                        if (typeof(samplerOutput.data[mCount]) === 'object') {
                            for (i = 0, iMax = samplerOutput.data[mCount].length; i < iMax; i++) {
                                ival = i;

                                if (up_axis === 2 && i === 2) {
                                    ival = 1;
                                } else if (up_axis === 2 && i === 1) {
                                    ival = 2;
                                }

                                k = mtn.setKey(controlTarget, ival, samplerInput.data[mCount], collada_tools.fixukaxis(clib.up_axis, controlTarget, ival, samplerOutput.data[mCount][i]));

                                if (samplerInterp) {
                                    var pInterp = samplerInterp.data[mCount][i];
                                    if (pInterp === "LINEAR") {
                                        k.shape = enums.envelope.shape.LINE;
                                    } else if (pInterp === "BEZIER") {
                                        if (!(hasInTangent || hasOutTangent)) {
                                            k.shape = enums.envelope.shape.LINEAR;
                                        } else {
                                            k.shape = enums.envelope.shape.BEZI;
                                        }
                                    }
                                }
                            }
                        } else {
                            ival = motionTarget;
                            ofs = 0;

                            if (targetCamera) {
                                if (controlTarget === enums.motion.ROT) {
                                    if (up_axis === 2 && ival === 0) {
                                        ofs = -90;
                                    }
                                }
                            }

                            if (controlTarget === enums.motion.ROT) {
                                k = mtn.setKey(controlTarget, ival, samplerInput.data[mCount], samplerOutput.data[mCount] + ofs);
                            } else {
                                if (up_axis === 2 && motionTarget === 2) {
                                    ival = 1;
                                } else if (up_axis === 2 && motionTarget === 1) {
                                    ival = 2;
                                }

                                k = mtn.setKey(controlTarget, ival, samplerInput.data[mCount], collada_tools.fixukaxis(clib.up_axis, controlTarget, ival, samplerOutput.data[mCount]));
                            }

                            if (samplerInterp) {
                                var pInterp = samplerInterp.data[mCount];
                                if (pInterp === "LINEAR") {
                                    k.shape = enums.envelope.shape.LINE;
                                } else if (pInterp === "BEZIER") {
                                    if (!(hasInTangent || hasOutTangent)) {
                                        k.shape = enums.envelope.shape.LINEAR;
                                        k.continutity = 1.0;
                                    } else {
                                        k.shape = enums.envelope.shape.BEZ2;

                                        var itx = samplerInTangent.data[mCount][0],
                                            ity;
                                        var otx = samplerOutTangent.data[mCount][0],
                                            oty;

                                        if (controlTarget === enums.motion.ROT) {
                                            ity = samplerInTangent.data[mCount][1];
                                            oty = samplerOutTangent.data[mCount][1];

                                            //  k.value = k.value/10;
                                            //  mtn.rscale = 10;
                                            k.param[0] = itx - k.time;
                                            k.param[1] = ity - k.value + ofs;
                                            k.param[2] = otx - k.time;
                                            k.param[3] = oty - k.value + ofs;
                                        } else {
                                            ity = collada_tools.fixukaxis(clib.up_axis, controlTarget, ival, samplerInTangent.data[mCount][1]);
                                            oty = collada_tools.fixukaxis(clib.up_axis, controlTarget, ival, samplerOutTangent.data[mCount][1]);

                                            k.param[0] = itx - k.time;
                                            k.param[1] = ity - k.value;
                                            k.param[2] = otx - k.time;
                                            k.param[3] = oty - k.value;
                                        }

                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }



    var sceneRef = null;

    if (clib.scene) {
        sceneRef = scenesRef[clib.scene];
    } else {
        sceneRef = scenesRef.pop();
    }


    return sceneRef;
}

function GML(srcUrl) {
  this.strokes = [];
  this.bounds = [1, 1, 1];
  this.origin = [0, 0, 0];
  this.upvector = [0, 1, 0];
  this.viewvector = [0, 0, 1];
  this.manual_pos = 0;

  if (srcUrl === undef) {
    return;
  }

  var gml = util.getXML(srcUrl);

  var gml_header = gml.getElementsByTagName("header");

  if (!gml_header.length) {
    return null;
  }

  var header = gml_header[0];

  var gml_environment = gml.getElementsByTagName("environment");


  if (!gml_environment.length) {
    return null;
  }

  this.name = null;

  var gml_name = header.getElementsByTagName("name");

  if (gml_name.length) {
    this.name = util.collectTextNode(gml_name[0]);
  }

  var gml_screenbounds = gml_environment[0].getElementsByTagName("screenBounds");

  if (gml_screenbounds.length) {
    this.bounds = [
      parseFloat(util.collectTextNode(gml_screenbounds[0].getElementsByTagName("x")[0])),
      parseFloat(util.collectTextNode(gml_screenbounds[0].getElementsByTagName("y")[0])),
      parseFloat(util.collectTextNode(gml_screenbounds[0].getElementsByTagName("z")[0]))
      ];
  }

  var gml_origin = gml_environment[0].getElementsByTagName("origin");

  if (gml_origin.length) {
    this.origin = [
      parseFloat(util.collectTextNode(gml_origin[0].getElementsByTagName("x")[0])),
      parseFloat(util.collectTextNode(gml_origin[0].getElementsByTagName("y")[0])),
      parseFloat(util.collectTextNode(gml_origin[0].getElementsByTagName("z")[0]))
      ];
  }

  var gml_upvector = gml_environment[0].getElementsByTagName("up");

  if (gml_upvector.length) {
    this.upvector = [
      parseFloat(util.collectTextNode(gml_upvector[0].getElementsByTagName("x")[0])),
      parseFloat(util.collectTextNode(gml_upvector[0].getElementsByTagName("y")[0])),
      parseFloat(util.collectTextNode(gml_upvector[0].getElementsByTagName("z")[0]))
      ];
  }

  var gml_drawings = gml.getElementsByTagName("drawing");

  var drawings = [];

  for (var dCount = 0, dMax = gml_drawings.length; dCount < dMax; dCount++) {
    var drawing = gml_drawings[dCount];
    var gml_strokes = drawing.getElementsByTagName("stroke");

    var xm = 0,
      ym = 0,
      zm = 0,
      tm = 0;

    for (var sCount = 0, sMax = gml_strokes.length; sCount < sMax; sCount++) {
      var gml_stroke = gml_strokes[sCount];
      var gml_points = gml_stroke.getElementsByTagName("pt");
      var plen = gml_points.length;

      var points = new Array(plen);
      var px, py, pz, pt;
      
      for (var pCount = 0, pMax = plen; pCount < pMax; pCount++) {
        var gml_point = gml_points[pCount];

        px = parseFloat(util.collectTextNode(gml_point.getElementsByTagName("x")[0]));
        py = parseFloat(util.collectTextNode(gml_point.getElementsByTagName("y")[0]));
        pz = parseFloat(util.collectTextNode(gml_point.getElementsByTagName("z")[0]));
        pt = parseFloat(util.collectTextNode(gml_point.getElementsByTagName("time")[0]));

        if (this.upvector[0] === 1) {
          points[pCount] = [(py !== py) ? 0 : py, (px !== px) ? 0 : -px, (pz !== pz) ? 0 : pz, pt];
        } else if (this.upvector[1] === 1) {
          points[pCount] = [(px !== px) ? 0 : px, (py !== py) ? 0 : py, (pz !== pz) ? 0 : pz, pt];
        } else if (this.upvector[2] === 1) {
          points[pCount] = [(px !== px) ? 0 : px, (pz !== pz) ? 0 : -pz, (py !== py) ? 0 : py, pt];
        }

        if (xm < px) {
          xm = px;
        }
        if (ym < py) {
          ym = py;
        }
        if (zm < pz) {
          zm = pz;
        }
        if (tm < pt) {
          tm = pt;
        }
      }

      if (zm > tm) { // fix swapped Z/Time
        for (var i = 0, iMax = points.length; i < iMax; i++) {
          var t = points[i][3];
          points[i][3] = points[i][2];
          points[i][2] = t / this.bounds[2];
        }
      }

      this.strokes[sCount] = points;
    }
  }
}

GML.prototype.addStroke = function(points, tstep) {
  var pts = [];

  if (tstep === undef) {
    tstep = 0.1;
  }

  for (var i = 0, iMax = points.length; i < iMax; i++) {
    var ta = [points[i][0], points[i][1], points[i][2]];
    this.manual_pos += tstep;
    ta.push(this.manual_pos);
    pts.push(ta);
  }

  this.strokes.push(pts);
};


GML.prototype.recenter = function() {
  var min = [0, 0, 0];
  var max = [this.strokes[0][0][0], this.strokes[0][0][1], this.strokes[0][0][2]];

  var i, iMax, s, sMax;

  for (s = 0, sMax = this.strokes.length; s < sMax; s++) {
    for (i = 0, iMax = this.strokes[s].length; i < iMax; i++) {
      if (min[0] > this.strokes[s][i][0]) {
        min[0] = this.strokes[s][i][0];
      }
      if (min[1] > this.strokes[s][i][1]) {
        min[1] = this.strokes[s][i][1];
      }
      if (min[2] > this.strokes[s][i][2]) {
        min[2] = this.strokes[s][i][2];
      }

      if (max[0] < this.strokes[s][i][0]) {
        max[0] = this.strokes[s][i][0];
      }
      if (max[1] < this.strokes[s][i][1]) {
        max[1] = this.strokes[s][i][1];
      }
      if (max[2] < this.strokes[s][i][2]) {
        max[2] = this.strokes[s][i][2];
      }
    }
  }

  var center = vec3.multiply(vec3.subtract(max, min), 0.5);

  for (s = 0, sMax = this.strokes.length; s < sMax; s++) {
    for (i = 0, iMax = this.strokes[s].length; i < iMax; i++) {
      this.strokes[s][i][0] = this.strokes[s][i][0] - center[0];
      this.strokes[s][i][1] = this.strokes[s][i][1] - (this.upvector[1] ? center[1] : (-center[1]));
      this.strokes[s][i][2] = this.strokes[s][i][2] - center[2];
    }
  }
};

GML.prototype.generateObject = function(seg_mod, extrude_depth, pwidth, divsper, do_zmove) {
  if (seg_mod === undef) {
    seg_mod = 0;
  }
  if (extrude_depth === undef) {
    extrude_depth = 0;
  }
  if (do_zmove === undef) {
    do_zmove = false;
  }
  
  

  // temporary defaults
  var divs = 3;
//  var divsper = 0.02;

  if (divsper === undef) divsper = 0.02;
//  var pwidth = 0.015;

  if (pwidth === undef) pwidth = 0.015;

  var extrude = extrude_depth !== 0;

  var segCount = 0;
  var faceSegment = 0;

  var obj = new Mesh(this.name);

  var lx, ly, lz, lt;

  var i, iMax, pCount;

  for (var sCount = 0, sMax = this.strokes.length; sCount < sMax; sCount++) {
    var strokeEnvX = new Envelope();
    var strokeEnvY = new Envelope();
    var strokeEnvZ = new Envelope();

    var pMax = this.strokes[sCount].length;

    var d = 0;
    var len_set = [];
    var time_set = [];
    var start_time = 0;
    var strk = this.strokes[sCount];

    for (pCount = 0; pCount < pMax; pCount++) {
      var pt = strk[pCount];

      var k1 = strokeEnvX.addKey(pt[3], pt[0]);
      var k2 = strokeEnvY.addKey(pt[3], pt[1]);
      var k3;
      
      if (do_zmove) {
        k3 = strokeEnvZ.addKey(pt[3], pt[2]);
      }
      else {
        k3 = strokeEnvZ.addKey(pt[3], 0);
      }

      k1.tension = 0.5;
      k2.tension = 0.5;
      k3.tension = 0.5;

      if (pCount !== 0) {
        var dx = pt[0] - lx;
        var dy = pt[1] - ly;
        var dz = pt[2] - lz;
        var dt = pt[3] - lt;
        var dlen = Math.sqrt(dx * dx + dy * dy + dz * dz);

        d += dlen;

        len_set[pCount-1] = dlen;
        time_set[pCount-1] = dt;
      } else {
        start_time = pt[3];
      }

      lx = pt[0];
      ly = pt[1];
      lz = pt[2];
      lt = pt[3];
    }

    var dpos = start_time;
    var ptofs = obj.points.length;

    for (pCount = 0; pCount < len_set.length; pCount++) {
      var segLen = len_set[pCount];
      var segTime = time_set[pCount];
      var segNum = Math.ceil((segLen / divsper) * divs);

      for (var t = dpos, tMax = dpos + segTime, tInc = (segTime / segNum); t < (tMax - tInc); t += tInc) {
        if (t === dpos) {
          lx = strokeEnvX.evaluate(t);
          ly = strokeEnvY.evaluate(t);
          lz = strokeEnvZ.evaluate(t);
        }

        var px, py, pz;

        px = strokeEnvX.evaluate(t + tInc);
        py = strokeEnvY.evaluate(t + tInc);
        pz = strokeEnvZ.evaluate(t + tInc);

        var pdx = (px - lx),
          pdy = py - ly,
          pdz = pz - lz;
        var pd = Math.sqrt(pdx * pdx + pdy * pdy + pdz * pdz);
        var a;

        a = vec3.multiply(
        vec3.normalize(
        vec3.cross(this.viewvector, vec3.normalize([pdx, pdy, pdz]))), pwidth / 2.0);

        obj.addPoint([lx - a[0], -(ly - a[1]), (lz - a[2]) + (extrude ? (extrude_depth / 2.0) : 0)]);
        obj.addPoint([lx + a[0], -(ly + a[1]), (lz + a[2]) + (extrude ? (extrude_depth / 2.0) : 0)]);

        lx = px;
        ly = py;
        lz = pz;
      }

      dpos += segTime;
    }

    var ptlen = obj.points.length;

    if (extrude) {
      for (i = ptofs, iMax = ptlen; i < iMax; i++) {
        obj.addPoint([obj.points[i][0], obj.points[i][1], obj.points[i][2] - (extrude ? (extrude_depth / 2.0) : 0)]);
      }
    }

    for (i = 0, iMax = ptlen - ptofs; i <= iMax - 4; i += 2) {
      if (segCount % seg_mod === 0) {
        faceSegment++;
      }

      obj.setSegment(faceSegment);

      var arFace = [ptofs + i, ptofs + i + 1, ptofs + i + 3, ptofs + i + 2];
      // var ftest = vec3.dot(this.viewvector, triangle.normal(obj.points[arFace[0]], obj.points[arFace[1]], obj.points[arFace[2]]));

      var faceNum = obj.addFace(arFace);

      // if (ftest < 0) {
      //   this.faces[faceNum].flip();
      // }

      if (extrude) {
        var arFace2 = [arFace[3] + ptlen - ptofs, arFace[2] + ptlen - ptofs, arFace[1] + ptlen - ptofs, arFace[0] + ptlen - ptofs];
        faceNum = obj.addFace(arFace2);

        arFace2 = [ptofs + i, ptofs + i + 2, ptofs + i + 2 + ptlen - ptofs, ptofs + i + ptlen - ptofs];
        faceNum = obj.addFace(arFace2);

        arFace2 = [ptofs + i + 1 + ptlen - ptofs, ptofs + i + 3 + ptlen - ptofs, ptofs + i + 3, ptofs + i + 1];
        faceNum = obj.addFace(arFace2);

        if (i === 0) {
          arFace2 = [ptofs + i + ptlen - ptofs, ptofs + i + 1 + ptlen - ptofs, ptofs + i + 1, ptofs + i];
          faceNum = obj.addFace(arFace2);
        }
        if (i === iMax - 4) {
          arFace2 = [ptofs + i + 2, ptofs + i + 3, ptofs + i + 3 + ptlen - ptofs, ptofs + i + 2 + ptlen - ptofs];
          faceNum = obj.addFace(arFace2);
        }
      }

      segCount++;
    }
  }


  obj.calcFaceNormals();

  obj.triangulateQuads();
  obj.calcNormals();
  obj.compile();

  return obj;
};


/* Particle System */

function Particle(pos, start_time, life_time, velocity, accel) {
  this.startpos = new Float32Array(pos);
  this.pos = new Float32Array(pos);
  this.velocity = new Float32Array((velocity !== undef) ? velocity : [0, 0, 0]);
  this.accel = new Float32Array((accel !== undef) ? accel : [0, 0, 0]);
  this.start_time = (start_time !== undef) ? start_time : 0;
  this.life_time = (life_time !== undef) ? life_time : 0;
  this.color = null;
  this.nextParticle = null;
}


function ParticleSystem(maxPts, hasColor, pTex, vWidth, vHeight, alpha, alphaCut) {
  var gl = GLCore.gl;

  if (!maxPts) {
    return;
  }

  this.particles = null;
  this.last_particle = null;
  this.pTex = (pTex !== undef) ? pTex : null;
  this.vWidth = vWidth;
  this.vHeight = vHeight;
  this.alpha = (alpha !== undef) ? alpha : false;
  this.alphaCut = (alphaCut !== undef) ? alphaCut : 0;

  this.pfunc = function(p, time) {
    var tdelta = time - p.start_time;

    if (tdelta < 0) {
      return 0;
    }
    if (tdelta > p.life_time && p.life_time) {
      return -1;
    }

    p.pos[0] = p.startpos[0] + (tdelta * p.velocity[0]) + (tdelta * tdelta * p.accel[0]);
    p.pos[1] = p.startpos[1] + (tdelta * p.velocity[1]) + (tdelta * tdelta * p.accel[1]);
    p.pos[2] = p.startpos[2] + (tdelta * p.velocity[2]) + (tdelta * tdelta * p.accel[2]);

    if (this.pgov !== null) {
      this.pgov(p, time);
    }

    return 1;
  };

  this.pgov = null;

  if (hasColor === undef) {
    this.hasColor = false;
  } else {
    this.hasColor = hasColor;
  }

  //    gl.enable(gl.VERTEX_PROGRAM_POINT_SIZE);
  var hasTex = (this.pTex !== null);

  this.vs = [
    "#ifdef GL_ES",
    "precision highp float;",
    "#endif",
    "attribute vec3 aVertexPosition;",
    this.hasColor ? "attribute vec3 aColor;" : "",
    "uniform mat4 uMVMatrix;",
    "uniform mat4 uPMatrix;",
    "varying vec4 color;",
    "varying vec2 screenPos;",
    hasTex ? "varying float pSize;" : "",
    "void main(void) {",
      "vec4 position = uPMatrix * uMVMatrix * vec4(aVertexPosition,1.0);",
      hasTex ? "screenPos=vec2(position.x/position.w,position.y/position.w);" : "",
      "gl_Position = position;",
      this.hasColor ? "color = vec4(aColor.r,aColor.g,aColor.b,1.0);" : "color = vec4(1.0,1.0,1.0,1.0);",
      hasTex ? "pSize=200.0/position.z;" : "float pSize=200.0/position.z;",
      "gl_PointSize = pSize;",
    "}"].join("\n");

  this.fs = [
    "#ifdef GL_ES",
    "precision highp float;",
    "#endif",

    hasTex ? "uniform sampler2D pMap;" : "",


    "varying vec4 color;",
    hasTex ? "varying vec2 screenPos;" : "",
    hasTex ? "uniform vec3 screenDim;" : "",
    hasTex ? "varying float pSize;" : "",

    "void main(void) {",
      "vec4 c = color;",
      hasTex ? "vec2 screen=vec2((gl_FragCoord.x/screenDim.x-0.5)*2.0,(gl_FragCoord.y/screenDim.y-0.5)*2.0);" : "",
      hasTex ? "vec2 pointCoord=vec2( ((screen.x-screenPos.x)/(pSize/screenDim.x))/2.0+0.5,((screen.y-screenPos.y)/(pSize/screenDim.y))/2.0+0.5);" : "",
      hasTex ? "vec4 tc = texture2D(pMap,pointCoord); gl_FragColor = vec4(c.rgb*tc.rgb,1.0);" : "gl_FragColor = c;",
    "}"].join("\n");

  this.maxPoints = maxPts;
  this.numParticles = 0;
  this.arPoints = new Float32Array(maxPts * 3);
  this.glPoints = null;

  if (hasColor) {
    this.arColor = new Float32Array(maxPts * 3);
    this.glColor = null;
  }

  this.shader_particle = new Shader(this.vs, this.fs);
  this.shader_particle.use();
  this.shader_particle.addVertexArray("aVertexPosition");

  if (this.hasColor) {
    this.shader_particle.addVertexArray("aColor");
  }

  this.shader_particle.addMatrix("uMVMatrix");
  this.shader_particle.addMatrix("uPMatrix");

  if (this.pTex !== null) {
    this.shader_particle.addInt("pMap", 0);
    this.shader_particle.addVector("screenDim");
    this.shader_particle.setVector("screenDim", [vWidth, vHeight, 0]);
  }

  this.genBuffer();
}


ParticleSystem.prototype.resizeView = function(vWidth, vHeight) {
  this.vWidth = vWidth;
  this.vHeight = vHeight;

  if (this.pTex !== null) {
    this.shader_particle.addVector("screenDim");
    this.shader_particle.setVector("screenDim", [vWidth, vHeight, 0]);
  }
};


ParticleSystem.prototype.addParticle = function(p) {
  if (this.last_particle === null) {
    this.particles = p;
    this.last_particle = p;
  } else {
    this.last_particle.nextParticle = p;
    this.last_particle = p;
  }
};

ParticleSystem.prototype.genBuffer = function() {
  var gl = GLCore.gl;

  this.glPoints = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, this.glPoints);
  gl.bufferData(gl.ARRAY_BUFFER, this.arPoints, gl.DYNAMIC_DRAW);

  if (this.hasColor) {
    this.glColor = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.glColor);
    gl.bufferData(gl.ARRAY_BUFFER, this.arColor, gl.DYNAMIC_DRAW);
  }
};

ParticleSystem.prototype.updatePoints = function() {
  var gl = GLCore.gl;

  // buffer update
  gl.bindBuffer(gl.ARRAY_BUFFER, this.glPoints);
  gl.bufferData(gl.ARRAY_BUFFER, this.arPoints, gl.DYNAMIC_DRAW);
  // end buffer update
};

ParticleSystem.prototype.updateColors = function() {
  var gl = GLCore.gl;

  if (!this.hasColor) {
    return;
  }
  // buffer update
  gl.bindBuffer(gl.ARRAY_BUFFER, this.glColor);
  gl.bufferData(gl.ARRAY_BUFFER, this.arColor, gl.DYNAMIC_DRAW);
  // end buffer update
};

ParticleSystem.prototype.draw = function(modelViewMat, projectionMat, time) {
  var gl = GLCore.gl;

  this.shader_particle.use();

  if (this.pTex !== null) {
    this.pTex.use(gl.TEXTURE0);
  }

  this.shader_particle.setMatrix("uMVMatrix", modelViewMat);
  this.shader_particle.setMatrix("uPMatrix", projectionMat);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  gl.bindBuffer(gl.ARRAY_BUFFER, this.glPoints);
  gl.vertexAttribPointer(this.shader_particle.uniforms["aVertexPosition"], 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(this.shader_particle.uniforms["aVertexPosition"]);

  if (this.hasColor) {
    gl.bindBuffer(gl.ARRAY_BUFFER, this.glColor);
    gl.vertexAttribPointer(this.shader_particle.uniforms["aColor"], 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.shader_particle.uniforms["aColor"]);
  }

  if (time === undef) {
    time = 0;
  }

  if (this.particles === null) {
    gl.disable(gl.BLEND);
    return;
  }

  var p = this.particles;
  var lp = null;


  this.numParticles = 0;

  var c = 0;

  while (p !== null) {
    var ofs = this.numParticles * 3;
    var pf = this.pfunc(p, time);

    if (pf === 1) {
      this.arPoints[ofs] = p.pos[0];
      this.arPoints[ofs + 1] = p.pos[1];
      this.arPoints[ofs + 2] = p.pos[2];

      if (p.color !== null && this.arColor !== undef) {
        this.arColor[ofs] = p.color[0];
        this.arColor[ofs + 1] = p.color[1];
        this.arColor[ofs + 2] = p.color[2];
      }

      this.numParticles++;
      c++;
      if (this.numParticles === this.maxPoints) {
        break;
      }
    } else if (pf === -1) // particle death
    {
      if (lp !== null) {
        lp.nextParticle = p.nextParticle;
      }
    }
    else if (pf === 0) {
      c++;
    }

    lp = p;
    p = p.nextParticle;
  }

  if (!c) {
    this.particles = null;
    this.last_particle = null;
  }

  this.updatePoints();
  if (this.hasColor) {
    this.updateColors();
  }

  if (this.alpha) {
    gl.enable(gl.BLEND);
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(0);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
  }

  gl.drawArrays(gl.POINTS, 0, this.numParticles);

  if (this.alpha) {
    // gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.depthMask(1);
    gl.blendFunc(gl.ONE, gl.ONE);
  }
  
  if (this.hasColor) {
    gl.disableVertexAttribArray(this.shader_particle.uniforms["aColor"]);
  }
};

/* SkyBox */

function SkyBox(in_obj) {
  var texture = in_obj.texture;
  var mapping = in_obj.mapping;

  var that = this;

  this.mapping = null;
  this.ready = false;
  this.texture = null;

  this.onready = function() {
    texture.onready = null;
    var tw = 1/Images[that.texture.tex_id].width;
    var th = 1/Images[that.texture.tex_id].height;
    if (that.mapping === null) {
      that.mapping = [[1/3, 0.5, 2/3-tw, 1],//top
                      [0, 0.5, 1/3, 1],        //bottom
                      [0, 0, 1/3-tw, 0.5],  //left
                      [2/3, 0, 1, 0.5],        //right
                      [2/3+tw, 0.5, 1, 1],  //front
                      [1/3, 0, 2/3, 0.5]];     //back
    } //if

    var mat = new Material("skybox");
    var obj = new Mesh();
    obj.sky_mapping = that.mapping;
    cubicvr_boxObject(obj, 1, mat);
    obj.calcNormals();
    var mat_map = new UVMapper();
    mat_map.projection_mode = enums.uv.projection.SKY;
    mat_map.scale = [1, 1, 1];
    mat_map.apply(obj, mat);
    obj.triangulateQuads();
    obj.compile();
    mat.setTexture(texture);
    that.scene_object = new SceneObject(obj);

    that.ready = true;
  } //onready

  if (texture) {
    if (typeof(texture) === "string") {
      texture = new Texture(texture, null, null, null, this.onready);
    }
    else if (!texture.loaded){
      texture.onready = this.onready;
    } //if
    this.texture = texture;

    if (mapping) {
      this.mapping = mapping;
      this.onready();
    } //if
  } //if
} //cubicvr_SkyBox::Constructor




function View(obj_init) {
  
  this.texture = obj_init.texture?obj_init.texture:null;
  this.width = obj_init.width?obj_init.width:128;
  this.height = obj_init.height?obj_init.height:128;
  this.x = obj_init.x?obj_init.x:0;
  this.y = obj_init.y?obj_init.y:0;
  this.blend = obj_init.blend?obj_init.blend:false;
  this.opacity = (typeof(obj_init.opacity)!=='undefined')?obj_init.opacity:1.0;
  this.tint = obj_init.tint?obj_init.tint:[1.0,1.0,1.0];
  
  this.type='view';
  
  this.superView = null;
  this.childViews = [];
  this.panel = null;
}

View.prototype.addSubview = function(view) {
  this.childViews.push(view);
//  this.superView.makePanel(view);
  view.superView = this;
}

View.prototype.makePanel = function(view) {
  return this.superView.makePanel(view);
}

function Layout(obj_init) {
  
  this.texture = obj_init.texture?obj_init.texture:null;
  this.width = obj_init.width?obj_init.width:128;
  this.height = obj_init.height?obj_init.height:128;
  this.x = obj_init.x?obj_init.x:0;
  this.y = obj_init.y?obj_init.y:0;
  this.blend = obj_init.blend?obj_init.blend:false;
  this.opacity = (typeof(obj_init.opacity)!=='undefined')?obj_init.opacity:1.0;
  this.tint = obj_init.tint?obj_init.tint:[1.0,1.0,1.0];

  this.type = 'root';

  this.superView = null;
  this.childViews = [];
  this.setupShader();

  this.panel = null;
  this.makePanel(this);
}

Layout.prototype.setupShader = function() {
  
  this.shader = new CubicVR.PostProcessShader({
    shader_vertex: ["attribute vec3 aVertex;",
                "attribute vec2 aTex;",
                "varying vec2 vTex;",
                "uniform vec3 screen;",
                "uniform vec3 position;",
                "uniform vec3 size;",
                "void main(void) {",
                  "vTex = aTex;",
                  "vec4 vPos = vec4(aVertex.xyz,1.0);",
                  "vPos.x *= size.x/screen.x;",
                  "vPos.y *= size.y/screen.y;",
                  "vPos.x += (size.x/screen.x);",
                  "vPos.y -= (size.y/screen.y);",
                  "vPos.x += (position.x/screen.x)*2.0 - 1.0;",
                  "vPos.y -= (position.y/screen.y)*2.0 - 1.0;",
                  "gl_Position = vPos;",
                "}"].join("\n"),
    shader_fragment: [
      "#ifdef GL_ES",
      "precision highp float;",
      "#endif",
      "uniform sampler2D srcTex;",
      "uniform vec3 tint;",
      "varying vec2 vTex;",
      "void main(void) {",
      "vec4 color = texture2D(srcTex, vTex)*vec4(tint,1.0);",
      // "if (color.a == 0.0) discard;",
        "gl_FragColor = color;",
      "}"].join("\n"),
      init: function(shader)
      {
        shader.setInt("srcTex",0);
        shader.addVector("screen");
        shader.addVector("position");
        shader.addVector("tint");
        shader.addVector("size");
      }
  });
}

Layout.prototype.addSubview = function(view) {
  this.childViews.push(view);
//  this.makePanel(view);
  view.superView = this;
}

Layout.prototype.makePanel = function(view) {
  var gl = CubicVR.GLCore.gl;
  var pQuad = {}; // intentional empty object

  pQuad.vbo_points = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0]);
  pQuad.vbo_uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1]);

  pQuad.gl_points = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pQuad.gl_points);
  gl.bufferData(gl.ARRAY_BUFFER, pQuad.vbo_points, gl.STATIC_DRAW);

  pQuad.gl_uvs = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pQuad.gl_uvs);
  gl.bufferData(gl.ARRAY_BUFFER, pQuad.vbo_uvs, gl.STATIC_DRAW);

  view.panel = pQuad;
}


Layout.prototype.renderPanel = function(view,panel) {
  var gl = CubicVR.GLCore.gl;

  if (!view.texture) {
    return false;
  }

  view.texture.use(gl.TEXTURE0);
};


Layout.prototype.renderView = function(view) {
  if (!view.texture) return;

  var gl = CubicVR.GLCore.gl;

  var offsetLeft = view.offsetLeft;
  var offsetTop = view.offsetTop;
  
  if (!offsetLeft) offsetLeft = 0;
  if (!offsetTop) offsetTop = 0;
  
  var shader = this.shader.shader;

  shader.use();
  shader.setVector("screen",[this.width,this.height,0]);
  shader.setVector("position",[view.x+offsetLeft,view.y+offsetTop,0]);
  shader.setVector("size",[view.width,view.height,0]);
  shader.setVector("tint",view.tint);

  if (view.blend) {
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
  }
  
  view.texture.use(gl.TEXTURE0);
  
//  this.renderPanel(view,this.panel);        
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  if (view.blend) {
    gl.disable(gl.BLEND);
    gl.blendFunc(gl.ONE,gl.ZERO);
  }
}



Layout.prototype.render = function() {
  var gl = CubicVR.GLCore.gl;
  
  gl.disable(gl.DEPTH_TEST);
  
  if (this.texture) this.renderView(this);
  
  var stack = [];
  var framestack = [];

  this.offsetLeft = 0, this.offsetTop = 0;
  stack.push(this);


  shader = this.shader.shader;
  shader.use();

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, this.panel.gl_points);
  gl.vertexAttribPointer(shader.uniforms["aVertex"], 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(shader.uniforms["aVertex"]);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, this.panel.gl_uvs);
  gl.vertexAttribPointer(shader.uniforms["aTex"], 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(shader.uniforms["aTex"]);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  
  while (stack.length) {
    var view = stack.pop();

    this.renderView(view);
    
    if (view.childViews.length) {
      for (var i = view.childViews.length-1, iMin = 0; i >= iMin; i--) {
      view.childViews[i].offsetLeft = view.x+view.offsetLeft;
      view.childViews[i].offsetTop = view.y+view.offsetTop;
      stack.push(view.childViews[i]);
      }
    }
    
  }


  gl.disableVertexAttribArray(shader.uniforms["aTex"]);

  gl.enable(gl.DEPTH_TEST); 
}


// Full-screen quad related
var fsQuad = {
  make:makeFSQuad,
  destroy:destroyFSQuad,
  render:renderFSQuad
};



// Extend CubicVR module by adding public methods and classes
var extend = {
  GLCore: GLCore,
  init: GLCore.init,
  addResizeable: GLCore.addResizeable,
  setFixedAspect: GLCore.setFixedAspect,
  setFixedSize: GLCore.setFixedSize,
  getCanvas: GLCore.getCanvas,
  enums: enums,
  vec2: vec2,
  vec3: vec3,
  mat4: mat4,
  util: util,
  fsQuad: fsQuad,
  IdentityMatrix: cubicvr_identity,
  Timer: Timer,
  MainLoop: MainLoop,
  MouseViewController: MouseViewController,
  setMainLoop: setMainLoop,
  Transform: Transform,
  Light: Light,
  Texture: Texture,
  PJSTexture: PJSTexture,
  CanvasTexture: CanvasTexture,
  TextTexture: TextTexture,
  UVMapper: UVMapper,
  Scene: Scene,
  SceneObject: SceneObject,
  Face: Face,
  Material: Material,
  Materials: Materials,
  Textures: Textures,
  Textures_obj: Textures_obj,
  Images: Images,
  Shader: Shader,
  Landscape: Landscape,
  Camera: Camera,
  GML: GML,
  SkyBox: SkyBox,
  Envelope: Envelope,
  Motion: Motion,
  RenderBuffer: RenderBuffer,
  PostProcessFX: PostProcessFX,
  PostProcessChain: PostProcessChain,
  PostProcessShader: PostProcessShader,
  NormalMapGen: NormalMapGen,
  Particle: Particle,
  ParticleSystem: ParticleSystem,
  Octree: Octree,
  OctreeWorker: OctreeWorkerProxy,
  Quaternion: Quaternion,
  AutoCamera: AutoCamera,
  Mesh: Mesh,
  MeshPool: MeshPool,
  genPlaneObject: cubicvr_planeObject,
  genBoxObject: cubicvr_boxObject,
  genLatheObject: cubicvr_latheObject,
  genTorusObject: cubicvr_torusObject,
  genConeObject: cubicvr_coneObject,
  genCylinderObject: cubicvr_cylinderObject,
  genSphereObject: cubicvr_sphereObject,
  primitives: primitives,
  renderObject: cubicvr_renderObject,
  globalAmbient: [0.1, 0.1, 0.1],
  setGlobalAmbient: function(c) {
    CubicVR.globalAmbient = c;
  },
  loadMesh: cubicvr_loadMesh,
  DeferredBin: DeferredBin,
  DeferredLoadTexture: DeferredLoadTexture,
  loadCollada: cubicvr_loadCollada,
  loadColladaWorker: cubicvr_loadColladaWorker,
  setGlobalDepthAlpha: GLCore.setDepthAlpha,
  setDefaultFilter: GLCore.setDefaultFilter,
  setSoftShadows: GLCore.setSoftShadows,
  Worker: CubicVR_Worker,
  Layout: Layout,
  View: View
};

for (var ext in extend) {
  if (extend.hasOwnProperty(ext)) {
    this.CubicVR[ext] = extend[ext];
  }
}

Materials.push(new Material("(null)"));

}(window, window.document, Math, function(){console.log('nop!');}));

</script>
		<script type="text/javascript">
/* 
 *  DSP.js - a comprehensive digital signal processing  library for javascript
 * 
 *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.
 *  Copyright 2010 Corban Brook. All rights reserved.
 *
 */

////////////////////////////////////////////////////////////////////////////////
//                                  CONSTANTS                                 //
////////////////////////////////////////////////////////////////////////////////

/**
 * DSP is an object which contains general purpose utility functions and constants
 */
var DSP = {
  // Channels
  LEFT:           0,
  RIGHT:          1,
  MIX:            2,

  // Waveforms
  SINE:           1,
  TRIANGLE:       2,
  SAW:            3,
  SQUARE:         4,

  // Filters
  LOWPASS:        0,
  HIGHPASS:       1,
  BANDPASS:       2,
  NOTCH:          3,

  // Window functions
  BARTLETT:       1,
  BARTLETTHANN:   2,
  BLACKMAN:       3,
  COSINE:         4,
  GAUSS:          5,
  HAMMING:        6,
  HANN:           7,
  LANCZOS:        8,
  RECTANGULAR:    9,
  TRIANGULAR:     10,

  // Loop modes
  OFF:            0,
  FW:             1,
  BW:             2,
  FWBW:           3,

  // Math
  TWO_PI:         2*Math.PI
};

// Setup arrays for platforms which do not support byte arrays
function setupTypedArray(name, fallback) {
  // check if TypedArray exists
  // typeof on Minefield and Chrome return function, typeof on Webkit returns object.
  if (typeof this[name] !== "function" && typeof this[name] !== "object") {
    // nope.. check if WebGLArray exists
    if (typeof this[fallback] === "function" && typeof this[fallback] !== "object") {
      this[name] = this[fallback];
    } else {
      // nope.. set as Native JS array
      this[name] = function(obj) {
        if (obj instanceof Array) {
          return obj;
        } else if (typeof obj === "number") {
          return new Array(obj);
        }
      };
    }
  }
}

setupTypedArray("Float32Array", "WebGLFloatArray");
setupTypedArray("Int32Array",   "WebGLIntArray");
setupTypedArray("Uint16Array",  "WebGLUnsignedShortArray");
setupTypedArray("Uint8Array",   "WebGLUnsignedByteArray");


////////////////////////////////////////////////////////////////////////////////
//                            DSP UTILITY FUNCTIONS                           //
////////////////////////////////////////////////////////////////////////////////

/**
 * Inverts the phase of a signal
 *
 * @param {Array} buffer A sample buffer
 *
 * @returns The inverted sample buffer
 */
DSP.invert = function(buffer) {
  for (var i = 0, len = buffer.length; i < len; i++) {
    buffer[i] *= -1;
  }

  return buffer;
};

/**
 * Converts split-stereo (dual mono) sample buffers into a stereo interleaved sample buffer
 *
 * @param {Array} left  A sample buffer
 * @param {Array} right A sample buffer
 *
 * @returns The stereo interleaved buffer
 */
DSP.interleave = function(left, right) {
  if (left.length !== right.length) {
    throw "Can not interleave. Channel lengths differ.";
  }
 
  var stereoInterleaved = new Float32Array(left.length * 2);
 
  for (var i = 0, len = left.length; i < len; i++) {
    stereoInterleaved[2*i]   = left[i];
    stereoInterleaved[2*i+1] = right[i];
  }
 
  return stereoInterleaved;
};

/**
 * Converts a stereo-interleaved sample buffer into split-stereo (dual mono) sample buffers
 *
 * @param {Array} buffer A stereo-interleaved sample buffer
 *
 * @returns an Array containing left and right channels
 */
DSP.deinterleave = (function() {
  var left, right, mix; 

  return function(buffer) { 
    left  = left  || new Float32Array(buffer.length/2);
    right = right || new Float32Array(buffer.length/2);
    mix   = mix   || new Float32Array(buffer.length/2);

    if (buffer.length/2 !== left.length) {
      left  = new Float32Array(buffer.length/2);
      right = new Float32Array(buffer.length/2);
      mix   = new Float32Array(buffer.length/2);
    }

    for (var i = 0, len = buffer.length/2; i < len; i++) {
      left[i]  = buffer[2*i];
      right[i] = buffer[2*i+1];
      mix[i]   = (left[i] + right[i]) / 2;
      //mix[i] = (buffer[2*i] + buffer[2*i+1]) /2;
    }
   
    return [left, right, mix];
  };
}());

/**
 * Separates a channel from a stereo-interleaved sample buffer
 *
 * @param {Array}  buffer A stereo-interleaved sample buffer
 * @param {Number} channel A channel constant (LEFT, RIGHT, MIX)
 *
 * @returns an Array containing a signal mono sample buffer
 */
DSP.getChannel = function(channel, buffer) {
  return DSP.deinterleave(buffer)[channel];
};

/**
 * Helper method (for Reverb) to mix two (interleaved) samplebuffers. It's possible
 * to negate the second buffer while mixing and to perform a volume correction
 * on the final signal.
 *
 * @param {Array} sampleBuffer1 Array containing Float values or a Float32Array
 * @param {Array} sampleBuffer2 Array containing Float values or a Float32Array
 * @param {Boolean} negate When true inverts/flips the audio signal
 * @param {Number} volumeCorrection When you add multiple sample buffers, use this to tame your signal ;)
 *
 * @returns A new Float32Array interleaved buffer.
 */
DSP.mixSampleBuffers = function(sampleBuffer1, sampleBuffer2, negate, volumeCorrection){
  var outputSamples = new Float32Array(sampleBuffer1);

  for(var i = 0; i<sampleBuffer1.length; i++){
    outputSamples[i] += (negate ? -sampleBuffer2[i] : sampleBuffer2[i]) / volumeCorrection;
  }
 
  return outputSamples;
}; 

// Biquad filter types
DSP.LPF = 0;                // H(s) = 1 / (s^2 + s/Q + 1)
DSP.HPF = 1;                // H(s) = s^2 / (s^2 + s/Q + 1)
DSP.BPF_CONSTANT_SKIRT = 2; // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
DSP.BPF_CONSTANT_PEAK = 3;  // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
DSP.NOTCH = 4;              // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
DSP.APF = 5;                // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
DSP.PEAKING_EQ = 6;         // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
DSP.LOW_SHELF = 7;          // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
DSP.HIGH_SHELF = 8;         // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)

// Biquad filter parameter types
DSP.Q = 1;
DSP.BW = 2; // SHARED with BACKWARDS LOOP MODE
DSP.S = 3;

// Find RMS of signal
DSP.RMS = function(buffer) {
  var total = 0;
  
  for (var i = 0, n = buffer.length; i < n; i++) {
    total += buffer[i] * buffer[i];
  }
  
  return Math.sqrt(total / n);
};

// Find Peak of signal
DSP.Peak = function(buffer) {
  var peak = 0;
  
  for (var i = 0, n = buffer.length; i < n; i++) {
    peak = (Math.abs(buffer[i]) > peak) ? Math.abs(buffer[i]) : peak; 
  }
  
  return peak;
};

// Fourier Transform Module used by DFT, FFT, RFT
function FourierTransform(bufferSize, sampleRate) {
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.bandwidth  = 2 / bufferSize * sampleRate / 2;

  this.spectrum   = new Float32Array(bufferSize/2);
  this.real       = new Float32Array(bufferSize);
  this.imag       = new Float32Array(bufferSize);

  this.peakBand   = 0;
  this.peak       = 0;

  /**
   * Calculates the *middle* frequency of an FFT band.
   *
   * @param {Number} index The index of the FFT band.
   *
   * @returns The middle frequency in Hz.
   */
  this.getBandFrequency = function(index) {
    return this.bandwidth * index + this.bandwidth / 2;
  };

  this.calculateSpectrum = function() {
    var spectrum  = this.spectrum,
        real      = this.real,
        imag      = this.imag,
        bSi       = 2 / this.bufferSize,
        sqrt      = Math.sqrt,
        rval, 
        ival,
        mag;

    for (var i = 0, N = bufferSize/2; i < N; i++) {
      rval = real[i];
      ival = imag[i];
      mag = bSi * sqrt(rval * rval + ival * ival);

      if (mag > this.peak) {
        this.peakBand = i;
        this.peak = mag;
      }

      spectrum[i] = mag;
    }
  };
}

/**
 * DFT is a class for calculating the Discrete Fourier Transform of a signal.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function DFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  var N = bufferSize/2 * bufferSize;
  var TWO_PI = 2 * Math.PI;

  this.sinTable = new Float32Array(N);
  this.cosTable = new Float32Array(N);

  for (var i = 0; i < N; i++) {
    this.sinTable[i] = Math.sin(i * TWO_PI / bufferSize);
    this.cosTable[i] = Math.cos(i * TWO_PI / bufferSize);
  }
}

/**
 * Performs a forward tranform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer
 *
 * @returns The frequency spectrum array
 */
DFT.prototype.forward = function(buffer) {
  var real = this.real, 
      imag = this.imag,
      rval,
      ival;

  for (var k = 0; k < this.bufferSize/2; k++) {
    rval = 0.0;
    ival = 0.0;

    for (var n = 0; n < buffer.length; n++) {
      rval += this.cosTable[k*n] * buffer[n];
      ival += this.sinTable[k*n] * buffer[n];
    }

    real[k] = rval;
    imag[k] = ival;
  }

  return this.calculateSpectrum();
};


/**
 * FFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function FFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);
   
  this.reverseTable     = new Uint32Array(bufferSize);

  var limit = 1;
  var bit = bufferSize >> 1;

  var i;

  while (limit < bufferSize) {
    for (i = 0; i < limit; i++) {
      this.reverseTable[i + limit] = this.reverseTable[i] + bit;
    }

    limit = limit << 1;
    bit = bit >> 1;
  }

  this.sinTable = new Float32Array(bufferSize);
  this.cosTable = new Float32Array(bufferSize);

  for (i = 0; i < bufferSize; i++) {
    this.sinTable[i] = Math.sin(-Math.PI/i);
    this.cosTable[i] = Math.cos(-Math.PI/i);
  }
}

/**
 * Performs a forward tranform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer. Buffer Length must be power of 2
 *
 * @returns The frequency spectrum array
 */
FFT.prototype.forward = function(buffer) {
  // Locally scope variables for speed up
  var bufferSize      = this.bufferSize,
      cosTable        = this.cosTable,
      sinTable        = this.sinTable,
      reverseTable    = this.reverseTable,
      real            = this.real,
      imag            = this.imag,
      spectrum        = this.spectrum;

  var k = Math.floor(Math.log(bufferSize) / Math.LN2);
  if (Math.pow(2, k) !== bufferSize) { throw "Invalid buffer size, must be a power of 2."; }
  if (bufferSize !== buffer.length) { throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length; }

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    real[i] = buffer[reverseTable[i]];
    imag[i] = 0;
  }

  while (halfSize < bufferSize) {
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];
    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }

    halfSize = halfSize << 1;
  }

  return this.calculateSpectrum();
};

FFT.prototype.inverse = function(real, imag) {
  // Locally scope variables for speed up
  var bufferSize      = this.bufferSize,
      cosTable        = this.cosTable,
      sinTable        = this.sinTable,
      reverseTable    = this.reverseTable,
      spectrum        = this.spectrum;
     
      real = real || this.real;
      imag = imag || this.imag;

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    imag[i] *= -1;
  }

  var revReal = new Float32Array(bufferSize);
  var revImag = new Float32Array(bufferSize);
 
  for (i = 0; i < real.length; i++) {
    revReal[i] = real[reverseTable[i]];
    revImag[i] = imag[reverseTable[i]];
  }
 
  real = revReal;
  imag = revImag;

  while (halfSize < bufferSize) {
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];
    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }

    halfSize = halfSize << 1;
  }

  var buffer = new Float32Array(bufferSize); // this should be reused instead
  for (i = 0; i < bufferSize; i++) {
    buffer[i] = real[i] / bufferSize;
  }

  return buffer;
};

/**
 * RFFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * This method currently only contains a forward transform but is highly optimized.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */

// lookup tables don't really gain us any speed, but they do increase
// cache footprint, so don't use them in here

// also we don't use sepearate arrays for real/imaginary parts

// this one a little more than twice as fast as the one in FFT
// however I only did the forward transform

// the rest of this was translated from C, see http://www.jjj.de/fxt/
// this is the real split radix FFT

function RFFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.trans = new Float32Array(bufferSize);

  // don't use a lookup table to do the permute, use this instead
  this.reverseBinPermute = function (d, s) {
    var nh = d.length >>> 1, nm1 = d.length - 1, x = 1, r = 0, h;

    d[0] = s[0];

    do {
      r = r + nh;
      //swap(a[x], a[r]);
      d[x] = s[r];
      d[r] = s[x];

      x++;
   
      h = nh;

      while (!((r ^= h) & h)) { 
        h = h >> 1;
      } 
      
      if (r >= x) { //swap(a[x], a[r]);
        d[x] = s[r]; 
        d[r] = s[x];
        d[nm1-x] = s[nm1-r]; 
        d[nm1-r] = s[nm1-x];
      }
      x++;
    } while (x < nh);
    d[nm1] = s[nm1];
  };
}


// Ordering of output:
//
// trans[0]     = re[0] (==zero frequency, purely real)
// trans[1]     = re[1]
//             ...
// trans[n/2-1] = re[n/2-1]
// trans[n/2]   = re[n/2]    (==nyquist frequency, purely real)
//
// trans[n/2+1] = im[n/2-1]
// trans[n/2+2] = im[n/2-2]
//             ...
// trans[n-1]   = im[1] 

RFFT.prototype.forward = function(buffer) {
  var n         = this.bufferSize, 
      spectrum  = this.spectrum,
      x         = this.trans, 
      TWO_PI    = 2*Math.PI,
      sqrt      = Math.sqrt,
      i         = n >>> 1,
      bSi       = 2 / n,
      n2, n4, n8, nn, 
      t1, t2, t3, t4, 
      i1, i2, i3, i4, i5, i6, i7, i8, 
      st1, cc1, ss1, cc3, ss3,
      e, 
      a,
      rval, ival, mag; 

  this.reverseBinPermute(x, buffer);

  for (var ix = 0, id = 4; ix < n; id *= 4) {
    for (var i0 = ix; i0 < n; i0 += id) {
      //sumdiff(x[i0], x[i0+1]); // {a, b}  <--| {a+b, a-b}
      st1 = x[i0] - x[i0+1];
      x[i0] += x[i0+1];
      x[i0+1] = st1;
    } 
    ix = 2*(id-1);
  }

  n2 = 2;
  nn = n >>> 1;

  while((nn = nn >>> 1)) {
    ix = 0;
    n2 = n2 << 1;
    id = n2 << 1;
    n4 = n2 >>> 2;
    n8 = n2 >>> 3;
    do {
      if(n4 !== 1) {
        for(i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;
     
          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4];
          x[i4] -= x[i3];
          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1; 
          x[i1] += t1;
     
          i1 += n8;
          i2 += n8;
          i3 += n8;
          i4 += n8;
         
          //sumdiff(x[i3], x[i4], t1, t2); // {s, d}  <--| {a+b, a-b}
          t1 = x[i3] + x[i4];
          t2 = x[i3] - x[i4];
         
          t1 = -t1 * Math.SQRT1_2;
          t2 *= Math.SQRT1_2;
     
          // sumdiff(t1, x[i2], x[i4], x[i3]); // {s, d}  <--| {a+b, a-b}
          st1 = x[i2];
          x[i4] = t1 + st1; 
          x[i3] = t1 - st1;
          
          //sumdiff3(x[i1], t2, x[i2]); // {a, b, d} <--| {a+b, b, a-b}
          x[i2] = x[i1] - t2;
          x[i1] += t2;
        }
      } else {
        for(i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;
     
          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4]; 
          x[i4] -= x[i3];
          
          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1; 
          x[i1] += t1;
        }
      }
   
      ix = (id << 1) - n2;
      id = id << 2;
    } while (ix < n);
 
    e = TWO_PI / n2;

    for (var j = 1; j < n8; j++) {
      a = j * e;
      ss1 = Math.sin(a);
      cc1 = Math.cos(a);
      
      //ss3 = sin(3*a); cc3 = cos(3*a);
      cc3 = 4*cc1*(cc1*cc1-0.75);
      ss3 = 4*ss1*(0.75-ss1*ss1);
   
      ix = 0; id = n2 << 1;
      do {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0 + j;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;
       
          i5 = i0 + n4 - j;
          i6 = i5 + n4;
          i7 = i6 + n4;
          i8 = i7 + n4;
       
          //cmult(c, s, x, y, &u, &v)
          //cmult(cc1, ss1, x[i7], x[i3], t2, t1); // {u,v} <--| {x*c-y*s, x*s+y*c}
          t2 = x[i7]*cc1 - x[i3]*ss1; 
          t1 = x[i7]*ss1 + x[i3]*cc1;
          
          //cmult(cc3, ss3, x[i8], x[i4], t4, t3);
          t4 = x[i8]*cc3 - x[i4]*ss3; 
          t3 = x[i8]*ss3 + x[i4]*cc3;
       
          //sumdiff(t2, t4);   // {a, b} <--| {a+b, a-b}
          st1 = t2 - t4;
          t2 += t4;
          t4 = st1;
          
          //sumdiff(t2, x[i6], x[i8], x[i3]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i6]; x[i8] = t2 + st1; x[i3] = t2 - st1;
          x[i8] = t2 + x[i6]; 
          x[i3] = t2 - x[i6];
         
          //sumdiff_r(t1, t3); // {a, b} <--| {a+b, b-a}
          st1 = t3 - t1;
          t1 += t3;
          t3 = st1;
          
          //sumdiff(t3, x[i2], x[i4], x[i7]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i2]; x[i4] = t3 + st1; x[i7] = t3 - st1;
          x[i4] = t3 + x[i2]; 
          x[i7] = t3 - x[i2];
         
          //sumdiff3(x[i1], t1, x[i6]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i6] = x[i1] - t1; 
          x[i1] += t1;
          
          //diffsum3_r(t4, x[i5], x[i2]); // {a, b, s} <--| {a, b-a, a+b}
          x[i2] = t4 + x[i5]; 
          x[i5] -= t4;
        }
     
        ix = id << 1 - n2;
        id = id << 2;
   
      } while (ix < n);
    }
  }

  while (--i) {
    rval = x[i];
    ival = x[n-i-1];
    mag = bSi * sqrt(rval * rval + ival * ival);

    if (mag > this.peak) {
      this.peakBand = i;
      this.peak = mag;
    }

    spectrum[i] = mag;
  }

  spectrum[0] = bSi * x[0];

  return spectrum;
};

function Sampler(file, bufferSize, sampleRate, playStart, playEnd, loopStart, loopEnd, loopMode) {
  this.file = file;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.playStart  = playStart || 0; // 0%
  this.playEnd    = playEnd   || 1; // 100%
  this.loopStart  = loopStart || 0;
  this.loopEnd    = loopEnd   || 1;
  this.loopMode   = loopMode  || DSP.OFF;
  this.loaded     = false;
  this.samples    = [];
  this.signal     = new Float32Array(bufferSize);
  this.frameCount = 0;
  this.envelope   = null;
  this.amplitude  = 1;
  this.rootFrequency = 110; // A2 110
  this.frequency  = 550;
  this.step       = this.frequency / this.rootFrequency;
  this.duration   = 0;
  this.samplesProcessed = 0;
  this.playhead   = 0;
 
  var audio = /* new Audio();*/ document.createElement("AUDIO");
  var self = this;
 
  this.loadSamples = function(event) {
    var buffer = DSP.getChannel(DSP.MIX, event.frameBuffer);
    for ( var i = 0; i < buffer.length; i++) {
      self.samples.push(buffer[i]);
    }
  };
 
  this.loadComplete = function() {
    // convert flexible js array into a fast typed array
    self.samples = new Float32Array(self.samples);
    self.loaded = true;
  };
 
  this.loadMetaData = function() {
    self.duration = audio.duration;
  };
 
  audio.addEventListener("MozAudioAvailable", this.loadSamples, false);
  audio.addEventListener("loadedmetadata", this.loadMetaData, false);
  audio.addEventListener("ended", this.loadComplete, false);
  audio.muted = true;
  audio.src = file;
  audio.play();
}

Sampler.prototype.applyEnvelope = function() {
  this.envelope.process(this.signal);
  return this.signal;
};

Sampler.prototype.generate = function() {
  var frameOffset = this.frameCount * this.bufferSize;
 
  var loopWidth = this.playEnd * this.samples.length - this.playStart * this.samples.length;
  var playStartSamples = this.playStart * this.samples.length; // ie 0.5 -> 50% of the length
  var playEndSamples = this.playEnd * this.samples.length; // ie 0.5 -> 50% of the length
  var offset;

  for ( var i = 0; i < this.bufferSize; i++ ) {
    switch (this.loopMode) {
      case DSP.OFF:
        this.playhead = Math.round(this.samplesProcessed * this.step + playStartSamples);
        if (this.playhead < (this.playEnd * this.samples.length) ) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        } else {
          this.signal[i] = 0;
        }
        break;
     
      case DSP.FW:
        this.playhead = Math.round((this.samplesProcessed * this.step) % loopWidth + playStartSamples);
        if (this.playhead < (this.playEnd * this.samples.length) ) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;
       
      case DSP.BW:
        this.playhead = playEndSamples - Math.round((this.samplesProcessed * this.step) % loopWidth);
        if (this.playhead < (this.playEnd * this.samples.length) ) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;
       
      case DSP.FWBW:
        if ( Math.floor(this.samplesProcessed * this.step / loopWidth) % 2 === 0 ) {
          this.playhead = Math.round((this.samplesProcessed * this.step) % loopWidth + playStartSamples);
        } else {
          this.playhead = playEndSamples - Math.round((this.samplesProcessed * this.step) % loopWidth);
        }  
        if (this.playhead < (this.playEnd * this.samples.length) ) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;
    }
    this.samplesProcessed++;
  }

  this.frameCount++;

  return this.signal;
};

Sampler.prototype.setFreq = function(frequency) {
  this.frequency = frequency;
  this.step = this.frequency / this.rootFrequency;
};

Sampler.prototype.reset = function() {
  this.samplesProcessed = 0;
  this.playhead = 0;
};

/**
 * Oscillator class for generating and modifying signals
 *
 * @param {Number} type       A waveform constant (eg. DSP.SINE)
 * @param {Number} frequency  Initial frequency of the signal
 * @param {Number} amplitude  Initial amplitude of the signal
 * @param {Number} bufferSize Size of the sample buffer to generate
 * @param {Number} sampleRate The sample rate of the signal
 *
 * @contructor
 */
function Oscillator(type, frequency, amplitude, bufferSize, sampleRate) {
  this.frequency  = frequency;
  this.amplitude  = amplitude;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  //this.pulseWidth = pulseWidth;
  this.frameCount = 0;
 
  this.waveTableLength = 2048;

  this.cyclesPerSample = frequency / sampleRate;

  this.signal = new Float32Array(bufferSize);
  this.envelope = null;

  switch(parseInt(type, 10)) {
    case DSP.TRIANGLE:
      this.func = Oscillator.Triangle;
      break;

    case DSP.SAW:
      this.func = Oscillator.Saw;
      break;

    case DSP.SQUARE:
      this.func = Oscillator.Square;
      break;

    default:
    case DSP.SINE:
      this.func = Oscillator.Sine;
      break;
  }

  this.generateWaveTable = function() {
    Oscillator.waveTable[this.func] = new Float32Array(2048);
    var waveTableTime = this.waveTableLength / this.sampleRate;
    var waveTableHz = 1 / waveTableTime;

    for (var i = 0; i < this.waveTableLength; i++) {
      Oscillator.waveTable[this.func][i] = this.func(i * waveTableHz/this.sampleRate);
    }
  };

  if ( typeof Oscillator.waveTable === 'undefined' ) {
    Oscillator.waveTable = {};
  }

  if ( typeof Oscillator.waveTable[this.func] === 'undefined' ) {
    this.generateWaveTable();
  }
 
  this.waveTable = Oscillator.waveTable[this.func];
}

/**
 * Set the amplitude of the signal
 *
 * @param {Number} amplitude The amplitude of the signal (between 0 and 1)
 */
Oscillator.prototype.setAmp = function(amplitude) {
  if (amplitude >= 0 && amplitude <= 1) {
    this.amplitude = amplitude;
  } else {
    throw "Amplitude out of range (0..1).";
  }
};
  
/**
 * Set the frequency of the signal
 *
 * @param {Number} frequency The frequency of the signal
 */  
Oscillator.prototype.setFreq = function(frequency) {
  this.frequency = frequency;
  this.cyclesPerSample = frequency / this.sampleRate;
};
     
// Add an oscillator
Oscillator.prototype.add = function(oscillator) {
  for ( var i = 0; i < this.bufferSize; i++ ) {
    //this.signal[i] += oscillator.valueAt(i);
    this.signal[i] += oscillator.signal[i];
  }
 
  return this.signal;
};
     
// Add a signal to the current generated osc signal
Oscillator.prototype.addSignal = function(signal) {
  for ( var i = 0; i < signal.length; i++ ) {
    if ( i >= this.bufferSize ) {
      break;
    }
    this.signal[i] += signal[i];
   
    /*
    // Constrain amplitude
    if ( this.signal[i] > 1 ) {
      this.signal[i] = 1;
    } else if ( this.signal[i] < -1 ) {
      this.signal[i] = -1;
    }
    */
  }
  return this.signal;
};
     
// Add an envelope to the oscillator
Oscillator.prototype.addEnvelope = function(envelope) {
  this.envelope = envelope;
};

Oscillator.prototype.applyEnvelope = function() {
  this.envelope.process(this.signal);
};
     
Oscillator.prototype.valueAt = function(offset) {
  return this.waveTable[offset % this.waveTableLength];
};
     
Oscillator.prototype.generate = function() {
  var frameOffset = this.frameCount * this.bufferSize;
  var step = this.waveTableLength * this.frequency / this.sampleRate;
  var offset;

  for ( var i = 0; i < this.bufferSize; i++ ) {
    //var step = (frameOffset + i) * this.cyclesPerSample % 1;
    //this.signal[i] = this.func(step) * this.amplitude;
    //this.signal[i] = this.valueAt(Math.round((frameOffset + i) * step)) * this.amplitude;
    offset = Math.round((frameOffset + i) * step);
    this.signal[i] = this.waveTable[offset % this.waveTableLength] * this.amplitude;
  }

  this.frameCount++;

  return this.signal;
};

Oscillator.Sine = function(step) {
  return Math.sin(DSP.TWO_PI * step);
};

Oscillator.Square = function(step) {
  return step < 0.5 ? 1 : -1;
};

Oscillator.Saw = function(step) {
  return 2 * (step - Math.round(step));
};

Oscillator.Triangle = function(step) {
  return 1 - 4 * Math.abs(Math.round(step) - step);
};

Oscillator.Pulse = function(step) {
  // stub
};
 
function ADSR(attackLength, decayLength, sustainLevel, sustainLength, releaseLength, sampleRate) {
  this.sampleRate = sampleRate;
  // Length in seconds
  this.attackLength  = attackLength;
  this.decayLength   = decayLength;
  this.sustainLevel  = sustainLevel;
  this.sustainLength = sustainLength;
  this.releaseLength = releaseLength;
  this.sampleRate    = sampleRate;
 
  // Length in samples
  this.attackSamples  = attackLength  * sampleRate;
  this.decaySamples   = decayLength   * sampleRate;
  this.sustainSamples = sustainLength * sampleRate;
  this.releaseSamples = releaseLength * sampleRate;
 
  // Updates the envelope sample positions
  this.update = function() {
    this.attack         =                this.attackSamples;
    this.decay          = this.attack  + this.decaySamples;
    this.sustain        = this.decay   + this.sustainSamples;
    this.release        = this.sustain + this.releaseSamples;
  };
 
  this.update();
 
  this.samplesProcessed = 0;
}

ADSR.prototype.noteOn = function() {
  this.samplesProcessed = 0;
  this.sustainSamples = this.sustainLength * this.sampleRate;
  this.update();
};

// Send a note off when using a sustain of infinity to let the envelope enter the release phase
ADSR.prototype.noteOff = function() {
  this.sustainSamples = this.samplesProcessed - this.decaySamples;
  this.update();
};

ADSR.prototype.processSample = function(sample) {
  var amplitude = 0;

  if ( this.samplesProcessed <= this.attack ) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if ( this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay ) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if ( this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain ) {
    amplitude = this.sustainLevel;
  } else if ( this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release ) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }
 
  return sample * amplitude;
};

ADSR.prototype.value = function() {
  var amplitude = 0;

  if ( this.samplesProcessed <= this.attack ) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if ( this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay ) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if ( this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain ) {
    amplitude = this.sustainLevel;
  } else if ( this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release ) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }
 
  return amplitude;
};
     
ADSR.prototype.process = function(buffer) {
  for ( var i = 0; i < buffer.length; i++ ) {
    buffer[i] *= this.value();

    this.samplesProcessed++;
  }
 
  return buffer;
};
     
     
ADSR.prototype.isActive = function() {
  if ( this.samplesProcessed > this.release || this.samplesProcessed === -1 ) {
    return false;
  } else {
    return true;
  }
};

ADSR.prototype.disable = function() {
  this.samplesProcessed = -1;
};
 
function IIRFilter(type, cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;

  switch(type) {
    case DSP.LOWPASS:
    case DSP.LP12:
      this.func = new IIRFilter.LP12(cutoff, resonance, sampleRate);
      break;
  }
}

IIRFilter.prototype.__defineGetter__('cutoff',
  function() {
    return this.func.cutoff;
  }
);

IIRFilter.prototype.__defineGetter__('resonance',
  function() {
    return this.func.resonance;
  }
);

IIRFilter.prototype.set = function(cutoff, resonance) {
  this.func.calcCoeff(cutoff, resonance);
};

IIRFilter.prototype.process = function(buffer) {
  this.func.process(buffer);
};

// Add an envelope to the filter
IIRFilter.prototype.addEnvelope = function(envelope) {
  if ( envelope instanceof ADSR ) {
    this.func.addEnvelope(envelope);
  } else {
    throw "Not an envelope.";
  }
};

IIRFilter.LP12 = function(cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;
  this.vibraPos   = 0;
  this.vibraSpeed = 0;
  this.envelope = false;
 
  this.calcCoeff = function(cutoff, resonance) {
    this.w = 2.0 * Math.PI * cutoff / this.sampleRate;
    this.q = 1.0 - this.w / (2.0 * (resonance + 0.5 / (1.0 + this.w)) + this.w - 2.0);
    this.r = this.q * this.q;
    this.c = this.r + 1.0 - 2.0 * Math.cos(this.w) * this.q;
   
    this.cutoff = cutoff;
    this.resonance = resonance;
  };

  this.calcCoeff(cutoff, resonance);

  this.process = function(buffer) {
    for ( var i = 0; i < buffer.length; i++ ) {
      this.vibraSpeed += (buffer[i] - this.vibraPos) * this.c;
      this.vibraPos   += this.vibraSpeed;
      this.vibraSpeed *= this.r;
   
      /*
      var temp = this.vibraPos;
     
      if ( temp > 1.0 ) {
        temp = 1.0;
      } else if ( temp < -1.0 ) {
        temp = -1.0;
      } else if ( temp != temp ) {
        temp = 1;
      }
     
      buffer[i] = temp;
      */

      if (this.envelope) {
        buffer[i] = (buffer[i] * (1 - this.envelope.value())) + (this.vibraPos * this.envelope.value());
        this.envelope.samplesProcessed++;
      } else {
        buffer[i] = this.vibraPos;
      }
    }
  };
}; 

IIRFilter.LP12.prototype.addEnvelope = function(envelope) {
  this.envelope = envelope;
};

function IIRFilter2(type, cutoff, resonance, sampleRate) {
  this.type = type;
  this.cutoff = cutoff;
  this.resonance = resonance;
  this.sampleRate = sampleRate;

  this.f = Float32Array(4);
  this.f[0] = 0.0; // lp
  this.f[1] = 0.0; // hp
  this.f[2] = 0.0; // bp
  this.f[3] = 0.0; // br 
 
  this.calcCoeff = function(cutoff, resonance) {
    this.freq = 2 * Math.sin(Math.PI * Math.min(0.25, cutoff/(this.sampleRate*2)));  
    this.damp = Math.min(2 * (1 - Math.pow(resonance, 0.25)), Math.min(2, 2/this.freq - this.freq * 0.5));
  };

  this.calcCoeff(cutoff, resonance);
}

IIRFilter2.prototype.process = function(buffer) {
  var input, output;
  var f = this.f;

  for ( var i = 0; i < buffer.length; i++ ) {
    input = buffer[i];

    // first pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output = 0.5 * f[this.type];

    // second pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output += 0.5 * f[this.type];

    if (this.envelope) {
      buffer[i] = (buffer[i] * (1 - this.envelope.value())) + (output * this.envelope.value());
      this.envelope.samplesProcessed++;
    } else {
      buffer[i] = output;
    }
  }
};

IIRFilter2.prototype.addEnvelope = function(envelope) {
  if ( envelope instanceof ADSR ) {
    this.envelope = envelope;
  } else {
    throw "This is not an envelope.";
  }
};

IIRFilter2.prototype.set = function(cutoff, resonance) {
  this.calcCoeff(cutoff, resonance);
};



function WindowFunction(type, alpha) {
  this.alpha = alpha;
 
  switch(type) {
    case DSP.BARTLETT:
      this.func = WindowFunction.Bartlett;
      break;
     
    case DSP.BARTLETTHANN:
      this.func = WindowFunction.BartlettHann;
      break;
     
    case DSP.BLACKMAN:
      this.func = WindowFunction.Blackman;
      this.alpha = this.alpha || 0.16;
      break;
   
    case DSP.COSINE:
      this.func = WindowFunction.Cosine;
      break;
     
    case DSP.GAUSS:
      this.func = WindowFunction.Gauss;
      this.alpha = this.alpha || 0.25;
      break;
     
    case DSP.HAMMING:
      this.func = WindowFunction.Hamming;
      break;
     
    case DSP.HANN:
      this.func = WindowFunction.Hann;
      break;
   
    case DSP.LANCZOS:
      this.func = WindowFunction.Lanczoz;
      break;
     
    case DSP.RECTANGULAR:
      this.func = WindowFunction.Rectangular;
      break;
     
    case DSP.TRIANGULAR:
      this.func = WindowFunction.Triangular;
      break;
  }
}

WindowFunction.prototype.process = function(buffer) {
  var length = buffer.length;
  for ( var i = 0; i < length; i++ ) {
    buffer[i] *= this.func(length, i, this.alpha);
  }
  return buffer;
};

WindowFunction.Bartlett = function(length, index) {
  return 2 / (length - 1) * ((length - 1) / 2 - Math.abs(index - (length - 1) / 2));
};

WindowFunction.BartlettHann = function(length, index) {
  return 0.62 - 0.48 * Math.abs(index / (length - 1) - 0.5) - 0.38 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Blackman = function(length, index, alpha) {
  var a0 = (1 - alpha) / 2;
  var a1 = 0.5;
  var a2 = alpha / 2;

  return a0 - a1 * Math.cos(DSP.TWO_PI * index / (length - 1)) + a2 * Math.cos(4 * Math.PI * index / (length - 1));
};

WindowFunction.Cosine = function(length, index) {
  return Math.cos(Math.PI * index / (length - 1) - Math.PI / 2);
};

WindowFunction.Gauss = function(length, index, alpha) {
  return Math.pow(Math.E, -0.5 * Math.pow((index - (length - 1) / 2) / (alpha * (length - 1) / 2), 2));
};

WindowFunction.Hamming = function(length, index) {
  return 0.54 - 0.46 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Hann = function(length, index) {
  return 0.5 * (1 - Math.cos(DSP.TWO_PI * index / (length - 1)));
};

WindowFunction.Lanczos = function(length, index) {
  var x = 2 * index / (length - 1) - 1;
  return Math.sin(Math.PI * x) / (Math.PI * x);
};

WindowFunction.Rectangular = function(length, index) {
  return 1;
};

WindowFunction.Triangular = function(length, index) {
  return 2 / length * (length / 2 - Math.abs(index - (length - 1) / 2));
};

function sinh (arg) {
  // Returns the hyperbolic sine of the number, defined as (exp(number) - exp(-number))/2 
  //
  // version: 1004.2314
  // discuss at: http://phpjs.org/functions/sinh    // +   original by: Onno Marsman
  // *     example 1: sinh(-0.9834330348825909);
  // *     returns 1: -1.1497971402636502
  return (Math.exp(arg) - Math.exp(-arg))/2;
}

/* 
 *  Biquad filter
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
// Implementation based on:
// http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
function Biquad(type, sampleRate) {
  this.Fs = sampleRate;
  this.type = type;  // type of the filter
  this.parameterType = DSP.Q; // type of the parameter

  this.x_1_l = 0;
  this.x_2_l = 0;
  this.y_1_l = 0;
  this.y_2_l = 0;

  this.x_1_r = 0;
  this.x_2_r = 0;
  this.y_1_r = 0;
  this.y_2_r = 0;

  this.b0 = 1;
  this.a0 = 1;

  this.b1 = 0;
  this.a1 = 0;

  this.b2 = 0;
  this.a2 = 0;

  this.b0a0 = this.b0 / this.a0;
  this.b1a0 = this.b1 / this.a0;
  this.b2a0 = this.b2 / this.a0;
  this.a1a0 = this.a1 / this.a0;
  this.a2a0 = this.a2 / this.a0;

  this.f0 = 3000;   // "wherever it's happenin', man."  Center Frequency or
                    // Corner Frequency, or shelf midpoint frequency, depending
                    // on which filter type.  The "significant frequency".

  this.dBgain = 12; // used only for peaking and shelving filters

  this.Q = 1;       // the EE kind of definition, except for peakingEQ in which A*Q is
                    // the classic EE Q.  That adjustment in definition was made so that
                    // a boost of N dB followed by a cut of N dB for identical Q and
                    // f0/Fs results in a precisely flat unity gain filter or "wire".

  this.BW = -3;     // the bandwidth in octaves (between -3 dB frequencies for BPF
                    // and notch or between midpoint (dBgain/2) gain frequencies for
                    // peaking EQ

  this.S = 1;       // a "shelf slope" parameter (for shelving EQ only).  When S = 1,
                    // the shelf slope is as steep as it can be and remain monotonically
                    // increasing or decreasing gain with frequency.  The shelf slope, in
                    // dB/octave, remains proportional to S for all other values for a
                    // fixed f0/Fs and dBgain.

  this.coefficients = function() {
    var b = [this.b0, this.b1, this.b2];
    var a = [this.a0, this.a1, this.a2];
    return {b: b, a:a};
  };

  this.setFilterType = function(type) {
    this.type = type;
    this.recalculateCoefficients();
  };

  this.setSampleRate = function(rate) {
    this.Fs = rate;
    this.recalculateCoefficients();
  };

  this.setQ = function(q) {
    this.parameterType = DSP.Q;
    this.Q = Math.max(Math.min(q, 115.0), 0.001);
    this.recalculateCoefficients();
  };

  this.setBW = function(bw) {
    this.parameterType = DSP.BW;
    this.BW = bw;
    this.recalculateCoefficients();
  };

  this.setS = function(s) {
    this.parameterType = DSP.S;
    this.S = Math.max(Math.min(s, 5.0), 0.0001);
    this.recalculateCoefficients();
  };

  this.setF0 = function(freq) {
    this.f0 = freq;
    this.recalculateCoefficients();
  }; 
 
  this.setDbGain = function(g) {
    this.dBgain = g;
    this.recalculateCoefficients();
  };

  this.recalculateCoefficients = function() {
    var A;
    if (type === DSP.PEAKING_EQ || type === DSP.LOW_SHELF || type === DSP.HIGH_SHELF ) {
      A = Math.pow(10, (this.dBgain/40));  // for peaking and shelving EQ filters only
    } else {
      A  = Math.sqrt( Math.pow(10, (this.dBgain/20)) );   
    }

    var w0 = DSP.TWO_PI * this.f0 / this.Fs;

    var cosw0 = Math.cos(w0);
    var sinw0 = Math.sin(w0);

    var alpha = 0;
   
    switch (this.parameterType) {
      case DSP.Q:
        alpha = sinw0/(2*this.Q);
        break;
           
      case DSP.BW:
        alpha = sinw0 * sinh( Math.LN2/2 * this.BW * w0/sinw0 );
        break;

      case DSP.S:
        alpha = sinw0/2 * Math.sqrt( (A + 1/A)*(1/this.S - 1) + 2 );
        break;
    }

    /**
        FYI: The relationship between bandwidth and Q is
             1/Q = 2*sinh(ln(2)/2*BW*w0/sin(w0))     (digital filter w BLT)
        or   1/Q = 2*sinh(ln(2)/2*BW)             (analog filter prototype)

        The relationship between shelf slope and Q is
             1/Q = sqrt((A + 1/A)*(1/S - 1) + 2)
    */

    var coeff;

    switch (this.type) {
      case DSP.LPF:       // H(s) = 1 / (s^2 + s/Q + 1)
        this.b0 =  (1 - cosw0)/2;
        this.b1 =   1 - cosw0;
        this.b2 =  (1 - cosw0)/2;
        this.a0 =   1 + alpha;
        this.a1 =  -2 * cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.HPF:       // H(s) = s^2 / (s^2 + s/Q + 1)
        this.b0 =  (1 + cosw0)/2;
        this.b1 = -(1 + cosw0);
        this.b2 =  (1 + cosw0)/2;
        this.a0 =   1 + alpha;
        this.a1 =  -2 * cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.BPF_CONSTANT_SKIRT:       // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
        this.b0 =   sinw0/2;
        this.b1 =   0;
        this.b2 =  -sinw0/2;
        this.a0 =   1 + alpha;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.BPF_CONSTANT_PEAK:       // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
        this.b0 =   alpha;
        this.b1 =   0;
        this.b2 =  -alpha;
        this.a0 =   1 + alpha;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.NOTCH:     // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
        this.b0 =   1;
        this.b1 =  -2*cosw0;
        this.b2 =   1;
        this.a0 =   1 + alpha;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.APF:       // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
        this.b0 =   1 - alpha;
        this.b1 =  -2*cosw0;
        this.b2 =   1 + alpha;
        this.a0 =   1 + alpha;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.PEAKING_EQ:  // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
        this.b0 =   1 + alpha*A;
        this.b1 =  -2*cosw0;
        this.b2 =   1 - alpha*A;
        this.a0 =   1 + alpha/A;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha/A;
        break;

      case DSP.LOW_SHELF:   // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
        coeff = sinw0 * Math.sqrt( (A^2 + 1)*(1/this.S - 1) + 2*A );
        this.b0 =    A*((A+1) - (A-1)*cosw0 + coeff);
        this.b1 =  2*A*((A-1) - (A+1)*cosw0);
        this.b2 =    A*((A+1) - (A-1)*cosw0 - coeff);
        this.a0 =       (A+1) + (A-1)*cosw0 + coeff;
        this.a1 =   -2*((A-1) + (A+1)*cosw0);
        this.a2 =       (A+1) + (A-1)*cosw0 - coeff;
        break;

      case DSP.HIGH_SHELF:   // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)
        coeff = sinw0 * Math.sqrt( (A^2 + 1)*(1/this.S - 1) + 2*A );
        this.b0 =    A*((A+1) + (A-1)*cosw0 + coeff);
        this.b1 = -2*A*((A-1) + (A+1)*cosw0);
        this.b2 =    A*((A+1) + (A-1)*cosw0 - coeff);
        this.a0 =       (A+1) - (A-1)*cosw0 + coeff;
        this.a1 =    2*((A-1) - (A+1)*cosw0);
        this.a2 =       (A+1) - (A-1)*cosw0 - coeff;
        break;
    }
   
    this.b0a0 = this.b0/this.a0;
    this.b1a0 = this.b1/this.a0;
    this.b2a0 = this.b2/this.a0;
    this.a1a0 = this.a1/this.a0;
    this.a2a0 = this.a2/this.a0;
  };

  this.process = function(buffer) {
      //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
      //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

      var len = buffer.length;
      var output = new Float32Array(len);

      for ( var i=0; i<buffer.length; i++ ) {
        output[i] = this.b0a0*buffer[i] + this.b1a0*this.x_1_l + this.b2a0*this.x_2_l - this.a1a0*this.y_1_l - this.a2a0*this.y_2_l;
        this.y_2_l = this.y_1_l;
        this.y_1_l = output[i];
        this.x_2_l = this.x_1_l;
        this.x_1_l = buffer[i];
      }

      return output;
  };

  this.processStereo = function(buffer) {
      //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
      //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

      var len = buffer.length;
      var output = new Float32Array(len);
     
      for (var i = 0; i < len/2; i++) {
        output[2*i] = this.b0a0*buffer[2*i] + this.b1a0*this.x_1_l + this.b2a0*this.x_2_l - this.a1a0*this.y_1_l - this.a2a0*this.y_2_l;
        this.y_2_l = this.y_1_l;
        this.y_1_l = output[2*i];
        this.x_2_l = this.x_1_l;
        this.x_1_l = buffer[2*i];

        output[2*i+1] = this.b0a0*buffer[2*i+1] + this.b1a0*this.x_1_r + this.b2a0*this.x_2_r - this.a1a0*this.y_1_r - this.a2a0*this.y_2_r;
        this.y_2_r = this.y_1_r;
        this.y_1_r = output[2*i+1];
        this.x_2_r = this.x_1_r;
        this.x_1_r = buffer[2*i+1];
      }

      return output;
  };
}

/* 
 *  Magnitude to decibels
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  @buffer array of magnitudes to convert to decibels
 *
 *  @returns the array in decibels
 *
 */
DSP.mag2db = function(buffer) {
  var minDb = -120;
  var minMag = Math.pow(10.0, minDb / 20.0);

  var log = Math.log;
  var max = Math.max;
 
  var result = Float32Array(buffer.length);
  for (var i=0; i<buffer.length; i++) {
    result[i] = 20.0*log(max(buffer[i], minMag));
  }

  return result;
};

/* 
 *  Frequency response
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  Calculates the frequency response at the given points.
 *
 *  @b b coefficients of the filter
 *  @a a coefficients of the filter
 *  @w w points (normally between -PI and PI) where to calculate the frequency response
 *
 *  @returns the frequency response in magnitude
 *
 */
DSP.freqz = function(b, a, w) {
  var i, j;

  if (!w) {
    w = Float32Array(200);
    for (i=0;i<w.length; i++) {
      w[i] = DSP.TWO_PI/w.length * i - Math.PI;
    }
  }

  var result = Float32Array(w.length);
 
  var sqrt = Math.sqrt;
  var cos = Math.cos;
  var sin = Math.sin;
 
  for (i=0; i<w.length; i++) {
    var numerator = {real:0.0, imag:0.0};
    for (j=0; j<b.length; j++) {
      numerator.real += b[j] * cos(-j*w[i]);
      numerator.imag += b[j] * sin(-j*w[i]);
    }

    var denominator = {real:0.0, imag:0.0};
    for (j=0; j<a.length; j++) {
      denominator.real += a[j] * cos(-j*w[i]);
      denominator.imag += a[j] * sin(-j*w[i]);
    }
 
    result[i] =  sqrt(numerator.real*numerator.real + numerator.imag*numerator.imag) / sqrt(denominator.real*denominator.real + denominator.imag*denominator.imag);
  }

  return result;
};

/* 
 *  Graphical Equalizer
 *
 *  Implementation of a graphic equalizer with a configurable bands-per-octave
 *  and minimum and maximum frequencies
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
function GraphicalEq(sampleRate) {
  this.FS = sampleRate;
  this.minFreq = 40.0;
  this.maxFreq = 16000.0;

  this.bandsPerOctave = 1.0;

  this.filters = [];
  this.freqzs = [];

  this.calculateFreqzs = true;

  this.recalculateFilters = function() {
    var bandCount = Math.round(Math.log(this.maxFreq/this.minFreq) * this.bandsPerOctave/ Math.LN2);

    this.filters = [];
    for (var i=0; i<bandCount; i++) {
      var freq = this.minFreq*(Math.pow(2, i/this.bandsPerOctave));
      var newFilter = new Biquad(DSP.PEAKING_EQ, this.FS);
      newFilter.setDbGain(0);
      newFilter.setBW(1/this.bandsPerOctave);
      newFilter.setF0(freq);
      this.filters[i] = newFilter;
      this.recalculateFreqz(i);
    }
  };

  this.setMinimumFrequency = function(freq) {
    this.minFreq = freq;
    this.recalculateFilters();
  };

  this.setMaximumFrequency = function(freq) {
    this.maxFreq = freq;
    this.recalculateFilters();
  };

  this.setBandsPerOctave = function(bands) {
    this.bandsPerOctave = bands;
    this.recalculateFilters();
  };

  this.setBandGain = function(bandIndex, gain) {
    if (bandIndex < 0 || bandIndex > (this.filters.length-1)) {
      throw "The band index of the graphical equalizer is out of bounds.";
    }

    if (!gain) {
      throw "A gain must be passed.";
    }
   
    this.filters[bandIndex].setDbGain(gain);
    this.recalculateFreqz(bandIndex);
  };
 
  this.recalculateFreqz = function(bandIndex) {
    if (!this.calculateFreqzs) {
      return;
    }

    if (bandIndex < 0 || bandIndex > (this.filters.length-1)) {
      throw "The band index of the graphical equalizer is out of bounds. " + bandIndex + " is out of [" + 0 + ", " + this.filters.length-1 + "]";
    }
       
    if (!this.w) {
      this.w = Float32Array(400);
      for (var i=0; i<this.w.length; i++) {
         this.w[i] = Math.PI/this.w.length * i;
      }
    }
   
    var b = [this.filters[bandIndex].b0, this.filters[bandIndex].b1, this.filters[bandIndex].b2];
    var a = [this.filters[bandIndex].a0, this.filters[bandIndex].a1, this.filters[bandIndex].a2];

    this.freqzs[bandIndex] = DSP.mag2db(DSP.freqz(b, a, this.w));
  };

  this.process = function(buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].process(output);
    }

    return output;
  };

  this.processStereo = function(buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].processStereo(output);
    }

    return output;
  };
}

/**
 * MultiDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/delay-firefox-audio-api/
 *
 * This is a delay that feeds it's own delayed signal back into its circular
 * buffer. Also known as a CombFilter.
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */
function MultiDelay(maxDelayInSamplesSize, delayInSamples, masterVolume, delayVolume) {
  this.delayBufferSamples   = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer     = delayInSamples;
  this.delayOutputPointer   = 0;
 
  this.delayInSamples   = delayInSamples;
  this.masterVolume     = masterVolume;
  this.delayVolume     = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
MultiDelay.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;
 
  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length; 
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setMasterVolume = function(masterVolume) {
  this.masterVolume = masterVolume;
};

/**
 * Change the delay feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setDelayVolume = function(delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and adds the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
MultiDelay.prototype.process = function(samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i=0; i<samples.length; i++) {
    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = (this.delayBufferSamples[this.delayOutputPointer] === null ? 0.0 : this.delayBufferSamples[this.delayOutputPointer]);
   
    // Mix normal audio data with delayed audio
    var sample = (delaySample * this.delayVolume) + samples[i];
   
    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = sample;
   
    // Return the audio with delay mix
    outputSamples[i] = sample * this.masterVolume;
   
    // Manage circulair delay buffer pointers
    this.delayInputPointer++;
    if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
      this.delayInputPointer = 0;
    }
     
    this.delayOutputPointer++;
    if (this.delayOutputPointer >= this.delayBufferSamples.length-1) {
      this.delayOutputPointer = 0; 
    } 
  }
 
  return outputSamples;
};

/**
 * SingleDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: See usage in Reverb class
 *
 * This is a delay that does NOT feeds it's own delayed signal back into its 
 * circular buffer, neither does it return the original signal. Also known as
 * an AllPassFilter(?).
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */

function SingleDelay(maxDelayInSamplesSize, delayInSamples, delayVolume) {
  this.delayBufferSamples = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer  = delayInSamples;
  this.delayOutputPointer = 0;
 
  this.delayInSamples     = delayInSamples;
  this.delayVolume        = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
SingleDelay.prototype.setDelayInSamples = function(delayInSamples) {
  this.delayInSamples = delayInSamples;
  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length; 
  }
};

/**
 * Change the return signal volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
SingleDelay.prototype.setDelayVolume = function(delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and
 * returns the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
SingleDelay.prototype.process = function(samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i=0; i<samples.length; i++) {

    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = samples[i];
   
    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = this.delayBufferSamples[this.delayOutputPointer];

    // Return the audio with delay mix
    outputSamples[i] = delaySample * this.delayVolume;

    // Manage circulair delay buffer pointers
    this.delayInputPointer++;

    if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
      this.delayInputPointer = 0;
    }
     
    this.delayOutputPointer++;

    if (this.delayOutputPointer >= this.delayBufferSamples.length-1) {
      this.delayOutputPointer = 0; 
    } 
  }
 
  return outputSamples;
};

/**
 * Reverb effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/reverb-firefox-audio-api/
 *
 * This reverb consists of 6 SingleDelays, 6 MultiDelays and an IIRFilter2
 * for each of the two stereo channels.
 *
 * Compatible with interleaved stereo buffers only!
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffers)
 * @param {Number} delayInSamples Initial delay in samples for internal (Single/Multi)delays
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} mixVolume Initial reverb signal mix volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume for internal (Single/Multi)delays. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} dampFrequency Initial low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 *
 * @constructor
 */
function Reverb(maxDelayInSamplesSize, delayInSamples, masterVolume, mixVolume, delayVolume, dampFrequency) {
  this.delayInSamples   = delayInSamples;
  this.masterVolume     = masterVolume;
  this.mixVolume       = mixVolume;
  this.delayVolume     = delayVolume;
  this.dampFrequency     = dampFrequency;
 
  this.NR_OF_MULTIDELAYS = 6;
  this.NR_OF_SINGLEDELAYS = 6;
 
  this.LOWPASSL = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);
  this.LOWPASSR = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);
 
  this.singleDelays = [];
  
  var i, delayMultiply;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + (i/7.0); // 1.0, 1.1, 1.2...
    this.singleDelays[i] = new SingleDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.delayVolume);
  }
 
  this.multiDelays = [];

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + (i/10.0); // 1.0, 1.1, 1.2... 
    this.multiDelays[i] = new MultiDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.masterVolume, this.delayVolume);
  }
}

/**
 * Change the delay time in samples as a base for all delays.
 *
 * @param {Number} delayInSamples Delay in samples
 */
Reverb.prototype.setDelayInSamples = function (delayInSamples){
  this.delayInSamples = delayInSamples;

  var i, delayMultiply;
 
  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + (i/7.0); // 1.0, 1.1, 1.2...
    this.singleDelays[i].setDelayInSamples( Math.round(this.delayInSamples * delayMultiply) );
  }
   
  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + (i/10.0); // 1.0, 1.1, 1.2...
    this.multiDelays[i].setDelayInSamples( Math.round(this.delayInSamples * delayMultiply) );
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMasterVolume = function (masterVolume){
  this.masterVolume = masterVolume;
};

/**
 * Change the reverb signal mix level.
 *
 * @param {Number} mixVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMixVolume = function (mixVolume){
  this.mixVolume = mixVolume;
};

/**
 * Change all delays feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setDelayVolume = function (delayVolume){
  this.delayVolume = delayVolume;
 
  var i;

  for (i = 0; i<this.NR_OF_SINGLEDELAYS; i++) {
    this.singleDelays[i].setDelayVolume(this.delayVolume);
  } 
 
  for (i = 0; i<this.NR_OF_MULTIDELAYS; i++) {
    this.multiDelays[i].setDelayVolume(this.delayVolume);
  } 
};

/**
 * Change the Low Pass filter frequency.
 *
 * @param {Number} dampFrequency low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 */
Reverb.prototype.setDampFrequency = function (dampFrequency){
  this.dampFrequency = dampFrequency;
 
  this.LOWPASSL.set(dampFrequency, 0);
  this.LOWPASSR.set(dampFrequency, 0); 
};

/**
 * Process a given interleaved float value Array and copies and adds the reverb signal.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved buffer.
 */
Reverb.prototype.process = function (interleavedSamples){ 
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(interleavedSamples.length);
 
  // Perform low pass on the input samples to mimick damp
  var leftRightMix = DSP.deinterleave(interleavedSamples);
  this.LOWPASSL.process( leftRightMix[DSP.LEFT] );
  this.LOWPASSR.process( leftRightMix[DSP.RIGHT] ); 
  var filteredSamples = DSP.interleave(leftRightMix[DSP.LEFT], leftRightMix[DSP.RIGHT]);

  var i;

  // Process MultiDelays in parallel
  for (i = 0; i<this.NR_OF_MULTIDELAYS; i++) {
    // Invert the signal of every even multiDelay
    outputSamples = DSP.mixSampleBuffers(outputSamples, this.multiDelays[i].process(filteredSamples), 2%i === 0, this.NR_OF_MULTIDELAYS);
  }
 
  // Process SingleDelays in series
  var singleDelaySamples = new Float32Array(outputSamples.length);
  for (i = 0; i<this.NR_OF_SINGLEDELAYS; i++) {
    // Invert the signal of every even singleDelay
    singleDelaySamples = DSP.mixSampleBuffers(singleDelaySamples, this.singleDelays[i].process(outputSamples), 2%i === 0, 1);
  }

  // Apply the volume of the reverb signal
  for (i = 0; i<singleDelaySamples.length; i++) {
    singleDelaySamples[i] *= this.mixVolume;
  }
 
  // Mix the original signal with the reverb signal
  outputSamples = DSP.mixSampleBuffers(singleDelaySamples, interleavedSamples, 0, 1);

  // Apply the master volume to the complete signal
  for (i = 0; i<outputSamples.length; i++) {
    outputSamples[i] *= this.masterVolume;
  }
   
  return outputSamples;
};


</script>
		<script type="text/javascript">
(function(global, document) {

  //  Cache refs to speed up calls to native utils
  var
  forEach = Array.prototype.forEach,
  hasOwn = Object.prototype.hasOwnProperty,
  slice = Array.prototype.slice,
  toString = Object.prototype.toString,

  //  ID string matching
  rIdExp  = /^(#([\w\-\_\.]+))$/,

  //  Ready fn cache
  readyStack = [],
  readyBound = false,
  readyFired = false,


  //  Declare constructor
  //  Returns an instance object.
  Popcorn = function( entity, options ) {
    //  Return new Popcorn object
    return new Popcorn.p.init( entity, options || null );
  };

  //  Instance caching
  Popcorn.instances = [];
  Popcorn.instanceIds = {};

  Popcorn.removeInstance = function( instance ) {
    //  If called prior to any instances being created
    //  Return early to avoid splicing on nothing
    if ( !Popcorn.instances.length ) {
      return;
    }

    //  Remove instance from Popcorn.instances
    Popcorn.instances.splice( Popcorn.instanceIds[ instance.id ], 1 );

    //  Delete the instance id key
    delete Popcorn.instanceIds[ instance.id ];

    //  Return current modified instances
    return Popcorn.instances;
  };

  //  Addes a Popcorn instance to the Popcorn instance array
  Popcorn.addInstance = function( instance ) {

    var instanceLen = Popcorn.instances.length,
        instanceId = instance.media.id && instance.media.id;

    //  If the media element has its own `id` use it, otherwise provide one
    //  Ensure that instances have unique ids and unique entries
    //  Uses `in` operator to avoid false positives on 0
    instance.id = !( instanceId in Popcorn.instanceIds ) && instanceId ||
                      "__popcorn" + instanceLen;

    //  Create a reference entry for this instance
    Popcorn.instanceIds[ instance.id ] = instanceLen;

    //  Add this instance to the cache
    Popcorn.instances.push( instance );

    //  Return the current modified instances
    return Popcorn.instances;
  };

  //  Request Popcorn object instance by id
  Popcorn.getInstanceById = function( id ) {
    return Popcorn.instances[ Popcorn.instanceIds[ id ] ];
  };

  //  Remove Popcorn object instance by id
  Popcorn.removeInstanceById = function( id ) {
    return Popcorn.removeInstance( Popcorn.instances[ Popcorn.instanceIds[ id ] ] );
  };

  //  Declare a shortcut (Popcorn.p) to and a definition of
  //  the new prototype for our Popcorn constructor
  Popcorn.p = Popcorn.prototype = {

    init: function( entity, options ) {

      var matches;

      //  Supports Popcorn(function () { /../ })
      //  Originally proposed by Daniel Brooks

      if ( typeof entity === "function" ) {

        //  If document ready has already fired
        if ( document.readyState === "interactive" || document.readyState === "complete" ) {

          entity(document, Popcorn);

          return;
        }
        //  Add `entity` fn to ready stack
        readyStack.push( entity );

        //  This process should happen once per page load
        if ( !readyBound ) {

          //  set readyBound flag
          readyBound = true;

          var DOMContentLoaded  = function () {

            readyFired = true;

            //  Remove global DOM ready listener
            document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );

            //  Execute all ready function in the stack
            for ( var i = 0; i < readyStack.length; i++ ) {

              readyStack[i].call( document, Popcorn );

            }
            //  GC readyStack
            readyStack = null;
          };

          //  Register global DOM ready listener
          document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false);
        }

        return;
      }

      //  Check if entity is a valid string id
      matches = rIdExp.exec( entity );

      //  Get media element by id or object reference
      this.media = matches && matches.length && matches[ 2 ] ?
                    document.getElementById( matches[ 2 ] ) :
                    entity;

      //  Create an audio or video element property reference
      this[ ( this.media.tagName && this.media.tagName.toLowerCase() ) || "video" ] = this.media;

      //  Register new instance
      Popcorn.addInstance( this );

      this.options = options || { };
      this.data = {
        history: [],
        events: {},
        trackEvents: {
          byStart: [{
            start: -1,
            end: -1
          }],
          byEnd:   [{
            start: -1,
            end: -1
          }],
          startIndex: 0,
          endIndex:   0,
          previousUpdateTime: 0
        }
      };

      //  Wrap true ready check
      var isReady = function( that ) {

        if ( that.media.readyState >= 2 ) {
          //  Adding padding to the front and end of the arrays
          //  this is so we do not fall off either end

          var duration = that.media.duration,
              //  Check for no duration info (NaN)
              videoDurationPlus = duration != duration ? Number.MAX_VALUE : duration + 1;

          Popcorn.addTrackEvent( that, {
            start: videoDurationPlus,
            end: videoDurationPlus
          });

          that.media.addEventListener( "timeupdate", function( event ) {

            var currentTime    = this.currentTime,
                previousTime   = that.data.trackEvents.previousUpdateTime,
                tracks         = that.data.trackEvents,
                tracksByEnd    = tracks.byEnd,
                tracksByStart  = tracks.byStart;

            //  Playbar advancing
            if ( previousTime < currentTime ) {

              while ( tracksByEnd[ tracks.endIndex ] && tracksByEnd[ tracks.endIndex ].end <= currentTime ) {
                //  If plugin does not exist on this instance, remove it
                if ( !tracksByEnd[ tracks.endIndex ]._natives || !!that[ tracksByEnd[ tracks.endIndex ]._natives.type ] ) {
                  if ( tracksByEnd[ tracks.endIndex ]._running === true ) {
                    tracksByEnd[ tracks.endIndex ]._running = false;
                    tracksByEnd[ tracks.endIndex ]._natives.end.call( that, event, tracksByEnd[ tracks.endIndex ] );
                  }
                  tracks.endIndex++;
                } else {
                  // remove track event
                  Popcorn.removeTrackEvent( that, tracksByEnd[ tracks.endIndex ]._id );
                  return;
                }
              }

              while ( tracksByStart[ tracks.startIndex ] && tracksByStart[ tracks.startIndex ].start <= currentTime ) {
                //  If plugin does not exist on this instance, remove it
                if ( !tracksByStart[ tracks.startIndex ]._natives || !!that[ tracksByStart[ tracks.startIndex ]._natives.type ] ) {
                  if ( tracksByStart[ tracks.startIndex ].end > currentTime && tracksByStart[ tracks.startIndex ]._running === false ) {
                    tracksByStart[ tracks.startIndex ]._running = true;
                    tracksByStart[ tracks.startIndex ]._natives.start.call( that, event, tracksByStart[ tracks.startIndex ] );
                  }
                  tracks.startIndex++;
                } else {
                  // remove track event
                  Popcorn.removeTrackEvent( that, tracksByStart[ tracks.startIndex ]._id );
                  return;
                }
              }

            // Playbar receding
            } else if ( previousTime > currentTime ) {

              while ( tracksByStart[ tracks.startIndex ] && tracksByStart[ tracks.startIndex ].start > currentTime ) {
                // if plugin does not exist on this instance, remove it
                if ( !tracksByStart[ tracks.startIndex ]._natives || !!that[ tracksByStart[ tracks.startIndex ]._natives.type ] ) {
                  if ( tracksByStart[ tracks.startIndex ]._running === true ) {
                    tracksByStart[ tracks.startIndex ]._running = false;
                    tracksByStart[ tracks.startIndex ]._natives.end.call( that, event, tracksByStart[ tracks.startIndex ] );
                  }
                  tracks.startIndex--;
                } else {
                  // remove track event
                  Popcorn.removeTrackEvent( that, tracksByStart[ tracks.startIndex ]._id );
                  return;
                }
              }

              while ( tracksByEnd[ tracks.endIndex ] && tracksByEnd[ tracks.endIndex ].end > currentTime ) {
                // if plugin does not exist on this instance, remove it
                if ( !tracksByEnd[ tracks.endIndex ]._natives || !!that[ tracksByEnd[ tracks.endIndex ]._natives.type ] ) {
                  if ( tracksByEnd[ tracks.endIndex ].start <= currentTime && tracksByEnd[ tracks.endIndex ]._running === false ) {
                    tracksByEnd[ tracks.endIndex ]._running = true;
                    tracksByEnd[ tracks.endIndex ]._natives.start.call( that, event, tracksByEnd[tracks.endIndex] );
                  }
                  tracks.endIndex--;
                } else {
                  // remove track event
                  Popcorn.removeTrackEvent( that, tracksByEnd[ tracks.endIndex ]._id );
                  return;
                }
              }
            }

            tracks.previousUpdateTime = currentTime;

          }, false);
        } else {
          global.setTimeout( function() {
            isReady( that );
          }, 1);
        }
      };

      isReady( this );

      return this;
    }
  };

  //  Extend constructor prototype to instance prototype
  //  Allows chaining methods to instances
  Popcorn.p.init.prototype = Popcorn.p;

  Popcorn.forEach = function( obj, fn, context ) {

    if ( !obj || !fn ) {
      return {};
    }

    context = context || this;
    // Use native whenever possible
    if ( forEach && obj.forEach === forEach ) {
      return obj.forEach(fn, context);
    }

    for ( var key in obj ) {
      if ( hasOwn.call(obj, key) ) {
        fn.call(context, obj[key], key, obj);
      }
    }

    return obj;
  };

  Popcorn.extend = function( obj ) {
    var dest = obj, src = slice.call(arguments, 1);

    Popcorn.forEach( src, function( copy ) {
      for ( var prop in copy ) {
        dest[prop] = copy[prop];
      }
    });
    return dest;
  };


  // A Few reusable utils, memoized onto Popcorn
  Popcorn.extend( Popcorn, {
    error: function( msg ) {
      throw new Error( msg );
    },
    guid: function( prefix ) {
      Popcorn.guid.counter++;
      return  ( prefix ? prefix : "" ) + ( +new Date() + Popcorn.guid.counter );
    },
    sizeOf: function ( obj ) {
      var size = 0;

      for ( var prop in obj  ) {
        size++;
      }

      return size;
    },
    isArray: Array.isArray || function( array ) {
      return toString.call( array ) === "[object Array]";
    }, 

    nop: function () {},

    position: function( elem ) {

      var clientRect = elem.getBoundingClientRect(),
          bounds = {}, 
          doc = elem.ownerDocument,
          docElem = document.documentElement,
          body = document.body,
          clientTop, clientLeft, scrollTop, scrollLeft, top, left;

      //  Determine correct clientTop/Left
      clientTop  = docElem.clientTop  || body.clientTop  || 0;
      clientLeft = docElem.clientLeft || body.clientLeft || 0;

      //  Determine correct scrollTop/Left
      scrollTop  = ( global.pageYOffset && docElem.scrollTop || body.scrollTop );
      scrollLeft = ( global.pageXOffset && docElem.scrollLeft || body.scrollLeft );

      //  Temp top/left
      top  = Math.ceil( clientRect.top  + scrollTop - clientTop );
      left = Math.ceil( clientRect.left + scrollLeft - clientLeft );

      for ( var p in clientRect ) {
        bounds[ p ] = Math.round( clientRect[ p ] );
      }

      return Popcorn.extend({}, bounds, { top: top, left: left });     
    }
  });

  //  Memoized GUID Counter
  Popcorn.guid.counter  = 1;

  //  Factory to implement getters, setters and controllers
  //  as Popcorn instance methods. The IIFE will create and return
  //  an object with defined methods
  Popcorn.extend(Popcorn.p, (function () {

      var methods = "load play pause currentTime playbackRate mute volume duration",
          ret = {};


      //  Build methods, store in object that is returned and passed to extend
      Popcorn.forEach( methods.split(/\s+/g), function( name ) {

        ret[ name ] = function( arg ) {

          if ( typeof this.media[name] === "function" ) {
            this.media[ name ]();

            return this;
          }


          if ( arg !== false && arg !== null && typeof arg !== "undefined" ) {

            this.media[ name ] = arg;

            return this;
          }

          return this.media[ name ];
        };
      });

      return ret;

    })()
  );

  Popcorn.extend(Popcorn.p, {

    //  Rounded currentTime
    roundTime: function () {
      return -~this.media.currentTime;
    },

    //  Attach an event to a single point in time
    exec: function ( time, fn ) {

      //  Creating a one second track event with an empty end
      Popcorn.addTrackEvent( this, {
        start: time,
        end: time + 1,
        _running: false,
        _natives: {
          start: fn || Popcorn.nop,
          end: Popcorn.nop,
          type: "exec"
        }
      });

      return this;
    },
    position: function() {
      return Popcorn.position( this.media );
    }
  });

  Popcorn.Events  = {
    UIEvents: "blur focus focusin focusout load resize scroll unload  ",
    MouseEvents: "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave click dblclick",
    Events: "loadstart progress suspend emptied stalled play pause " +
           "loadedmetadata loadeddata waiting playing canplay canplaythrough " +
           "seeking seeked timeupdate ended ratechange durationchange volumechange"
  };

  Popcorn.Events.Natives = Popcorn.Events.UIEvents + " " +
                            Popcorn.Events.MouseEvents + " " +
                              Popcorn.Events.Events;

  Popcorn.events  = {


    isNative: function( type ) {

      var checks = Popcorn.Events.Natives.split( /\s+/g );

      for ( var i = 0; i < checks.length; i++ ) {
        if ( checks[i] === type ) {
          return true;
        }
      }

      return false;
    },
    getInterface: function( type ) {

      if ( !Popcorn.events.isNative( type ) ) {
        return false;
      }

      var natives = Popcorn.Events,
          proto;

      for ( var p in natives ) {
        if ( p !== "Natives" && natives[ p ].indexOf( type ) > -1 ) {
          proto = p;
        }
      }

      return proto;
    },
    //  Compile all native events to single array
    all: Popcorn.Events.Natives.split(/\s+/g),
    //  Defines all Event handling static functions
    fn: {
      trigger: function ( type, data ) {

        //  setup checks for custom event system
        if ( this.data.events[ type ] && Popcorn.sizeOf( this.data.events[ type ] ) ) {

          var eventInterface  = Popcorn.events.getInterface( type );

          if ( eventInterface ) {

            var evt = document.createEvent( eventInterface );
                evt.initEvent(type, true, true, global, 1);

            this.media.dispatchEvent(evt);

            return this;
          }

          //  Custom events
          Popcorn.forEach(this.data.events[ type ], function ( obj, key ) {

            obj.call( this, data );

          }, this);

        }

        return this;
      },
      listen: function ( type, fn ) {

        var self = this, hasEvents = true;

        if ( !this.data.events[type] ) {
          this.data.events[type] = {};
          hasEvents = false;
        }

        //  Register
        this.data.events[ type ][ fn.name || ( fn.toString() + Popcorn.guid() ) ] = fn;

        // only attach one event of any type
        if ( !hasEvents && Popcorn.events.all.indexOf( type ) > -1 ) {

          this.media.addEventListener( type, function( event ) {

            Popcorn.forEach( self.data.events[type], function ( obj, key ) {
              if ( typeof obj === "function" ) {
                obj.call(self, event);
              }

            });

            //fn.call( self, event );

          }, false);
        }
        return this;
      },
      unlisten: function( type, fn ) {

        if ( this.data.events[type] && this.data.events[type][fn] ) {

          delete this.data.events[type][ fn ];

          return this;
        }

        this.data.events[type] = null;

        return this;
      }
    }
  };

  //  Extend Popcorn.events.fns (listen, unlisten, trigger) to all Popcorn instances
  Popcorn.forEach( ["trigger", "listen", "unlisten"], function ( key ) {
    Popcorn.p[ key ] = Popcorn.events.fn[ key ];
  });
  //  Protected API methods
  Popcorn.protect = {
    natives: "load play pause currentTime playbackRate mute volume duration removePlugin roundTime trigger listen unlisten".toLowerCase().split(/\s+/)
  };

  //  Internal Only
  Popcorn.addTrackEvent = function( obj, track ) {

    if ( track._natives ) {
      //  Supports user defined track event id
      track._id = !track.id ? Popcorn.guid( track._natives.type ) : track.id;

      //  Push track event ids into the history
      obj.data.history.push( track._id );

      track._natives.start = track._natives.start || Popcorn.nop;
      track._natives.end = track._natives.end || Popcorn.nop;
    }

    track.start = Popcorn.util.toSeconds( track.start, obj.options.framerate );
    track.end = Popcorn.util.toSeconds( track.end, obj.options.framerate );

    //  Store this definition in an array sorted by times
    obj.data.trackEvents.byStart.push( track );
    obj.data.trackEvents.byEnd.push( track );
    obj.data.trackEvents.byStart.sort( function( a, b ){
      return ( a.start - b.start );
    });
    obj.data.trackEvents.byEnd.sort( function( a, b ){
      return ( a.end - b.end );
    });

  };

  //  removePlugin( type ) removes all tracks of that from all instances of popcorn
  //  removePlugin( obj, type ) removes all tracks of type from obj, where obj is a single instance of popcorn
  Popcorn.removePlugin = function( obj, name ) {

    //  Check if we are removing plugin from an instance or from all of Popcorn
    if ( !name ) {

      //  Fix the order
      name = obj;
      obj = Popcorn.p;

      var registryLen = Popcorn.registry.length,
          registryIdx;

      // remove plugin reference from registry
      for ( registryIdx = 0; registryIdx < registryLen; registryIdx++ ) {
        if ( Popcorn.registry[ registryIdx ].name === name ) {
          Popcorn.registry.splice( registryIdx, 1 );
          delete Popcorn.registryByName[ name ];

          // delete the plugin
          delete obj[ name ];

          // plugin found and removed, stop checking, we are done
          return;
        }
      }

    }

    var byStart = obj.data.trackEvents.byStart,
        byEnd = obj.data.trackEvents.byEnd,
        idx, sl;

    // remove all trackEvents
    for ( idx = 0, sl = byStart.length; idx < sl; idx++ ) {

      if ( ( byStart[ idx ] && byStart[ idx ]._natives && byStart[ idx ]._natives.type === name ) &&
                ( byEnd[ idx ] && byEnd[ idx ]._natives && byEnd[ idx ]._natives.type === name ) ) {

        byStart.splice( idx, 1 );
        byEnd.splice( idx, 1 );

        // update for loop if something removed, but keep checking
        idx--; sl--;
        if ( obj.data.trackEvents.startIndex <= idx ) {
          obj.data.trackEvents.startIndex--;
          obj.data.trackEvents.endIndex--;
        }
      }
    }
  };

  Popcorn.removeTrackEvent  = function( obj, trackId ) {

    var historyLen = obj.data.history.length,
        indexWasAt = 0,
        byStart = [],
        byEnd = [],
        history = [];


    Popcorn.forEach( obj.data.trackEvents.byStart, function( o, i, context ) {
      // Preserve the original start/end trackEvents
      if ( !o._id ) {
        byStart.push( obj.data.trackEvents.byStart[i] );
        byEnd.push( obj.data.trackEvents.byEnd[i] );
      }

      // Filter for user track events (vs system track events)
      if ( o._id ) {

        // Filter for the trackevent to remove
        if ( o._id !== trackId ) {
          byStart.push( obj.data.trackEvents.byStart[i] );
          byEnd.push( obj.data.trackEvents.byEnd[i] );
        }

        //  Capture the position of the track being removed.
        if ( o._id === trackId ) {
          indexWasAt = i;
          o._natives._teardown && o._natives._teardown.call( obj, o );
        }
      }
    });


    //  Update
    if ( indexWasAt <= obj.data.trackEvents.startIndex ) {
      obj.data.trackEvents.startIndex--;
    }

    if ( indexWasAt <= obj.data.trackEvents.endIndex ) {
      obj.data.trackEvents.endIndex--;
    }


    obj.data.trackEvents.byStart = byStart;
    obj.data.trackEvents.byEnd = byEnd;


    for ( var i = 0; i < historyLen; i++ ) {
      if ( obj.data.history[i] !== trackId ) {
        history.push( obj.data.history[i] );
      }
    }

    obj.data.history = history;

  };

  Popcorn.getTrackEvents = function( obj ) {

    var trackevents = [];

    Popcorn.forEach( obj.data.trackEvents.byStart, function( o, i, context ) {
      if ( o._id ) {
        trackevents.push(o);
      }
    });

    return trackevents;
  };


  Popcorn.getLastTrackEventId = function( obj ) {
    return obj.data.history[ obj.data.history.length - 1 ];
  };

  //  Map and Extend TrackEvent functions to all Popcorn instances
  Popcorn.extend( Popcorn.p, {

    getTrackEvents: function() {
      return Popcorn.getTrackEvents.call( null, this );
    },

    getLastTrackEventId: function() {
      return Popcorn.getLastTrackEventId.call( null, this );
    },

    removeTrackEvent: function( id ) {
      Popcorn.removeTrackEvent.call( null, this, id );
      return this;
    },

    removePlugin: function( name ) {
      Popcorn.removePlugin.call( null, this, name );
      return this;
    }

  });

  //  Plugin manifests
  Popcorn.manifest = {};
  //  Plugins are registered
  Popcorn.registry = [];
  Popcorn.registryByName = {};
  //  An interface for extending Popcorn
  //  with plugin functionality
  Popcorn.plugin = function( name, definition, manifest ) {

    if ( Popcorn.protect.natives.indexOf( name.toLowerCase() ) >= 0 ) {
      Popcorn.error("'" + name + "' is a protected function name");
      return;
    }

    //  Provides some sugar, but ultimately extends
    //  the definition into Popcorn.p
    var reserved = [ "start", "end" ],
        plugin = {},
        setup,
        isfn = typeof definition === "function";

    //  If `manifest` arg is undefined, check for manifest within the `definition` object
    //  If no `definition.manifest`, an empty object is a sufficient fallback
    if ( !manifest ) {
      manifest = definition.manifest || {};
    }

    var pluginFn = function( setup, options ) {

      if ( !options ) {
        return this;
      }

      //  Storing the plugin natives
      options._natives = setup;
      options._natives.type = name;
      options._running = false;

      //  Ensure a manifest object, an empty object is a sufficient fallback
      options._natives.manifest = manifest;

      //  Checks for expected properties
      if ( !( "start" in options ) ) {
        options.start = 0;
      }

      if ( !( "end" in options ) ) {
        options.end = this.duration();
      }

      //  If a _setup was declared, then call it before
      //  the events commence
      if ( "_setup" in setup && typeof setup._setup === "function" ) {

        // Resolves 239, 241, 242
        if ( !options.target ) {

          //  Sometimes the manifest may be missing entirely
          //  or it has an options object that doesn't have a `target` property

          var manifestopts = "options" in manifest && manifest.options;

          options.target = manifestopts && "target" in manifestopts && manifestopts.target;
        }

        setup._setup.call( this, options );
      }

      Popcorn.addTrackEvent( this, options );

      //  Future support for plugin event definitions
      //  for all of the native events
      Popcorn.forEach( setup, function ( callback, type ) {

        if ( type !== "type" ) {

          if ( reserved.indexOf( type ) === -1 ) {

            this.listen( type, callback );
          }
        }

      }, this);

      return this;
    };

    //  Augment the manifest object
    if ( manifest || ( "manifest" in definition ) ) {
      Popcorn.manifest[ name ] = manifest || definition.manifest;
    }

    //  Assign new named definition
    plugin[ name ] = function( options ) {
      return pluginFn.call( this, isfn ? definition.call( this, options ) : definition,
                                  options );
    };

    //  Extend Popcorn.p with new named definition
    Popcorn.extend( Popcorn.p, plugin );

    //  Push into the registry
    var entry = {
      fn: plugin[ name ],
      definition: definition,
      base: definition,
      parents: [],
      name: name
    };
    Popcorn.registry.push(
       Popcorn.extend( plugin, entry, {
        type: name
      })
    );
    Popcorn.registryByName[ name ] = entry;

    return plugin;
  };

  //  Popcorn Plugin Inheritance Helper Methods
  //  Internal use only
  Popcorn.plugin.getDefinition = function( name ) {

    var registry = Popcorn.registryByName;
    
    if ( registry[ name ] ) {
      return registry[ name ];
    }

    Popcorn.error( "Cannot inherit from "+ name +"; Object does not exist" );
  };

  //  Internal use only
  Popcorn.plugin.delegate = function( instance, name, plugins ) {

    return function() {
      var args = arguments;
      plugins.forEach( function( plugin ) {
        // The new plugin simply calls the delegated methods on
        // all of its parents in the order they were specified.
        plugin[ name ] && plugin[ name ].apply( instance, args );
      });
    };
  };

  //  Plugin inheritance
  Popcorn.plugin.inherit = function( name, parents, definition, manifest ) {


    // Get the names of all of the ancestor classes, in the order that
    // we will be calling them. The override is for the class we're
    // currently defining, since it's not in the registry yet.
    var ancestors = [], 
        pluginFn, entry;

    function getAncestors( name, override ) {
      var parents = override || Popcorn.plugin.getDefinition( name ).parents;
      for ( var i in parents ) {
        if ( hasOwn.call( parents, i ) ) {
          var p = parents[ i ];
          getAncestors( p );
          if ( ancestors.indexOf( p ) === -1 ) {
            ancestors.push( p );
          }
        }
      }
    }

    getAncestors( name, Popcorn.isArray( parents ) ? parents : [ parents ] );
    ancestors.push( name );

    // Now create the requested plugin under the reqested name.
    pluginFn = Popcorn.plugin( name, function( options ) {

      var self = this, 
          plugins;

      function instantiate( definition ) {
        return definition.call && definition.call( self, options ) || definition;
      }

      // When the newly-defined plugin is instantiated, it must
      // explicitly instantiate all of its ancestors.
      plugins = ancestors.map( function( name ) {
        return instantiate( Popcorn.plugin.getDefinition( name ).base );
      });

      return {
        _setup: Popcorn.plugin.delegate( self, "_setup", plugins ),
        start: Popcorn.plugin.delegate( self, "start", plugins ),
        end: Popcorn.plugin.delegate( self, "end", plugins )
      };
      
    }, manifest || definition.manifest );

    entry = Popcorn.plugin.getDefinition( name );
    entry.base = definition;
    entry.parents = parents;

    return pluginFn;
  };

  // Augment Popcorn; 
  Popcorn.inherit = Popcorn.plugin.inherit;

  // stores parsers keyed on filetype
  Popcorn.parsers = {};

  // An interface for extending Popcorn
  // with parser functionality
  Popcorn.parser = function( name, type, definition ) {

    if ( Popcorn.protect.natives.indexOf( name.toLowerCase() ) >= 0 ) {
      Popcorn.error("'" + name + "' is a protected function name");
      return;
    }

    // fixes parameters for overloaded function call
    if ( typeof type === "function" && !definition ) {
      definition = type;
      type = "";
    }

    if ( typeof definition !== "function" || typeof type !== "string" ) {
      return;
    }

    // Provides some sugar, but ultimately extends
    // the definition into Popcorn.p

    var natives = Popcorn.events.all,
        parseFn,
        parser = {};

    parseFn = function ( filename, callback ) {

      if ( !filename ) {
        return this;
      }

      var that = this;

      Popcorn.xhr({
        url: filename,
        dataType: type,
        success: function( data ) {

          var tracksObject = definition( data ),
              tracksData,
              tracksDataLen,
              tracksDef,
              idx = 0;

          tracksData = tracksObject.data || [];
          tracksDataLen = tracksData.length;
          tracksDef = null;

          //  If no tracks to process, return immediately
          if ( !tracksDataLen ) {
            return;
          }

          //  Create tracks out of parsed object
          for ( ; idx < tracksDataLen; idx++ ) {

            tracksDef = tracksData[ idx ];

            for ( var key in tracksDef ) {

              if ( hasOwn.call( tracksDef, key ) && !!that[ key ] ) {

                that[ key ]( tracksDef[ key ] );
              }
            }
          }
          if ( callback ) {
            callback();
          }
        }
      });

      return this;
    };

    // Assign new named definition
    parser[ name ] = parseFn;

    // Extend Popcorn.p with new named definition
    Popcorn.extend( Popcorn.p, parser );

    // keys the function name by filetype extension
    //Popcorn.parsers[ name ] = true;

    return parser;
  };


  //  Cache references to reused RegExps
  var rparams = /\?/,
  //  XHR Setup object
  setup = {
    url: '',
    data: '',
    dataType: '',
    success: Popcorn.nop,
    type: 'GET',
    async: true,
    xhr: function()  {
      return new global.XMLHttpRequest();
    }
  };

  Popcorn.xhr = function ( options ) {

    options.dataType = options.dataType && options.dataType.toLowerCase() || null;
    
    if ( options.dataType &&
            ( options.dataType === "jsonp" ||
                options.dataType === "script" ) ) {

      Popcorn.xhr.getJSONP(
        options.url,
        options.success,
        options.dataType === "script"
      );
      return;
    }

    var settings = Popcorn.extend( {}, setup, options );

    //  Create new XMLHttpRequest object
    settings.ajax  = settings.xhr();

    if ( settings.ajax ) {

      if ( settings.type === "GET" && settings.data ) {

        //  append query string
        settings.url += ( rparams.test( settings.url ) ? "&" : "?" ) + settings.data;

        //  Garbage collect and reset settings.data
        settings.data = null;
      }


      settings.ajax.open( settings.type, settings.url, settings.async );
      settings.ajax.send( settings.data || null );

      return Popcorn.xhr.httpData( settings );
    }
  };


  Popcorn.xhr.httpData = function ( settings ) {

    var data, json = null;

    settings.ajax.onreadystatechange = function() {

      if ( settings.ajax.readyState === 4 ) {

        try {
          json = JSON.parse(settings.ajax.responseText);
        } catch(e) {
          //suppress
        }

        data = {
          xml: settings.ajax.responseXML,
          text: settings.ajax.responseText,
          json: json
        };

        //  If a dataType was specified, return that type of data
        if ( settings.dataType ) {
          data = data[ settings.dataType ];
        }


        settings.success.call( settings.ajax, data );

      }
    };
    return data;
  };

  Popcorn.xhr.getJSONP = function ( url, success, isScript ) {

    //  If this is a script request, ensure that we do not call something that has already been loaded
    if ( isScript ) {

      var scripts = document.querySelectorAll('script[src="' + url + '"]');

      //  If there are scripts with this url loaded, early return
      if ( scripts.length ) {

        //  Execute success callback and pass "exists" flag
        success && success( true );

        return;
      }
    }

    var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement,
      script = document.createElement("script"),
      paramStr = url.split("?")[1],
      isFired = false,
      params = [],
      callback, parts, callparam;

    if ( paramStr && !isScript ) {
      params = paramStr.split("&");
    }

    if ( params.length ) {
      parts = params[ params.length - 1 ].split("=");
    }

    callback = params.length ? ( parts[1] ? parts[1] : parts[0]  ) : "jsonp";

    if ( !paramStr && !isScript ) {
      url += "?callback=" + callback;
    }

    if ( callback && !isScript ) {

      //  If a callback name already exists
      if ( !!window[ callback ] ) {

        //  Create a new unique callback name
        callback = Popcorn.guid( callback );
      }

      //  Define the JSONP success callback globally
      window[ callback ] = function ( data ) {

        success && success( data );
        isFired = true;

      };

      //  Replace callback param and callback name
      url = url.replace( parts.join("="), parts[0] + "=" + callback );

    }

    script.onload = script.onreadystatechange = function() {

      if ( !script.readyState || /loaded|complete/.test( script.readyState ) ) {

        //  Handling remote script loading callbacks
        if ( isScript ) {

          //  getScript
          success && success();
        }

        //  Executing for JSONP requests
        if ( isFired ) {

          //  Garbage collect the callback
          delete window[ callback ];

          //  Garbage collect the script resource
          head.removeChild( script );
        }
      }
    };

    script.src = url;

    head.insertBefore( script, head.firstChild );

    return;
  };

  Popcorn.getJSONP = Popcorn.xhr.getJSONP;

  Popcorn.getScript = Popcorn.xhr.getScript = function( url, success ) {

    return Popcorn.xhr.getJSONP( url, success, true );
  };

  Popcorn.util = {
    // Simple function to parse a timestamp into seconds
    // Acceptable formats are:
    // HH:MM:SS.MMM
    // HH:MM:SS;FF
    // Hours and minutes are optional. They default to 0
    toSeconds: function( timeStr, framerate ) {
        //Hours and minutes are optional
        //Seconds must be specified
        //Seconds can be followed by milliseconds OR by the frame information
        var validTimeFormat = /^([0-9]+:){0,2}[0-9]+([.;][0-9]+)?$/,
            errorMessage = "Invalid time format";

        if ( typeof timeStr === "number" ) {
          return timeStr;
        } else if ( typeof timeStr === "string" ) {
          if ( ! validTimeFormat.test( timeStr ) ) {
            Popcorn.error( errorMessage );
          }
        } else {
          Popcorn.error( errorMessage );
        }

        var t = timeStr.split( ":" ),
            lastIndex = t.length - 1,
            lastElement = t[ lastIndex ];

        //Fix last element:
        if ( lastElement.indexOf( ";" ) > -1 ) {
          var frameInfo = lastElement.split( ";" ),
              frameTime = 0;

          if ( framerate && ( typeof framerate === "number" ) ) {
              frameTime = parseFloat( frameInfo[ 1 ], 10 ) / framerate;
          }

          t[ lastIndex ] =
            parseInt( frameInfo[ 0 ], 10 ) + frameTime;
        }

        if ( t.length === 1 ) {
          return parseFloat( t[ 0 ], 10 );
        } else if ( t.length === 2 ) {
          return ( parseInt( t[ 0 ], 10 ) * 60 ) + parseFloat( t[ 1 ], 10 );
        } else if ( t.length === 3 ) {
          return ( parseInt( t[ 0 ], 10 ) * 3600 ) +
                 ( parseInt( t[ 1 ], 10 ) * 60 ) +
                 parseFloat( t[ 2 ], 10 );
        }
    }
  };

  //  Exposes Popcorn to global context
  global.Popcorn = Popcorn;

  document.addEventListener( "DOMContentLoaded", function() {

    //  Supports non-specific elements
    var dataAttr = "data-timeline-sources",
        medias = document.querySelectorAll( "[" + dataAttr + "]" );

    Popcorn.forEach( medias, function( idx, key ) {

      var media = medias[ key ],
          hasDataSources = false,
          dataSources, data, popcornMedia;

      //  Ensure that the DOM has an id
      if ( !media.id ) {

        media.id = Popcorn.guid( "__popcorn" );

      }

      //  Ensure we're looking at a dom node
      if ( media.nodeType && media.nodeType === 1 ) {

        popcornMedia = Popcorn( "#" + media.id );

        dataSources = ( media.getAttribute( dataAttr ) || "" ).split(",");

        if ( dataSources[ 0 ] ) {

          Popcorn.forEach( dataSources, function( source ) {

            // split the parser and data as parser:file
            data = source.split( ":" );

            // if no parser is defined for the file, assume "parse" + file extension
            if ( data.length === 1 ) {

              data = source.split( "." );
              data[ 0 ] = "parse" + data[ data.length - 1 ].toUpperCase();
              data[ 1 ] = source;

            }

            //  If the media has data sources and the correct parser is registered, continue to load
            if ( dataSources[ 0 ] && popcornMedia[ data[ 0 ] ] ) {

              //  Set up the media and load in the datasources
              popcornMedia[ data[ 0 ] ]( data[ 1 ] );

            }
          });

        }

        //  Only play the media if it was specified to do so
        if ( !!popcornMedia.autoplay ) {
          popcornMedia.play();
        }

      }
    });
  }, false );

})(window, window.document);


</script>
		<script type="text/javascript">
(function( global, doc ) {
  Popcorn.baseplayer = function() {
    return new Popcorn.baseplayer.init();
  };

  Popcorn.baseplayer.init = function() {
    this.readyState = 0;
    this.currentTime = 0;
    this.duration = 0;
    this.paused = 1;
    this.ended = 0;
    this.volume = 1;
    this.muted = 0;
    this.playbackRate = 1;

    // These are considered to be "on" by being defined. Initialize to undefined
    this.autoplay;
    this.loop;
    
    // List of events
    this._events = {};
    
    // The underlying player resource. May be <canvas>, <iframe>, <object>, array, etc
    this._resource;
    // The container div of the resource
    this._container;
    
    this.offsetWidth = this.width = 0;
    this.offsetHeight = this.height = 0;
    this.offsetLeft = 0;
    this.offsetTop = 0;
    this.offsetParent;
  };

  Popcorn.baseplayer.init.prototype = {
    load: function() {},
    
    play: function() {
      this.paused = 0;
      this.timeupdate();
    },
    
    pause: function() {
      this.paused = 1;
    },
    
    timeupdate: function() {
      // The player was paused since the last time update
      if ( this.paused ) {
        return;
      }

      // So we can refer to the instance when setTimeout is run
      var self = this;
      this.currentTime += 0.015;
      
      this.dispatchEvent( "timeupdate" );
      setTimeout( function() {
        self.timeupdate.call( self );
      }, 15 );
    },
    
    // By default, assumes this.resource is a DOM Element
    // Changing the type of this.resource requires this method to be overridden
    getBoundingClientRect: function() {
      var b,
          self = this;
          
      if ( this._resource ) {
        b = this._resource.getBoundingClientRect();
        
        return {
          bottom: Math.ceil( b.bottom ),
          left: Math.ceil( b.left ),
          right: Math.ceil( b.right ),
          top: Math.ceil( b.top ),
          
          //  These not guaranteed to be in there
          width: b.width || ( b.right - b.left ),
          height: b.height || ( b.bottom - b.top )
        };
      } else {
        b = this._container.getBoundingClientRect();
        
        // Update bottom, right for expected values once the container loads
        return {
          left: b.left,
          top: b.top,
          width: self.offsetWidth,
          height: self.offsetHeight,
          bottom: b.top + this.width,
          right: b.top + this.height
        };
      }
    },
    
    // Add an event listener to the object
    addEventListener: function( evtName, fn ) {
      if ( !this._events[evtName] ) {
        this._events[evtName] = [];
      }
      
      this._events[evtName].push( fn );
      return fn;
    },
    
    // Can take event object or simple string
    dispatchEvent: function( oEvent ) {
      var evt,
          self = this,
          eventInterface,
          eventName = oEvent.type;
          
      // A string was passed, create event object
      if ( !eventName ) {
        eventName = oEvent;
        eventInterface  = Popcorn.events.getInterface( eventName );
        
        if ( eventInterface ) {
          evt = document.createEvent( eventInterface );
          evt.initEvent( eventName, true, true, window, 1 );
        }
      }
      
      Popcorn.forEach( this._events[eventName], function( val ) {
        val.call( self, evt, self );
      });
    },
    
    // Extracts values from container onto this object
    extractContainerValues: function( id ) {
      this._container = document.getElementById( id );
      
      if ( !this._container ) {
        return;
      }
      
      var bounds = this._container.getBoundingClientRect();
      
      this.offsetWidth = this.width = container.getAttribute( "width" ) || getStyle( "width" ) || 0;
      this.offsetHeight = this.height = container.getAttribute( "height" ) || getStyle( "height" ) || 0;
      this.offsetLeft = bounds.left;
      this.offsetTop = bound.top;
      this.offsetParent = this._container.offsetParent;
      
      return this._container;
    },
    
    // By default, assumes this.resource is a DOM Element
    // Changing the type of this.resource requires this method to be overridden
    // Returns the computed value for CSS style 'prop' as computed by the browser
    getStyle: function( prop ) {
      var elem = this._resource;
      
      if ( elem.currentStyle ) {
        // IE syntax
        return elem.currentStyle[prop];
      } else if ( global.getComputedStyle ) {
        // Firefox, Chrome et. al
        return doc.defaultView.getComputedStyle( elem, null ).getPropertyValue( prop );
      } else {
        // Fallback, just in case
        return elem.style[prop];
      }
    }
  };
})( window, document );

</script>
		<script type="text/javascript">
// PLUGIN: Code

(function (Popcorn) {

  /**
   * Code Popcorn Plug-in
   *
   * Adds the ability to run arbitrary code (JavaScript functions) according to video timing.
   *
   * @param {Object} options
   *
   * Required parameters: start, end, template, data, and target.
   * Optional parameter: static.
   *
   *   start: the time in seconds when the mustache template should be rendered
   *          in the target div.
   *
   *   end: the time in seconds when the rendered mustache template should be
   *        removed from the target div.
   *
   *   onStart: the function to be run when the start time is reached.
   *
   *   onFrame: [optional] a function to be run on each paint call
   *            (e.g., called ~60 times per second) between the start and end times.
   *
   *   onEnd: [optional] a function to be run when the end time is reached.
   *
   * Example:
     var p = Popcorn('#video')

        // onStart function only
        .code({
          start: 1,
          end: 4,
          onStart: function( options ) {
            // called on start
          }
        })

        // onStart + onEnd only
        .code({
          start: 6,
          end: 8,
          onStart: function( options ) {
            // called on start
          },
          onEnd: function ( options ) {
            // called on end
          }
        })

        // onStart, onEnd, onFrame
        .code({
          start: 10,
          end: 14,
          onStart: function( options ) {
            // called on start
          },
          onFrame: function ( options ) {
            // called on every paint frame between start and end.
            // uses mozRequestAnimationFrame, webkitRequestAnimationFrame,
            // or setTimeout with 16ms window.
          },
          onEnd: function ( options ) {
            // called on end
          }
        });
  *
  */

  Popcorn.plugin( 'code' , function(options) {
    var running = false;
  
    // Setup a proper frame interval function (60fps), favouring paint events.
    var step = ( function() {
    
      var buildFrameRunner = function( runner ) {
        return function( f, options ) {
    
          var _f = function() {
            f();
            if ( running ) {
              runner( _f );
            }
          };
    
          _f();
        };
      };
    
      // Figure out which level of browser support we have for this
      if ( window.webkitRequestAnimationFrame ) {
        return buildFrameRunner( window.webkitRequestAnimationFrame );
      } else if ( window.mozRequestAnimationFrame ) {
        return buildFrameRunner( window.mozRequestAnimationFrame );
      } else {
        return buildFrameRunner( function( f ) {
          window.setTimeout( f, 16 );
        } );
      }
    
    } )();

    if ( !options.onStart || typeof options.onStart !== 'function' ) {
      throw 'Popcorn Code Plugin Error: onStart must be a function.';
    }

    if ( options.onEnd && typeof options.onEnd !== 'function' ) {
      throw 'Popcorn Code Plugin Error: onEnd  must be a function.';
    }

    if ( options.onFrame && typeof options.onFrame !== 'function' ) {
      throw 'Popcorn Code Plugin Error: onFrame  must be a function.';
    }

    return {
      start: function( event, options ) {
        options.onStart( options );

        if ( options.onFrame ) {
          running = true;
          step( options.onFrame, options );
        }
      },

      end: function( event, options ) {
        if ( options.onFrame ) {
          running = false;
        }

        if ( options.onEnd ) {
          options.onEnd( options );
        }
      }
    };
  },
  {
    about: {
      name: 'Popcorn Code Plugin',
      version: '0.1',
      author: 'David Humphrey (@humphd)',
      website: 'http://vocamus.net/dave'
    },
    options: {
      start: {elem:'input', type:'text', label:'In'},
      end: {elem:'input', type:'text', label:'Out'},
      // TODO: how to deal with functions, eval strings?
      onStart: {elem:'input', type:'text', label:'onStart'},
      onFrame: {elem:'input', type:'text', label:'onFrame'},
      onEnd: {elem:'input', type:'text', label:'onEnd'}
    }
  });
})( Popcorn );

</script>
    <script type="text/javascript">
function AudioEngine ( audioData, updateFunction ) {

  var modPlayer;
  var playing = false;
  var channels = 2;	//stereo
  var sampleRate = 44100;
  var bufferSize = 2048 * channels; 
  var prebufferSize = 12 * channels * 1024; // defines the latency
  var outputAudio = new Audio();
  var currentWritePosition = 0;
  var lastSampleOffset = 0;

  this.audioObject = outputAudio;

  function play() {
    playing = true;
  }; //play

  function stop() {
    playing = false;
  }; //stop

  function writeAudio() {
    if (!playing) { return; }
    var currentSampleOffset = outputAudio.mozCurrentSampleOffset();
    var playHasStopped = currentSampleOffset == lastSampleOffset; // if audio stopped playing, just send data to trigger it to play again.
    while (currentSampleOffset + prebufferSize >= currentWritePosition || playHasStopped ) {
      // generate audio
      var audioData = modPlayer.getSamples(bufferSize);

      // write audio	
      var written = outputAudio.mozWriteAudio(audioData);
      currentWritePosition += written;	//portionSize;
      currentSampleOffset = outputAudio.mozCurrentSampleOffset();
      playHasStopped = 0;
      updateFunction(audioData);
      if (written < audioData.length) { // firefox buffer is full, stop writing
        return;
      }
    }
    lastSampleOffset = outputAudio.mozCurrentSampleOffset();

  }; //writeAudio

  function loadEmbedded() {
    var t = atob(audioData);
    var ff = [];
    var mx = t.length;
    var scc= String.fromCharCode;
    for (var z = 0; z < mx; z++) {
      ff[z] = scc(t.charCodeAt(z) & 255);
    }
    var binString = ff.join("");
      
    var modFile = new ModFile(binString);
    modPlayer = new ModPlayer(modFile, 44100);
    play();
  }; //loadEmbedded

  function loadRemote(path) {
    var fetch = new XMLHttpRequest();
    fetch.open('GET', path);
    fetch.overrideMimeType("text/plain; charset=x-user-defined");
    fetch.onreadystatechange = function() {
      if(this.readyState == 4) {
        /* munge response into a binary string */
        var t = this.responseText || "" ;
        var ff = [];
        var mx = t.length;
        var scc= String.fromCharCode;
        for (var z = 0; z < mx; z++) {
          ff[z] = scc(t.charCodeAt(z) & 255);
        }
        var binString = ff.join("");
      
        var modFile = new ModFile(binString);
        modPlayer = new ModPlayer(modFile, 44100);
        play();
      }
    }
    fetch.send();
  }; //loadRemote

  this.playMod = function (modFileName) {
    if (outputAudio.mozSetup) {
      outputAudio.mozSetup(2, sampleRate);
      writeAudio();
      var writeInterval = Math.floor(1000 * bufferSize / sampleRate);
      setInterval(writeAudio, writeInterval);
    } //if

    if (audioData) {
      loadEmbedded();
    }
    else {
      loadRemote(modFileName);
    } //if
  };

}; //ModPlayer

</script>
    <script type="text/javascript">
/*
 *  bitFont.js
 *  vis_testbed
 *
 *  Created by Charles J. Cliffe on 2002-6-22.
 *  Copyright 2009 Cubic Productions. All rights reserved.
 *
 *  Ported to javascript by Corban Brook 2010-06-07
 *
 */

var NULL_CHAR = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

// [256][64]
var bitFont = [
	NULL_CHAR, // 0
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 5
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 10
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 15
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 20
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //25
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR,//30
	NULL_CHAR,
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], //SPACE
	
	[
		0,0,1,0,0,0,0,0,
		0,1,1,1,0,0,0,0,
		0,1,1,1,0,0,0,0,
		0,1,1,1,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,0,0,0,0,0
	], // !
	
	[
		0,0,1,0,1,0,0,0,
		0,0,1,0,1,0,0,0,
		0,0,1,0,1,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // "
	
	[
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0
	], // #			//35
	
	[
		0,0,0,1,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,0,1,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,0,1,0,0,
		0,0,0,1,0,1,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,0,0,0,0
	], // $
	
	[
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,1,0,0,
		0,0,0,0,1,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,0,0,1,1,0,
		0,1,0,0,0,1,1,0,
		0,0,0,0,0,0,0,0
	], // %
	
	[
		0,0,0,1,0,0,0,0,
		0,0,1,0,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,0,0,1,0,0,0,
		0,1,0,0,1,1,1,0,
		0,1,0,0,1,0,0,1,
		0,0,1,1,0,0,0,0
	], // &
	
	[
		0,1,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,1,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // '
	
	[
		0,0,0,0,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,0,1,0,0,0
	], // (			//40
	
	[
		0,1,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,0,0,0,0,0,0
	], // )
	
	[
		0,1,0,1,0,1,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,1,1,1,0,0,0,
		0,1,0,1,0,1,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // *
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // +
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // ,
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // -			//45
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // .
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,1,
		0,0,0,0,0,0,1,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,1,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,1,0,0,0,0,0,0
	], // /
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,1,0,0,1,1,0,
		0,0,1,0,1,0,1,0,
		0,0,1,0,1,0,1,0,
		0,0,1,1,0,0,1,0,
		0,0,1,1,0,1,1,0,
		0,0,0,1,1,1,0,0
	], // 0
	
	[
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,1,1,0
	], // 1
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,1,1,1,1,0,
		0,0,1,1,1,1,1,0
	], // 2			//50
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,0,1,1,1,0,0
	], // 3
	
	[
		0,0,0,0,1,1,0,0,
		0,0,1,0,1,1,0,0,
		0,0,1,0,1,1,0,0,
		0,0,1,0,1,1,0,0,
		0,0,1,0,1,1,0,0,
		0,0,1,1,1,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0
	], // 4
	
	[
		0,0,1,1,1,1,1,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,1,0,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,0,1,1,1,0,0
	], // 5
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,0,1,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,0,1,0,
		0,0,1,1,0,0,1,0,
		0,0,1,1,0,0,1,0,
		0,0,0,1,1,1,0,0
	], // 6
	
	[
		0,0,1,1,1,1,1,0,
		0,0,1,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // 7			//55
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // 8
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // 9
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // :
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,0,0,0,0,0
	], // ;
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,1,0,0
	], // <			//60
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,0,0,0,0,0
	], // =
	
	[
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // >
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0
	], // ?
	
	[
		0,0,1,1,1,1,0,0,
		0,1,0,0,0,0,1,0,
		0,1,0,1,1,0,1,0,
		0,1,1,0,1,0,1,0,
		0,1,1,0,1,0,1,0,
		0,1,0,1,1,1,0,0,
		0,1,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0
	], // @
	
	[
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // A			//65
	
	[
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0
	], // B
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // C
	
	[
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0
	], // D
	
	[
		0,1,1,1,1,1,1,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,1,1,1,1,0
	], // E
	
	[
		0,1,1,1,1,1,1,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // F			//70
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // G
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // H
	
	[
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0
	], // I
	
	[
		0,1,1,1,1,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,0,0,0
	], // J
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,1,1,0,0,
		0,1,1,1,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // K			//75
	
	[
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,1,0,
		0,1,1,1,1,1,1,0
	], // L
	
	[
		0,1,1,0,0,0,1,1,
		0,1,1,1,0,1,1,1,
		0,1,1,1,0,1,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,0,0,0,1,1,
		0,1,1,0,0,0,1,1,
		0,1,1,0,0,0,1,1
	], // M
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,0,1,1,0,
		0,1,1,1,0,1,1,0,
		0,1,1,1,1,1,1,0,
		0,1,1,0,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // N
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // O
	
	[
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // P			//80
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,1,1,1,0,
		0,1,1,0,0,1,0,0,
		0,0,1,1,1,0,1,0
	], // Q
	
	[
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // R
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,1,0,0,
		0,0,0,0,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // S
	
	[
		0,1,1,1,1,1,1,0,
		0,1,1,1,1,1,1,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // T
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0
	], // U			//85
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // V
	
	[
		0,1,1,0,0,0,1,1,
		0,1,1,0,0,0,1,1,
		0,1,1,0,0,0,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,1,0,1,1,1,
		0,0,1,1,0,1,1,0
	], // W
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // X
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // Y
	
	[
		0,1,1,1,1,1,1,0,
		0,1,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,1,0,
		0,1,1,1,1,1,1,0
	], // Z			//90
	
	[
		0,0,1,1,1,1,1,0,
		0,0,1,1,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,1,1,0
	], // [
	
	[
		0,1,0,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,0,1,0
	], 
	
	[
		0,1,1,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,1,1,0,0,
		0,1,1,1,1,1,0,0
	], // ]
	
	[
		0,0,0,0,1,0,0,0,
		0,0,0,1,0,1,0,0,
		0,0,1,0,0,0,1,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // ^
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,1,1
	], // 0			//95
	
	[
		0,0,0,0,1,1,1,0,
		0,0,0,0,1,1,1,0,
		0,0,0,0,0,0,1,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // '
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0
	], // a
	
	[
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // b
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,1,1,0,0
	], // c 
	
	[
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0
	], // d			//100
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,1,0,0,0
	], // e
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,1,1,0,0,0
	], // f
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,1,1,1,0,0,0
	], // g
	
	[
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0
	], // h
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0 
	], // i			//105
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0
	], // j
	
	[
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0
	], // k
	
	[
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0
	], // l
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,1,0,1,0,
		0,1,1,0,1,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0
	], // m
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,1,0,0,
	], // n			//110
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // o
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0
	], // p
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,1,0
	], // q
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // r
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,1,1,1,0,0,0
	], // s			//115
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,0,0,0
	], // t
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,1,0
	], // u
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,0,0,0,0
	], // v
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,1,0,1,0,
		0,1,1,0,1,0,1,0,
		0,0,1,1,1,1,0,0
	], // w
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0
	], // x			//120
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,0,0,0
	], // y
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,1,1,1,0,0,
		0,0,1,1,1,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,1,0,0,0,0,
		0,1,1,1,1,1,0,0
	], // z
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,0,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,0,1,1,1,0,0
	], // [
	
	[
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // |
	
	[
		0,1,1,1,0,0,0,0,
		0,0,0,0,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,0,0,0,
		0,1,1,1,0,0,0,0
	], // ]			//125
	
	[
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,0,0,1,0,1,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // ~
	
	NULL_CHAR, //	127
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 130
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 135
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 140
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 145
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 150
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 155
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 160
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 165
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 170
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 175
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 180
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //185
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //190
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 195
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 200
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 205
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 210
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //215
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //220
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //225
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //230
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //235
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //240
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //245
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //250
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR //255
];

</script>
    <script type="text/javascript">
function bitFont3D(elementSource_in,material,uvmapper) {
  this.element_size = 1.0/8.0;
  this.elementSource = null;
  this.trans = new CubicVR.Transform();
  this.chars = [];
  this.material = new CubicVR.Material();
  
  this.genString = function (str_in) {
      var letters = [];
      var strlen = str_in.length;
      var spacing = 0.75;
      var ofs = -strlen / 2.0 * spacing;

      textObj = new CubicVR.SceneObject(null);

      for (var i = 0; i < strlen; i++) {
          var fontObj = new CubicVR.SceneObject({
              mesh: this.chars[str_in.charCodeAt(i)],
              position: [ofs + i * spacing, 0, 0],
              scale: [1, 1, 1]
          });

          textObj.bindChild(fontObj);
      }

      return textObj;
  }
  
  
  this.getElementSize = function() {
    return this.element_size;
  };
  
  this.setElementSource = function(obj_in) {
    this.elementSource = obj_in;
  }
  
  this.setElement = function(type_str,material,uvmapper,undef) {
    if (type_str === "box") {
      this.elementSource =  CubicVR.primitives.box({size:this.element_size,material:material?material:this.material,uvmapper:uvmapper?uvmapper:undef});
    } else if (type_str === "sphere") {
      this.elementSource =  CubicVR.primitives.sphere({radius:this.element_size/2.0,lon:10,lat:5,material:material?material:this.material,uvmapper:uvmapper?uvmapper:undef});
    } else {
      alert("unknown bf3d element type: "+type_str);
    }
  }
  
  this.genLetterMesh = function(lnum) {
    var bf = bitFont[lnum];
    trans = this.trans;

    var c = 0;
    for (var i = 0; i<64; i++) { c+=bf[i]; }
    if (!c) {
      return null;
    }

    var dest = new CubicVR.Mesh();

    for (var i = 0; i<8; i++) {
      for (var j = 0; j<8; j++) {
        var idx = j*8+i;

        if (bf[idx]===1) {
          trans.clearStack();
          trans.translate([-this.element_size*4.0+i*this.element_size,-this.element_size*4.0+(8-j)*this.element_size,0]);

          dest.booleanAdd(this.elementSource,trans);
        }
      }
    }

    return dest;
  }

  this.loadFont = function() {
    for (var i = 0; i < 255; i++) {
      this.chars[i] = this.genLetterMesh(i);
      
      // apply any material stuff here..
      
      if (this.chars[i]) {
        this.chars[i].triangulateQuads().calcNormals().compile().clean();
      }
    }
  }

  // if (typeof(elementSource_in) === 'object') {
  //   this.elementSource = elementSource_in;
  // } else if (typeof(elementSource_in) === 'string') {
    elementSource_in = this.setElement(elementSource_in,material,uvmapper);
  // }
}


</script>
    <script type="text/javascript">
function AnimationKit() {

    this.transition = function (start_time, distance, totaltime, sceneObj, anim_method, in_out) {

        if (!in_out) in_out = "in";
        if (!sceneObj.children) return;

        var nchild = sceneObj.children.length;

        if (anim_method === "spiral") {            
            for (var j = 0; j < nchild; j++) {
                if (!sceneObj.children[j].motion) sceneObj.children[j].motion = new CubicVR.Motion();
                var mot = sceneObj.children[j].motion;
                var spintotal = 360.0 * 1.5;
                var spinstep = (360.0 / 5.0);
                var spincount = (spintotal / spinstep);
                var ystep = distance / spincount;
                var ypos = distance;

                var t;
                var tofs = 0.1 * j;
                var c = 0;
                
                if (in_out == "in") {
                  for (i = 0; i < spintotal - spinstep; i += spinstep) {
                      t = (c / spincount) * totaltime + start_time + tofs;

                      mot.setKey(0, 0, t, distance * (1.0 - c / spincount) * Math.sin(i * (180.0 / Math.PI)));
                      mot.setKey(0, 1, t, ypos);
                      mot.setKey(0, 2, t, distance * (1.0 - c / spincount) * Math.cos(i * (180.0 / Math.PI)));

                      mot.setKey(1, 0, t, i + tofs);
                      mot.setKey(1, 2, t, -i + tofs);
                      ypos -= ystep;
                      c++;
                  }

                  t = start_time + totaltime + tofs;

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;
                } 
                else { // end: if in
                  mot.setKey(0, 0, start_time, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, start_time, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, start_time, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, start_time, 0).tension=1.0;
                  mot.setKey(1, 2, start_time, 0).tension=1.0;

                  ypos = 0;

                  for (i = spinstep; i < spintotal; i += spinstep) {
                      t = 1.0+(c / spincount) * totaltime + start_time + tofs;

                      mot.setKey(0, 0, t, distance * (c / spincount) * Math.sin(i+90 * (180.0 / Math.PI)));
                      mot.setKey(0, 1, t, ypos);
                      mot.setKey(0, 2, t, distance * (c / spincount) * Math.cos(i+90 * (180.0 / Math.PI)));

                      mot.setKey(1, 0, t, i + tofs);
                      mot.setKey(1, 2, t, -i + tofs);
                      ypos += ystep;
                      c++;
                  }
                } // end: if out
            } // end: for (j)

        } // end: anim method 'spiral'
        if (anim_method === "spiral2") {            
            for (var j = 0; j < nchild; j++) {
                if (!sceneObj.children[j].motion) sceneObj.children[j].motion = new CubicVR.Motion();
                var mot = sceneObj.children[j].motion;
                var spintotal = 360.0 * 1.5;
                var spinstep = (360.0 / 5.0);
                var spincount = (spintotal / spinstep);
                var ystep = distance / spincount;
                var ypos = distance;

                var t;
                var tofs = 0.05 * j;
                var c = 0;
                
                if (in_out == "in") {
                  for (i = 0; i < spintotal - spinstep; i += spinstep) {
                      t = (c / spincount) * totaltime + start_time + tofs;

                      mot.setKey(0, 0, t, (1.0 - c / spincount)*sceneObj.children[j].position[0]+distance * (1.2 - c / spincount) * Math.sin(i * (180.0 / Math.PI)));
                      mot.setKey(0, 1, t, (1.0 - c / spincount)*sceneObj.children[j].position[1]+ypos);
                      mot.setKey(0, 2, t, (1.0 - c / spincount)*sceneObj.children[j].position[2]+distance * (1.2 - c / spincount) * Math.cos(i * (180.0 / Math.PI)));

                      mot.setKey(1, 0, t, i + tofs);
                      mot.setKey(1, 2, t, -i + tofs);
                      ypos -= ystep;
                      c++;
                  }

                  t = start_time + totaltime + tofs;

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;
                } 
                else { // end: if in
                  mot.setKey(0, 0, start_time, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, start_time, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, start_time, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, start_time, 0).tension=1.0;
                  mot.setKey(1, 2, start_time, 0).tension=1.0;

                  ypos = 0;

                  for (i = spinstep; i < spintotal; i += spinstep) {
                      t = 1.0+(c / spincount) * totaltime + start_time + tofs;

                      mot.setKey(0, 0, t, (1.0 - c / spincount)*sceneObj.children[j].position[0]+distance * (c / spincount) * Math.sin(i+90 * (180.0 / Math.PI)));
                      mot.setKey(0, 1, t, (1.0 - c / spincount)*sceneObj.children[j].position[1]+ypos);
                      mot.setKey(0, 2, t, (1.0 - c / spincount)*sceneObj.children[j].position[2]+distance * (c / spincount) * Math.cos(i+90 * (180.0 / Math.PI)));

                      mot.setKey(1, 0, t, i + tofs);
                      mot.setKey(1, 2, t, -i + tofs);
                      ypos += ystep;
                      c++;
                  }
                } // end: if out
            } // end: for (j)

        } // end: anim method 'spiral2'        
        if (anim_method === "random") {
            for (var j = 0; j < nchild; j++) {
                if (!sceneObj.children[j].motion) sceneObj.children[j].motion = new CubicVR.Motion();
                var mot = sceneObj.children[j].motion;
               var t;
                
                if (in_out==="in") {
                  for (i = 0; i < totaltime-totaltime / 5.0; i += totaltime / 5.0) {
                      t = start_time + i;

                      mot.setKey(0, 0, t, (Math.random() - 0.5) * distance);
                      mot.setKey(0, 1, t, (Math.random() - 0.5) * distance);
                      mot.setKey(0, 2, t, (Math.random() - 0.5) * distance);

                      mot.setKey(1, 0, t, (Math.random()) * 360);
                      mot.setKey(1, 2, t, (Math.random()) * 360);
                  }

                  t = start_time + totaltime

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;
                } else {  // end: if 'in'
                  
                  mot.setKey(0, 0, start_time, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, start_time, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, start_time, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, start_time, 0).tension=1.0;
                  mot.setKey(1, 2, start_time, 0).tension=1.0;

                  for (i = 1; i < totaltime; i += totaltime / 5.0) {
                      t = start_time + i;

                      mot.setKey(0, 0, t, (Math.random() - 0.5) * distance);
                      mot.setKey(0, 1, t, (Math.random() - 0.5) * distance);
                      mot.setKey(0, 2, t, (Math.random() - 0.5) * distance);

                      mot.setKey(1, 0, t, (Math.random()) * 360);
                      mot.setKey(1, 2, t, (Math.random()) * 360);
                  }
                  
                  t = start_time+totaltime+totaltime/5.0;

                  var r = CubicVR.vec3.normalize([(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0]);
                  mot.setKey(0, 0, t, distance*r[0]);
                  mot.setKey(0, 1, t, distance*r[1]);
                  mot.setKey(0, 2, t, distance*r[2]);
                  mot.setKey(1, 0, t, Math.random()*360.0);
                  mot.setKey(1, 2, t, Math.random()*360.0);

                } // end: if 'out'
            } // end: for (j)
        } // end: anim method 'random'
        if (anim_method === "explode") {
            for (var j = 0; j < nchild; j++) {
                if (!sceneObj.children[j].motion) sceneObj.children[j].motion = new CubicVR.Motion();
                var mot = sceneObj.children[j].motion;
               var t;
                
                if (in_out==="in") {
                  t = start_time;

                  var r = CubicVR.vec3.normalize([(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0]);
                  mot.setKey(0, 0, t, distance*r[0]);
                  mot.setKey(0, 1, t, distance*r[1]);
                  mot.setKey(0, 2, t, distance*r[2]);

                  mot.setKey(1, 0, t, (Math.random()) * 360);
                  mot.setKey(1, 2, t, (Math.random()) * 360);

                  mot.setKey(1, 0, start_time+totaltime/2.0, (Math.random()) * 360);
                  mot.setKey(1, 2, start_time+totaltime/2.0, (Math.random()) * 360);

                  t = start_time + totaltime

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;

                } else {  // end: if 'in'
                  t = start_time;

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;

                  mot.setKey(1, 0, start_time+totaltime/2.0, Math.random()*360.0);
                  mot.setKey(1, 2, start_time+totaltime/2.0, Math.random()*360.0);

                  t = start_time+totaltime;

                  var r = CubicVR.vec3.normalize([(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0]);
                  mot.setKey(0, 0, t, distance*r[0]);
                  mot.setKey(0, 1, t, distance*r[1]);
                  mot.setKey(0, 2, t, distance*r[2]);
                  mot.setKey(1, 0, t, Math.random()*360.0);
                  mot.setKey(1, 2, t, Math.random()*360.0);

                } // end: if 'out'
            } // end: for (j)
        } // end: anim method 'explode'
 
    }
}

</script>
    <script type="text/javascript">
function Segment (options) {
  this.active = false;
  this.startTime = options.startTime || 0;
  this.update = options.update || function (timer) {};
  this.updateFunction = function (timer) {
    if (this.active) {
      this.update(timer);
    } //if
  };
  this.prepare = options.prepare || function (prepareOptions) {};
  this.load = options.load || function () {};
  this.unload = options.unload || function () {};
}; //Segment

var SegmentList = new function () {
  this.segments = [];
  this.currentSegment = undefined;

  this.addSegment = function (segment) {
    this.segments.push(segment);
  };

  this.updateSegments = function (timer) {
    for (var i=0, l=this.segments.length; i<l; ++i) {
      this.segments[i].updateFunction(timer);
    } //for
  };

  this.prepareSegments = function (options) {
    for (var i=0, l=this.segments.length; i<l; ++i) {
      this.segments[i].prepare(options);
    } //for
  };

  this.nextSegment = function (lastSceneTimeout) {
    lastSegment = this.currentSegment;

    if (this.currentSegment === undefined) {
      this.currentSegment = this.segments[0];
    }
    else {
      this.currentSegment = this.segments[this.segments.indexOf(this.currentSegment)+1];
    } //if

    this.currentSegment.load();
    this.currentSegment.active = true;

    if (lastSegment) {
      var time = lastSceneTimeout || 0;
      setTimeout(function () {
        lastSegment.active = false;
        lastSegment.unload();
      }, time);
    } //if
  };

}; //SegmentList

</script>
    <script type="text/javascript">
SegmentList.addSegment(function () {

  var audioEngine, audioBuffer, fft, popcorn;
  var scene, animKit, bf3d, bfMaterial, targetFOV = 80, cameraTarget;
  var dateTextObjects = [], dirLight, spotLights = [];
  var currentSeconds;

  function moveCameraTarget(startTime, duration, destination) {
    var mot = cameraTarget.motion;
    var p = cameraTarget.position;
    var d = destination;
    mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, startTime, p[0]).tension = 1;
    mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, startTime, p[1]).tension = 1;
    mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Z, startTime, p[2]).tension = 1;
    mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, startTime+duration, d[0]).tension = 1;
    mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, startTime+duration, d[1]).tension = 1;
    mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Z, startTime+duration, d[2]).tension = 1;
    mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
    mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
    mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.Z, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
  }; //moveCameraTarget

  function makeCylinderLathe(mesh, height, inner_radius, outer_radius, res, material, uvmapper) {
    var pointList = new Array();
    var thick = outer_radius-inner_radius;
    var radius = inner_radius+(thick)/2.0;
    var transform;

    pointList.push([inner_radius, 0, 0]);
    pointList.push([inner_radius+thick, 0, 0]);
    pointList.push([inner_radius+thick, height, 0]);
    pointList.push([inner_radius, height, 0]);
    pointList.push([inner_radius, 0, 0]);

    CubicVR.genLatheObject(mesh, pointList, res, material, transform, uvmapper);
  };

  var floorUV = {
    projectionMode: CubicVR.enums.uv.projection.SPHERICAL,
    projectionAxis: CubicVR.enums.uv.axis.Y,
    scale: [1, 1, 1]
  };
  
  var SOUND_FLOOR_RINGS = 25,
      SOUND_FLOOR_Y = -5.5,
      SOUND_FLOOR_H = 2.0,
      SOUND_FLOOR_SPACING = 0.35,
      MAX_WIDTH = 45;

  var soundFloorRings = [];
  var soundFloorRingParent = new CubicVR.SceneObject(new CubicVR.Mesh());

  var floorBumpTexture, floorNormalTexture, floorMaterial,
      floorShapeMode = 0, floorColorMode = 0;

  function updateSoundFloor(seconds) {
    for (var i=0; i<SOUND_FLOOR_RINGS; ++i) {
      var ring = soundFloorRings[i];
      var v = ring.material.color[0];
      if (floorShapeMode === 0) {
        var newY = ring.baseY + fft.spectrum[2*(i)] * 40;
        if (ring.targetY < newY) {
          ring.targetY = newY;
          v = fft.spectrum[2*i] * 50;
        } //if
        ring.targetY = Math.max(ring.targetY - 0.1, ring.baseY);
      } //if
      if (floorColorMode === 0) {
        v = Math.min(0.5, v-0.05);
      }
      else if (floorColorMode === 1) {
        v = Math.max(0.5, v-0.05);
      }
      else if (floorColorMode === 2) {
        v = 1.0;
      } //if

      ring.position[1] -= (ring.position[1] - ring.targetY)*.25;
      ring.material.color = [Math.min(1, v*(Math.sin(seconds)*.5 + 1)*.9), Math.min(1, v*(Math.sin(seconds-1)*.5 + 1)*.9), Math.min(1, v*(Math.sin(seconds-2)*.5 + 1)*.9)];
      if (floorShapeMode === 0) {
        ring.rotation[1] = Math.sin(seconds + (SOUND_FLOOR_RINGS-i)*0.1)*120;
      }
      else {
        ring.rotation[1] = seconds * 100 + 30*i;
      } //if
    } //for
    if (floorShapeMode === 1) {
      floorBumpTexture.update();
      floorNormalTexture.update();
    } //if
  }; //updateSoundFloor

  return new Segment({
    prepare: function (options) {

      audioEngine = options.audioEngine;
      popcorn = options.popcorn;
      scene = options.scene;
      animKit = new AnimationKit();

      var spotLight;

      spotLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.SPOT_SHADOW,
        specular: [0.4,0.4,0.4],
        diffuse: [1,1,1],
        intensity: .2,
        distance: 100,
        cutoff: 50,
        map_res: 1024,
        position: [-7,10,-5]
      });

      spotLight.lookat([0,0,0]);
      scene.bindLight(spotLight);
      spotLights.push(spotLight);

      spotLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.SPOT_SHADOW,
        specular: [0.4,0.4,0.4],
        diffuse: [1,1,1],
        intensity: .3,
        distance: 100,
        cutoff: 300,
        map_res: 1024,
        position: [0, 8, 0],
      });

      spotLight.lookat([-2, 0, -4]);
      scene.bindLight(spotLight);
      spotLights.push(spotLight);

      cameraTarget = new CubicVR.SceneObject(null);
      cameraTarget.motion = new CubicVR.Motion();
      cameraTarget.position = [0, 1, 0];

      scene.bindSceneObject(cameraTarget);

      dateTextObjects[0] = new CubicVR.SceneObject(CubicVR.primitives.plane({
        size: 8.0,
        material: new CubicVR.Material({
          textures: {
            color: new CubicVR.TextTexture('June', {font:'200pt Arial'}),
          }
        }),
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.PLANAR,
          projectionAxis: CubicVR.enums.uv.axis.Z,
          scale: [1.2, 1.2, 1.2],
        },
      }).triangulateQuads().compile().clean());

      dateTextObjects[1] = new CubicVR.SceneObject(CubicVR.primitives.plane({
        size: 8.0,
        material: new CubicVR.Material({
          textures: {
            color: new CubicVR.TextTexture('18', {font:'200pt Arial'}),
          }
        }),
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.PLANAR,
          projectionAxis: CubicVR.enums.uv.axis.Z,
          scale: [1.2, 1.2, 1.2],
        },
      }).triangulateQuads().compile().clean());

      bfMaterial = new CubicVR.Material({
        color: [0.8,0.3,0.2],
        specular: [1, 5, 0],
        shininess: 0.9,
        textures: {
          envsphere: new CubicVR.CanvasTexture(document.getElementById("img/fract_reflections.jpg"))
        }
      });
        
      var bfUV = new CubicVR.UVMapper({
        projectionMode: CubicVR.enums.uv.projection.CUBIC,
        scale: [1, 1, 1]
      });

      bf3d = new bitFont3D("box", bfMaterial, bfUV);
      bf3d.loadFont();

      floorBumpTexture = new CubicVR.CanvasTexture({
        update: function (canvas, ctx) {
          for (var i=0; i<10; ++i) {
            var radius = Math.round(Math.random()*3);
            ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#000000';
            ctx.beginPath();
            ctx.arc(Math.floor(Math.random()*256), Math.floor(Math.random()*256), radius, 0, Math.PI*2, true);
            ctx.fill();
          } //for
        },
        width: 256,
        height: 256,
      });

      floorNormalTexture = new CubicVR.NormalMapGen(floorBumpTexture, 256, 256);

      floorMaterial = new CubicVR.Material({
        color: [0.3, 0.3, 0.3],
        textures: {
          bump: floorBumpTexture,
          normal: floorNormalTexture,
        },
        opacity: 1,
      });

      for (var i=0; i<SOUND_FLOOR_RINGS; ++i) {
        var floorMaterial = new CubicVR.Material({
          color: [0.3, 0.3, 0.3],
          textures: {
            bump: floorBumpTexture,
            normal: floorNormalTexture,
          },
          opacity: 1,
        });
        var soundFloorMesh = new CubicVR.Mesh();
        makeCylinderLathe(soundFloorMesh, SOUND_FLOOR_H, i*MAX_WIDTH/SOUND_FLOOR_RINGS, (i+1)*MAX_WIDTH/SOUND_FLOOR_RINGS-SOUND_FLOOR_SPACING, 3, floorMaterial, floorUV);
        soundFloorMesh.triangulateQuads().compile().clean();
        var soundFloorObject = new CubicVR.SceneObject(soundFloorMesh);
        soundFloorRingParent.bindChild(soundFloorObject);
        soundFloorRings.push(soundFloorObject);
        soundFloorObject.targetY = SOUND_FLOOR_Y + i/2.9;
        soundFloorObject.baseY = SOUND_FLOOR_Y + i/2.9;
        soundFloorObject.rotation[1] = 3*i;
        soundFloorObject.material = floorMaterial;
      } //for

      popcorn.code({
        start: 1,
        end: 11,
        onStart: function (options) {
          var bfStrs = [bf3d.genString('#audio'), bf3d.genString("welcomes you")];
          bfStrs[0].scale = [1.5, 1.5, 1.5];
          bfStrs[0].position[1] = 1.5;
          animKit.transition(currentSeconds, 5, 3, bfStrs[0], "spiral2");
          animKit.transition(currentSeconds, 5, 3, bfStrs[1], "spiral");
          options.bfStrs = bfStrs;
          scene.bindSceneObject(bfStrs[0]);
          scene.bindSceneObject(bfStrs[1]);
        },
        onEnd: function (options) {
          animKit.transition(currentSeconds, 20, 3, options.bfStrs[0], 'explode', 'out');
          animKit.transition(currentSeconds, 20, 3, options.bfStrs[1], 'explode', 'out');
          setTimeout(function(){
            scene.removeSceneObject(options.bfStrs[0]);
            scene.removeSceneObject(options.bfStrs[1]);
          }, 3000);
        },
      });

      popcorn.code({
        start: 9,
        end: 24,
        onStart: function (options) {
          var bfStrs = [bf3d.genString('to'), bf3d.genString("flameparty!!")];
          bfStrs[0].scale = [0.6, 0.6, 0.6];
          bfStrs[0].position[1] = 1.2;
          bfStrs[1].position[1] = .2;
          bfStrs[1].scale = [1, 1, 1];
          animKit.transition(currentSeconds, 5, 3, bfStrs[0], "spiral");
          animKit.transition(currentSeconds, 5, 3, bfStrs[1], "spiral2");
          animKit.transition(currentSeconds+10, 200, 15, bfStrs[0], 'random', 'out');
          options.bfStrs = bfStrs;
          scene.bindSceneObject(bfStrs[0]);
          scene.bindSceneObject(bfStrs[1]);
        },
        onEnd: function (options) {
          animKit.transition(currentSeconds, 20, 3, options.bfStrs[1], 'random', 'out');
          setTimeout(function(){
            scene.removeSceneObject(options.bfStrs[0]);
            scene.removeSceneObject(options.bfStrs[1]);
          }, 3000);
        },
      });

      popcorn.code({
        start: 15,
        end: 25,
        onStart: function (options) {
          var bfStr = bf3d.genString("Helsinki");
          animKit.transition(currentSeconds, 20, 3, bfStr, 'explode', 'in');
          options.bfStr = bfStr;
          bfStr.scale = [3, 3, 3];
          bfStr.position = [6, 2.8, -8];
          bfStr.rotation[1] = -45;
          scene.bindSceneObject(bfStr);
          moveCameraTarget(currentSeconds+1, 2, bfStr.position);
        },
        onEnd: function (options) {
          animKit.transition(currentSeconds, 200, 3, options.bfStr, 'random', 'out');
          setTimeout(function(){
            scene.removeSceneObject(options.bfStr);
          }, 3000);
        },
      });

      popcorn.code({
        start: 18,
        end: 28,
        onStart: function (options) {
          var bfStr = bf3d.genString("Finland");
          animKit.transition(currentSeconds, 5, 3, bfStr, 'explode', 'in');
          options.bfStr = bfStr;
          bfStr.scale = [3, 3, 3];
          bfStr.position = [-5, 3.8, -7];
          bfStr.rotation[1] = 45;
          scene.bindSceneObject(bfStr);
          spotLights[1].lookat(bfStr.position);
          moveCameraTarget(currentSeconds+3, 2, bfStr.position);
        },
        onEnd: function (options) {
          animKit.transition(currentSeconds, 20, 3, options.bfStr, 'explode', 'out');
          moveCameraTarget(currentSeconds, .25, [0,.2,0]);
          setTimeout(function(){
            scene.removeSceneObject(options.bfStr);
          }, 3000);
        },
      });

      popcorn.code({
        start: 9,
        end: 11,
        onStart: function (options) {
          floorColorMode = 1;
        },
      });

      popcorn.code({
        start: 28,
        end: 36,
        onStart: function (options) {
          for (var i=0; i<soundFloorRings.length; ++i) {
            var ring = soundFloorRings[i];
            ring.targetY = 1-i*1.5;
          } //for
          floorShapeMode = 1;
          floorColorMode = 2;

          spotLights[0].position = [2, 2, 35];
          spotLights[1].position = [-1, 10, 35];
          spotLights[0].lookat([1, 0, 0]);
          spotLights[1].lookat([0, 0, 0]);
          spotLights[0].cutoff = 400;
          spotLights[1].cutoff = 400;
          spotLights[0].intensity = .2;
          spotLights[1].intensity = .2;

          dateTextObjects[0].scale = [50, 40, 1];
          dateTextObjects[0].rotation[1] = 180;
          dateTextObjects[0].position = [-15, -2, -10];

          dateTextObjects[1].scale = [80, 100, 1];
          dateTextObjects[1].rotation[1] = 180;
          dateTextObjects[1].position = [30, -12, -15];

          var mot = dateTextObjects[1].motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, currentSeconds, dateTextObjects[0].position[1]).tension=1;
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, currentSeconds+25, dateTextObjects[0].position[1]-60).tension=1;
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, currentSeconds+26, dateTextObjects[0].position[1]-420).tension=1;

          var mot = dateTextObjects[0].motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, currentSeconds, dateTextObjects[1].position[2]).tension=1;
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, currentSeconds+25, dateTextObjects[1].position[2]-60).tension=1;
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, currentSeconds+26, dateTextObjects[1].position[2]-420).tension=1;

          scene.bindSceneObject(dateTextObjects[0]);
          scene.bindSceneObject(dateTextObjects[1]);

        },
        onEnd: function (options) {
          targetFOV = 65;
        },
      });

      function curveLetters(bfStr) {
        var tilt = 70/bfStr.children.length;
        for (var i=0; i<bfStr.children.length; ++i) {
          var letter = bfStr.children[i];
          var xofs = letter.position[0];
          letter.position[2] = bfStr.children.length/2+Math.cos(xofs/2);
          letter.rotation[1] = xofs * tilt;
        } //for
      }; //curveLetters

      function setupLettersMotion(bfStr, startTime, endTime, offset) {
        offset = offset || [0,0,0];
        bfStr.position = [0, -20, 0];
        var mot = bfStr.motion = new CubicVR.Motion();
        mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, startTime, -20+offset[1]);
        mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, startTime+.5, 0+offset[1]);
        mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, startTime, -180).tension = 1;
        mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, startTime+.5, 0).tension = 1;
        mot.setBehavior(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);

        mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, endTime, 0+offset[1]);
        mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, endTime+.5, -20+offset[1]);
        mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, endTime, 0).tension = 1;
        mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, endTime+.5, 180).tension = 1;
        mot.setBehavior(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
 
      }; //setupLettersMotion

      var words = [
        [bf3d.genString(' starring')],
        [bf3d.genString(' secret'),bf3d.genString(' robotron')],
        [bf3d.genString(' ccliffe')],
        [bf3d.genString(' humph')],
        [bf3d.genString(' corban')],
        [bf3d.genString(' cubicvr')],
        [bf3d.genString(' popcorn')],
      ];

      for (var i=0; i<words.length; ++i) {
        (function (bfStrs) {
          popcorn.code({
            start: 36+i*3,
            end: 40+i*3,
            onStart: function (options) {
              for (var j=0; j<bfStrs.length; ++j) {
                var bfStr = bfStrs[j];
                curveLetters(bfStr);
                options.bfStr = bfStr;
                setupLettersMotion(bfStr, currentSeconds, currentSeconds+3, [0, -3*j, 0]);
                bfStr.scale = [3, 3, 3];
                scene.bindSceneObject(bfStr);
              } //for
            },
            onEnd: function (options) {
              for (var j=0; j<bfStrs.length; ++j) {
                scene.removeSceneObject(bfStrs[j]);
              } //for
            },
          });
        })(words[i]);
      } //for

      var FINISH_FLOOR = 40 + words.length*3;

      var mot = soundFloorRingParent.motion = new CubicVR.Motion();
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, FINISH_FLOOR, 0);
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, FINISH_FLOOR + .2, 0.6).tension = 1;
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, FINISH_FLOOR + 2, -100).tension = 1;
      mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);

      popcorn.code({
        start: FINISH_FLOOR+5,
        end: FINISH_FLOOR+6,
        onStart: function (options) {
          soundFloorRingParent.visible = false;
        }
      });

      dirLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.DIRECTIONAL,
        specular: [1,1,1],
        intensity: .4,
        direction: CubicVR.vec3.normalize([0.5,-1,0.5])
      });
      scene.bindLight(dirLight);

    },
    load: function () {
      shaders['quarterbloom'].enabled = false;
      shaders['halfbloom'].enabled = true;
      shaders['dof'].enabled = false;
      shaders['ssao'].enabled = true;
      scene.bindSceneObject(soundFloorRingParent);
    },
    unload: function () {
      scene.removeLight(dirLight);
      scene.removeLight(spotLights[0]);
      scene.removeLight(spotLights[1]);
      scene.removeSceneObject(soundFloorRingParent);
      for (var i=0; i<dateTextObjects.length; ++i) {
        scene.removeSceneObject(dateTextObjects[i]);
      } //for
    },
    update: function (timer) {
      audioBuffer = audioEngine.audioBuffer;
      fft = audioEngine.fft;
      currentSeconds = timer.getSeconds();

      scene.camera.target = cameraTarget.position;

      if (audioBuffer) {
        updateSoundFloor(currentSeconds);
      } //if
      if (floorShapeMode === 0) {
        scene.camera.position[0] = 3 + 4 * Math.sin(currentSeconds/1.2) + Math.cos(currentSeconds/2) * 1.5;
        scene.camera.position[2] = 3 + Math.sin(currentSeconds/5) + Math.cos(currentSeconds/2) * 1.5;
      }
      else if (floorShapeMode === 1) {
        scene.camera.position[0] -= (scene.camera.position[0] - 0)*.85;
        scene.camera.position[1] -= (scene.camera.position[1] - 0)*.85;
        scene.camera.position[2] -= (scene.camera.position[2] - 22)*.85;
        scene.camera.setFOV(scene.camera.fov - (scene.camera.fov - targetFOV)*.15);
      } //if

    },
  });
}());

</script>
    <script type="text/javascript">
SegmentList.addSegment(function () {
  var START_TIME = 65;

  var audioEngine;
  var audioBuffer, fft;
  var popcorn;
  var scene, animkit, bf3d;

  var spotLight, pointLight;

  var cameraTarget = [0,0,0],
      cameraMode = 0,
      cameraPosition = [0,0,0];

  var boxRotation = 0;

  function makeWireBoxObject(boxObject,boxSize,boxMesh) {
    for (var i = 1; i <= boxSize; i++) {
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2+i,boxSize/2,boxSize/2],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2+i,-boxSize/2,boxSize/2],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2+i,boxSize/2,-boxSize/2],mesh:boxMesh}));                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2+i,-boxSize/2,-boxSize/2],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,boxSize/2,-boxSize/2+i],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,-boxSize/2,-boxSize/2+i],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[boxSize/2,boxSize/2,-boxSize/2+i],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[boxSize/2,-boxSize/2,-boxSize/2+i],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[boxSize/2,-boxSize/2+i,boxSize/2],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[boxSize/2,-boxSize/2+i,-boxSize/2],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,-boxSize/2+i,boxSize/2],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,-boxSize/2+i,-boxSize/2],mesh:boxMesh}));
    }

    boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,-boxSize/2,-boxSize/2],mesh:boxMesh}));
  }; //makeWireBoxObject

  var boxObject;

  return new Segment({
    startTime: START_TIME,

    prepare: function (options) {
      audioEngine = options.audioEngine;
      popcorn = options.popcorn;
      scene = options.scene;
      animkit = new AnimationKit();

      bfMaterial = new CubicVR.Material({
        color: [0.8,0.3,0.2],
        specular: [1, 5, 0],
        shininess: 0.9,
        textures: {
          envsphere: new CubicVR.CanvasTexture(document.getElementById("img/fract_reflections.jpg"))
        }
      });
        
      var bfUV = new CubicVR.UVMapper({
        projectionMode: CubicVR.enums.uv.projection.CUBIC,
        scale: [1, 1, 1]
      });

      bf3d = new bitFont3D("box", bfMaterial, bfUV);
      bf3d.loadFont();

      var boxMaterial = new CubicVR.Material({
        color: [0.3,0.4,0.9],
        specular: [1,1,1],
        shininess: 0.9,
        textures: {
          envsphere: new CubicVR.CanvasTexture(document.getElementById("img/fract_reflections.jpg"))
        }
      });

      var boxMesh = CubicVR.primitives.box({
        size: 1.0,
        material: boxMaterial,
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.CUBIC,
          scale: [1,1,1]
        }
      });

      boxMesh.triangulateQuads().compile().clean();

      boxObject = new CubicVR.SceneObject(null);

      makeWireBoxObject(boxObject,7,boxMesh);
      makeWireBoxObject(boxObject,3,boxMesh);

      animkit.transition(START_TIME+0, 10, 2, boxObject, "spiral2");
      animkit.transition(START_TIME+15, 40, 2, boxObject, "explode","out");
      animkit.transition(START_TIME+20, 10, 2, boxObject, "random");
      animkit.transition(START_TIME+28, 50, 2, boxObject, "spiral2","out");
      animkit.transition(START_TIME+48, 40, 2, boxObject, "explode");

      spotLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.SPOT,
        specular: [0.4,0.4,0.4],
        diffuse: [1,1,1],
        intensity: .3,
        distance: 200,
        cutoff: 400,
        //map_res: 1024,
        position: [0, 8, -8],
      });

      pointLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.POINT,
        specular: [1,1,1],
        intensity: .5,
        distance: 100,
        position: [0, 2, 0],
      });

      spotLight.lookat([0, 0, 0]);

      var words = [
        bf3d.genString('Moz Labs'),
        bf3d.genString('Alternative Party'),
        bf3d.genString('& DOT'),
        bf3d.genString('Present:'),
      ];

      for (var j=0; j<words.length; ++j) {
        (function (bfStr, i) {
          popcorn.code({
            start: START_TIME+21+i/2,
            end: START_TIME+43+i/2,
            onStart: function (options) {
              bfStr.position = [-3+5*i, 3-i, -8];
              var startTime = START_TIME + 20;
              var mot = bfStr.motion = new CubicVR.Motion();
              mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, startTime, bfStr.position[0]);
              mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, startTime+3, bfStr.position[0]+2);
              mot.setBehavior(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
              options.bfStr = bfStr;
              animkit.transition(START_TIME+40+i/2, 40, 2, bfStr, "explode", 'out');
              scene.bindSceneObject(bfStr);
            },
            onEnd: function (options) {
              scene.removeSceneObject(options.bfStr);
            },
          });

          popcorn.code({
            start: START_TIME+27+i*2,
            end: START_TIME+27.5+i*2,
            onStart: function (options) {
              cameraTarget = bfStr.position;
              cameraPosition = [bfStr.position[0]+2, bfStr.position[1]-1.3, bfStr.position[2]+2.5];
            },
          });
        })(words[j], j);
      } //for

      popcorn.code({
        start: START_TIME+25.5,
        end: START_TIME+26,
        onStart: function (options) {
          cameraMode = 1;
          cameraPosition = [4, 2, 5];
        },
      });

      popcorn.code({
        start: START_TIME+35,
        end: START_TIME+50,
        onStart: function (options) {
          spotLight.position = [0, 8, 0];
          cameraPosition = [2, 5, -9];
          cameraTarget = [0, 3, 8];
          var bfStrs = [
            bf3d.genString('Demo Art'),
            bf3d.genString('on the'),
            bf3d.genString('Open Web platform'),
          ];

          bfStrs[0].scale = [5, 5, 5];
          bfStrs[0].position = [-5, 5.5, 9];
          bfStrs[0].rotation[1] = 170;
          bfStrs[1].scale = [1, 1, 1];
          bfStrs[1].position = [0, 0, 10];
          bfStrs[1].rotation[1] = 180;
          bfStrs[2].scale = [4, 4, 4];
          bfStrs[2].position = [-11, -4.5, 11.5];
          bfStrs[2].rotation[1] = 190;

          var bfStr = bfStrs[0];
          var mot = bfStr.motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, START_TIME+35, bfStr.position[0]);
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, START_TIME+50, bfStr.position[0]+1);
          mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
          bfStr = bfStrs[1];
          mot = bfStr.motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, START_TIME+35, bfStr.position[1]);
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, START_TIME+50, bfStr.position[1]-1);
          mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
          bfStr = bfStrs[2];
          mot = bfStr.motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Z, START_TIME+35, bfStr.position[2]);
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Z, START_TIME+50, bfStr.position[2]+1);
          mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.Z, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);

          scene.bindSceneObject(bfStrs[0]);
          scene.bindSceneObject(bfStrs[1]);
          scene.bindSceneObject(bfStrs[2]);

          animkit.transition(START_TIME+47, 40, 3, bfStrs[0], "explode", "out");
          animkit.transition(START_TIME+47, 40, 3, bfStrs[1], "explode", "out");
          animkit.transition(START_TIME+47, 40, 3, bfStrs[2], "explode", "out");

          spotLight.lookat(bfStrs[1].position);
         
          options.bfStrs = bfStrs;
        },
        onEnd: function (options) {
          scene.removeSceneObject(options.bfStrs[0]);
          scene.removeSceneObject(options.bfStrs[1]);
          scene.removeSceneObject(options.bfStrs[2]);
        },
      });

      popcorn.code({
        start: START_TIME+50,
        end: START_TIME+53,
        onStart: function (options) {
          cameraTarget = [0, 0, 0];
          cameraPosition = [10, 10, 10];
        },
        onEnd: function (options) {
          boxRotation = 1;
        },
      });

      popcorn.code({
        start: START_TIME+57,
        end: START_TIME+60,
        onStart: function (options) {
          animkit.transition(START_TIME+57, 300, 3, boxObject, "explode", "out");
        },
      });

    },
    load: function () {
      shaders['ssao'].enabled = false;
      scene.bindLight(spotLight);
      scene.bindLight(pointLight);
      scene.bindSceneObject(boxObject);
      scene.camera.target = [0,0,0];
      cameraTarget = [0,0,0];
    },
    unload: function () {
      scene.removeLight(spotLight);
      scene.removeLight(pointLight);
      scene.removeSceneObject(boxObject);
    },
    update: function (timer) {
      var seconds = timer.getSeconds();

      boxRotation *= 1.07;
      boxObject.rotation[1] += boxRotation;

      if (cameraMode === 0) {
        scene.camera.position[0] = 5 * Math.sin(seconds / 5) + Math.cos(seconds / 2) * 3.5;
        scene.camera.position[2] = 5 * Math.cos(seconds / 5) + Math.cos(seconds / 2) * 3.5;
      }
      else if (cameraMode === 1) {
        scene.camera.target[0] -= (scene.camera.target[0] - cameraTarget[0]) *.35;
        scene.camera.target[1] -= (scene.camera.target[1] - cameraTarget[1]) *.35;
        scene.camera.target[2] -= (scene.camera.target[2] - cameraTarget[2]) *.35;
        scene.camera.position[0] -= (scene.camera.position[0] - cameraPosition[0]) *.35;
        scene.camera.position[1] -= (scene.camera.position[1] - cameraPosition[1]) *.35;
        scene.camera.position[2] -= (scene.camera.position[2] - cameraPosition[2]) *.35;
      } //if
    },
  });

}());
 

</script>
    <script type="text/javascript">
SegmentList.addSegment(function () {
  var START_TIME = 126;
  //var START_TIME = 1;

  var audioEngine;
  var audioBuffer, fft;
  var popcorn;
  var scene, animkit, bf3d;

  var logoObject, words, wordsWidth, audioPlane, audioTexture;
  var canvas, links = [], mvc;
  var currentSeconds;
  var rootLinkObject;

  return new Segment({
    startTime: START_TIME,

    prepare: function (options) {
      audioEngine = options.audioEngine;
      popcorn = options.popcorn;
      scene = options.scene;
      canvas = options.canvas;
      animkit = new AnimationKit();

      bfMaterial = new CubicVR.Material({
        color: [0.8,0.3,0.2],
        specular: [1, 5, 0],
        shininess: 0.9,
        textures: {
          envsphere: new CubicVR.CanvasTexture(document.getElementById("img/fract_reflections.jpg"))
        }
      });
        
      var bfUV = new CubicVR.UVMapper({
        projectionMode: CubicVR.enums.uv.projection.CUBIC,
        scale: [1, 1, 1]
      });

      bf3d = new bitFont3D("box", bfMaterial, bfUV);
      bf3d.loadFont();

      audioTexture = new CubicVR.CanvasTexture({
        update: function (canvas, ctx) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
          ctx.fillRect(0, 0, 512, 512);
          ctx.strokeStyle = "rgb("+Math.floor(255*(Math.sin(currentSeconds/2)*.5+1))+", "+Math.floor(255*(Math.sin(currentSeconds/4)*.5+1))+", "+Math.floor(255*(Math.sin(currentSeconds/3)*.5+1))+")";
          ctx.moveTo(0, 128);
          ctx.lineWidth = 4;
          ctx.beginPath();
          for (var i=0; i<256 && i<audioBuffer.length; ++i) {
            ctx.lineTo(i, 128 + audioBuffer[i]*64);
          }//for
          ctx.stroke();
        },
        width: 256,
        height: 256,
      });

      var s = 50.0;
      audioPlane = new CubicVR.SceneObject(CubicVR.primitives.plane({
        size: s,
        material: new CubicVR.Material({
          textures: {
            color: audioTexture,
          }
        }),
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.PLANAR,
          projectionAxis: CubicVR.enums.uv.axis.Z,
          scale: [s, s, s],
        },
      }).triangulateQuads().compile().clean());

      function makeLinkObject(text, link, color, position, scale, rotation) {
        var linkObject = new CubicVR.SceneObject(CubicVR.primitives.plane({
          size: 1,
          material: new CubicVR.Material({
            shininess: 2,
            specular: [1, 1, 1],
            diffuse: [1, 1, 1],
            textures: {
              color: new CubicVR.TextTexture(text, {font: '100pt Arial', color: color}),
            },
          }),
          uvmapper: {
            projectionMode: CubicVR.enums.uv.projection.PLANAR,
            projectionAxis: CubicVR.enums.uv.axis.Z,
            scale: [1, 1, 1],
          },
        }).triangulateQuads().compile().clean());

        linkObject.position = position;
        linkObject.rotation = rotation;
        linkObject.scale = scale;

        linkObject.href = link;

        links.push(linkObject);
      };

      makeLinkObject('mozillalabs.com/demoparty/helsinki', 'http://mozillalabs.com/demoparty/helsinki', '#ffaa00', [0, .8, 0], [1.1, .2, 1], [0, 0, 0]);
      makeLinkObject('github.com/cjcliffe/CubicVR.js', 'http://github.com/cjcliffe/CubicVR.js', '#ffffff', [-1, .4, 0], [.8, .2, 1], [0, -45, -10]);
      makeLinkObject('github.com/BillyWM/jsmodplayer', 'http://github.com/BillyWM/jsmodplayer', '#ffffff', [-1, -.4, 0], [.8, .2, 1], [0, -45, 10]);
      makeLinkObject('github.com/webmademovies/popcorn-js', 'http://github.com/webmademovies/popcorn-js', '#ffffff', [1, -.4, 0], [.8, .2, 1], [0, 45, -10]);
      makeLinkObject('github.com/secretrobotron/audio.3', 'http://github.com/secretrobotron/audio.3', '#00aaff', [1, .4, 0], [.9, .2, 1], [0, 45, 10]);

      audioPlane.position = [0, 0, 6];

      var logoMaterial = new CubicVR.Material({
        textures: {
          color: new CubicVR.CanvasTexture(document.getElementById("img/logo.jpg")),
          alpha: new CubicVR.CanvasTexture(document.getElementById("img/logo-alpha.jpg")),
        },
      });

      var logoMesh = CubicVR.primitives.plane({
        size: 5.0,
        material: logoMaterial,
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.PLANAR,
          projectionAxis: CubicVR.enums.uv.axis.Z,
          scale: [5, 5, 5],
        }
      });

      logoMesh.triangulateQuads().compile().clean();

      logoObject = new CubicVR.SceneObject(logoMesh);

      logoObject.position = [0, 0, 3.5];
      logoObject.rotation[1] = 90;

      var mot = logoObject.motion = new CubicVR.Motion();
      mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, START_TIME+1, 90).tension=1;
      mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, START_TIME+3, 0).tension=1;
      mot.setBehavior(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);

      var str = 'Register now!! June 18th, Helsinki, Finland. Mozilla Labs, Alternative Party and DOT present: Demo Art on the Open Web Platform; THE FLAME PARTY!!   --   Thanks to jsmodplayer, popcorn.js, cubicvr.js, for driving this thing, and xtd/mystic & pulse for the tunes. #audio expects you to show your stuff at FlameParty. -- ';
      words = bf3d.genString(str);

      words.position = [0, -1.5, 2];
      words.rotation = [0, 180, 0];
      wordsWidth = str.length;
      mot = words.motion = new CubicVR.Motion();
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, START_TIME, -str.length/2).tension=0;
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, START_TIME+90, str.length/2).tension=0;
      mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, CubicVR.enums.envelope.behavior.REPEAT, CubicVR.enums.envelope.behavior.REPEAT);

      for (var i=0; i<links.length; ++i) {
        links[i].restingScale = [links[i].scale[0], links[i].scale[1], links[i].scale[2]];
        links[i].targetScale = [links[i].scale[0], links[i].scale[1], links[i].scale[2]];
        links[i].activeScale = [links[i].scale[0]*2, links[i].scale[1]*2, links[i].scale[2]*2];
      } //for

      rootLinkObject = new CubicVR.SceneObject(null);
      for (var i=0; i<links.length; ++i) {
        rootLinkObject.bindChild(links[i]);
      } //for

      animkit.transition(START_TIME+3, 20, 3, rootLinkObject, "spiral");

    },
    load: function () {
      shaders['ssao'].enabled = true;
      shaders['halfbloom'].enabled = true;
      scene.camera.position = [0, 0, -1.5];
      scene.camera.target = [0, 0, 0];
      scene.camera.setFOV(80);
      scene.bindSceneObject(audioPlane);
      scene.bindSceneObject(rootLinkObject, true);
      scene.bindSceneObject(logoObject);
      scene.bindSceneObject(words);
      var spotLight = (new CubicVR.Light({
        type: CubicVR.enums.light.type.SPOT_SHADOW,
        specular: [1 ,1, 1],
        diffuse: [1, 1, 1],
        intensity: .2,
        distance: 35,
        cutoff: 200,
        map_res: 1024,
        position: [0, -2, -3],
      }));
      spotLight.lookat([0, 0, 0]);
      scene.bindLight(spotLight);

      var pLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.POINT,
        specular: [1, 1, 1],
        diffuse: [1, 1, 1],
        intensity: .6,
        distance: 20,
        position: [0, 0, -2],
      });
      scene.bindLight(pLight);

      mvc = new CubicVR.MouseViewController(canvas, scene.camera);
      canvas.addEventListener('click', function (e) {
        for (var i=0; i<links.length; ++i) {
          if (links[i].mouseOver) {
            window.open(links[i].href, '_blank');
          } //if
        } //for
      }, false);
    },
    unload: function () {
    },
    update: function (timer) {
      currentSeconds = timer.getSeconds();

      var wordsPos = words.position;
      for (var i=0; i<words.children.length; ++i) {
        var child = words.children[i];
        var childPos = child.position[0] - wordsPos[0];
        if (childPos < -20 || childPos > 20) {
          child.visible = false;
        }
        else {
          child.visible = true;
        } //if
      } //for

      var rayTest = scene.bbRayTest(scene.camera.position, mvc.getMousePosition(), 3);
      if (rayTest.length > 0) {
        var objs = [];
        var cursor = 'default';
        for (var i=0; i<rayTest.length; ++i) {
          objs.push(rayTest[i].obj);
        } //for
        for (var i=0; i<links.length; ++i) {
          if (objs.indexOf(links[i]) > -1) {
            cursor = 'pointer';
            links[i].targetScale = links[i].activeScale;
            links[i].mouseOver = true;
          }
          else {
            links[i].targetScale = links[i].restingScale;
            links[i].mouseOver = false;
          } //if
        } //for
        document.body.style.cursor = cursor;
      }
      else {
        document.body.style.cursor = 'default';
        for (var i=0; i<links.length; ++i) {
          links[i].targetScale = links[i].restingScale;
          links[i].mouseOver = false;
        } //for
      } //if

      for (var i=0; i<links.length; ++i) {
        var scale = links[i].scale;
        var tScale = links[i].targetScale;
        scale[0] -= (scale[0] - tScale[0]) * .85;
        scale[1] -= (scale[1] - tScale[1]) * .85;
        scale[2] -= (scale[2] - tScale[2]) * .85;
        links[i].scale = scale;
      } //for

      audioBuffer = audioEngine.audioBuffer;
      if (audioBuffer) {
        audioTexture.update();
      } //if
    },
  });

}());
 

</script>
    <script id="cubicvr-core-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec3 aNormal;
  attribute vec2 aTextureCoord;
  varying vec2 vTextureCoord;

//  #if hasColorMap||hasBumpMap||hasNormalMap||hasAmbientMap||hasSpecularMap||hasAlphaMap
//  #endif

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  uniform mat4 uOMatrix;
  uniform mat3 uNMatrix;

  vec3 mSpec;
  float mShine;

  varying vec3 vNormal;
  varying vec4 vPosition;

#if !depthPack

#if loopCount
  struct Light {
    vec3 lDir;
    vec3 lPos;
    vec3 lSpec;
    vec3 lDiff;
    float lInt;
    float lDist;
#ifdef lightSpot
    float lCut;
#endif
  };
 uniform Light lights[loopCount];
#endif

#if hasShadow
  varying vec4 shadowProj[loopCount];
  uniform mat4 spMatrix[loopCount];
#endif


#if hasEnvSphereMap
#if hasNormalMap
  varying vec3 u;
#else
  varying vec2 vEnvTextureCoord;
#endif
#endif


  
#if hasBumpMap||hasNormalMap
  varying vec3 eyeVec; 
#endif

#endif // !depthPack

void main(void) 
{
  mat4 uMVOMatrix = uMVMatrix * uOMatrix;
  mat4 uMVPMatrix = uPMatrix * uMVMatrix;

  vPosition = uMVOMatrix * vec4(aVertexPosition, 1.0);
  
  gl_Position = uMVPMatrix * uOMatrix * vec4(aVertexPosition, 1.0);

  vTextureCoord = aTextureCoord;

#if !depthPack
  
  vNormal = uNMatrix * normalize(uOMatrix*vec4(aNormal,0.0)).xyz;


#if hasBumpMap||hasNormalMap
  vec3 tangent;
  vec3 binormal;

  vec3 c1 = cross( aNormal, vec3(0.0, 0.0, 1.0) );
  vec3 c2 = cross( aNormal, vec3(0.0, 1.0, 0.0) );

  if ( length(c1) > length(c2) )  {
    tangent = c1;
  }  else {
    tangent = c2;
  }

  tangent = normalize(tangent);

  binormal = cross(aNormal, tangent);
  binormal = normalize(binormal);

  mat3 TBNMatrix = mat3( (vec3 (uMVOMatrix * vec4 (tangent, 0.0))), 
                         (vec3 (uMVOMatrix * vec4 (binormal, 0.0))), 
                         (vec3 (uMVOMatrix * vec4 (aNormal, 0.0)))
                       );

  eyeVec = vec3(uMVOMatrix * vec4(aVertexPosition,1.0)) * TBNMatrix;
#endif

#if (lightSpot||lightArea) && hasShadow
    for (int i = 0; i < loopCount; i++)
    {
#if hasShadow
      shadowProj[i] = spMatrix[i] * (uOMatrix * vec4(aVertexPosition, 1.0));
#endif      
    }
#endif

#if hasEnvSphereMap
#if hasNormalMap
   u = normalize( vPosition.xyz );
 #else
  vec3 ws = (uMVMatrix * vec4(aVertexPosition,1.0)).xyz;
  vec3 u = normalize( vPosition.xyz );
  vec3 r = reflect(ws, vNormal );
  float m = 2.0 * sqrt( r.x*r.x + r.y*r.y + (r.z+1.0)*(r.z+1.0) );
  vEnvTextureCoord.s = r.x/m + 0.5;
  vEnvTextureCoord.t = r.y/m + 0.5;
#endif
#endif

#endif // !depthPack
}
</script>
    <script id="cubicvr-core-fs" type="x-shader/x-fragment">
#ifdef GL_ES
  precision highp float;
#endif

  uniform vec3 mDiff;
  uniform vec3 mColor;
  uniform vec3 mAmb;

  varying vec3 vNormal;

  varying vec2 vTextureCoord;

#if alphaDepth||depthPack||hasShadow
  uniform vec3 depthInfo;
  float ConvertDepth3(float d) { return (depthInfo.x*depthInfo.y)/(depthInfo.y-d*(depthInfo.y-depthInfo.x));  }
  // transform range in world-z to 0-1 for near-far
  float DepthRange( float d ) { return ( d - depthInfo.x ) / ( depthInfo.y - depthInfo.x ); }

  float ConvertDepth3A(float d, float near, float far) { return (near*far)/(far-d*(far-near));  }
  // transform range in world-z to 0-1 for near-far
  float DepthRangeA( float d, float near, float far ) { return ( d - near ) / ( far - near ); }
#endif

#if depthPack
  vec4 packFloatToVec4i(const float value)
  {
    const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
    const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
    vec4 res = fract(value * bitSh);
    res -= res.xxyz * bitMsk;
    return res;
  }

#endif

#if hasShadow
float unpackFloatFromVec4i(const vec4 value)
{
  const vec4 bitSh = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
  return(dot(value, bitSh));
}

#if softShadow
float getShadowVal(sampler2D shadowTex,vec4 shadowCoord, float proj, float texel_size) {
  vec2 filterTaps[6]; 
  filterTaps[0] = vec2(-0.326212,-0.40581);
  filterTaps[1] = vec2(-0.840144,-0.07358);
  filterTaps[2] = vec2(-0.695914,0.457137);
  filterTaps[3] = vec2(-0.203345,0.620716);
  filterTaps[4] = vec2(0.96234,-0.194983);
  filterTaps[5] = vec2(0.473434,-0.480026); 
/*  filterTaps[6] = vec2(0.519456,0.767022);
  filterTaps[7] = vec2(0.185461,-0.893124); 
  filterTaps[8] = vec2(0.507431,0.064425);
  filterTaps[9] = vec2(0.89642,0.412458) ;
  filterTaps[10] =vec2(-0.32194,-0.932615);
  filterTaps[11] =vec2(-0.791559,-0.59771); */

   float shadow = 0.0;   
  
   for (int i = 0; i < 6; i++) {
   vec4 shadowSample = texture2D(shadowTex,shadowCoord.st+filterTaps[i]*(2.0*texel_size));

   float distanceFromLight = unpackFloatFromVec4i(shadowSample);
  
   shadow += distanceFromLight <= shadowCoord.z ? 0.0 : 1.0 ;
  }

  shadow /= 6.0;
  
  return shadow;
}
#else
float getShadowVal(sampler2D shadowTex,vec4 shadowCoord, float proj, float texel_size) {
  vec4 shadowSample = texture2D(shadowTex,shadowCoord.st);

  float distanceFromLight = unpackFloatFromVec4i(shadowSample);
  float shadow = 1.0;
   
  shadow = distanceFromLight <= (shadowCoord.z) ? 0.0 : 1.0 ;
  
  return shadow;
}
#endif
#endif


#if hasShadow
  varying vec4 shadowProj[loopCount];
  uniform sampler2D lDepthTex[loopCount];
  uniform vec3 lDepth[loopCount];
#endif


#if !depthPack
#if hasColorMap
  uniform sampler2D colorMap;
#endif

#if hasBumpMap
  varying vec3 eyeVec; 
  uniform sampler2D bumpMap;
#endif


#if hasEnvSphereMap
  uniform sampler2D envSphereMap;
  uniform float envAmount;
#if hasNormalMap
   varying vec3 u;
#else
  varying vec2 vEnvTextureCoord;
#endif
#endif

#if hasReflectMap
  uniform sampler2D reflectMap;
#endif

#if hasNormalMap
  uniform sampler2D normalMap;
#endif

  uniform float mAlpha;

#if hasAmbientMap
  uniform sampler2D ambientMap;
#endif

#if hasSpecularMap
  uniform sampler2D specularMap;
#endif

#endif // !depthPack

#if hasAlphaMap
  uniform sampler2D alphaMap;
#endif

#if lightPoint||lightDirectional||lightSpot||lightArea
  struct Light {
    vec3 lDir;
    vec3 lPos;
    vec3 lSpec;
    vec3 lDiff;
    float lInt;
    float lDist;
    #if lightSpot
        float lCut;
    #endif
  };
  uniform Light lights[loopCount];  
#endif

uniform vec3 mSpec;
uniform float mShine;
uniform vec3 lAmb;



varying vec4 vPosition;

uniform mat4 uPMatrix;

void main(void) 
{
#if depthPack
  vec2 texCoord = vTextureCoord;
#else
  vec3 n;
  vec4 color = vec4(0.0,0.0,0.0,0.0);
  
#if hasBumpMap
  float height = texture2D(bumpMap, vTextureCoord.xy).r;  
  float v = (height) * 0.05 - 0.04; // * scale and - bias 
  vec3 eye = normalize(eyeVec); 
  vec2 texCoord = vTextureCoord.xy + (eye.xy * v);
#else 
//#if hasColorMap||hasBumpMap||hasNormalMap||hasAmbientMap||hasSpecularMap||hasAlphaMap
  vec2 texCoord = vTextureCoord;
//#endif
#endif


#if hasNormalMap
     vec3 bumpNorm = vec3(texture2D(normalMap, texCoord));

    n = (vec4(normalize(vNormal),1.0)).xyz;
    bumpNorm = (bumpNorm-0.5)*2.0;
    bumpNorm.y = -bumpNorm.y;
    n = normalize((n+bumpNorm)/2.0);
#else
    n = normalize(vNormal);
#endif


#if hasColorMap
#if !(lightPoint||lightDirectional||lightSpot||lightArea)
  color = texture2D(colorMap, vec2(texCoord.s, texCoord.t)).rgba;
  //vec4(lAmb,1.0)*
#else
  color = texture2D(colorMap, vec2(texCoord.s, texCoord.t)).rgba;
  color.rgb *= mColor;
#endif
  if (color.a<=0.9) discard;  
#else
  color = vec4(mColor,1.0);
#endif

#if hasAlphaMap
  color.a = texture2D(alphaMap, texCoord).r;
#if alphaDepth
  if (color.a < 0.9) discard;
#else
#if !hasAlpha
  if (color.a<0.9) discard;
#else
  if (color.a==0.0) discard;
#endif
#endif
#else
#if hasAlpha
  color.a = mAlpha;
#endif
#endif


//float envAmount = 1.0;

vec3 accum = lAmb;


#if lightPoint

  vec3 specTotal = vec3(0.0,0.0,0.0);

  for (int i = 0; i < loopCount; i++) {

    vec3 lDir = lights[i].lPos-vPosition.xyz;

    float dist = length(lDir);
  
    vec3 halfVector = normalize(vec3(0.0,0.0,1.0)+lDir);

    float NdotL = max(dot(normalize(lDir),n),0.0);

    if (NdotL > 0.0) {
      // basic diffuse
      float att = clamp(((lights[i].lDist-dist)/lights[i].lDist), 0.0, 1.0)*lights[i].lInt;

      accum += att * NdotL * lights[i].lDiff * mDiff;

       float NdotHV = max(dot(n, halfVector),0.0);

  
      #if hasSpecularMap
        vec3 spec2 = lights[i].lSpec * texture2D(specularMap, vec2(texCoord.s, texCoord.t)).rgb * pow(NdotHV,mShine);
      #else
        vec3 spec2 = lights[i].lSpec * mSpec * pow(NdotHV,mShine);
      #endif
  
        specTotal += spec2;
    }
    
  }
  
  color.rgb *= accum;
  color.rgb += specTotal;
#endif




#if lightDirectional
  float NdotL;
  float NdotHV = 0.0;
  vec3 specTotal = vec3(0.0,0.0,0.0);
  vec3 spec2 = vec3(0.0,0.0,0.0);

  vec3 halfVector;
  
  for (int i = 0; i < loopCount; i++) {

    halfVector = normalize(vec3(0.0,0.0,1.0)-lights[i].lDir);

    NdotL = max(dot(normalize(-lights[i].lDir),n),0.0);

    if (NdotL > 0.0)   {
      accum += lights[i].lInt * mDiff * lights[i].lDiff * NdotL;    

       NdotHV = max(dot(n, halfVector),0.0);

      #if hasSpecularMap
        spec2 = lights[i].lSpec * texture2D(specularMap, vec2(texCoord.s, texCoord.t)).rgb * pow(NdotHV,mShine);
      #else
        spec2 = lights[i].lSpec * mSpec * pow(NdotHV,mShine);
      #endif
      
      specTotal += spec2;
    }
  }  
  
  color.rgb *= accum;
  color.rgb += specTotal;
#endif


#if lightArea
  vec3 specTotal = vec3(0.0,0.0,0.0);
  vec3 spec2 = vec3(0.0,0.0,0.0);
  float NdotL;
  float NdotHV = 0.0;

  vec3 halfVector;
  
  for (int i = 0; i < loopCount; i++) {
    halfVector = normalize(vec3(0.0,0.0,1.0)-lights[i].lDir);

   NdotL = max(dot(normalize(-lights[i].lDir),n),0.0);

   if (NdotL > 0.0)   {

    NdotHV = max(dot(n, halfVector),0.0);
   
#if hasShadow
    vec4 shadowCoord = shadowProj[i] / shadowProj[i].w;
    
    shadowCoord.z = DepthRangeA(ConvertDepth3A(shadowCoord.z,lDepth[i].x,lDepth[i].y),lDepth[i].x,lDepth[i].y);

    vec4 shadowSample;

    float shadow = 1.0;
// this seems to get around a shader crash ...    
    if (shadowCoord.s >= 0.000&&shadowCoord.s <= 1.000 && shadowCoord.t >= 0.000 && shadowCoord.t <= 1.000) if (i == 0) { shadow = getShadowVal(lDepthTex[0],shadowCoord,shadowProj[i].w,lDepth[i].z);} 
#if loopCount>1    
    else if (i == 1) { shadow = getShadowVal(lDepthTex[1],shadowCoord,shadowProj[i].w,lDepth[i].z); }
#endif
#if loopCount>2    
    else if (i == 2) { shadow = getShadowVal(lDepthTex[2],shadowCoord,shadowProj[i].w,lDepth[i].z); }
#endif
#if loopCount>3
    else if (i == 3) { shadow = getShadowVal(lDepthTex[3],shadowCoord,shadowProj[i].w,lDepth[i].z);  }
#endif
#if loopCount>4    
    else if (i == 4) { shadow = getShadowVal(lDepthTex[4],shadowCoord,shadowProj[i].w,lDepth[i].z);  }
#endif
#if loopCount>5    
    else if (i == 5) { shadow = getShadowVal(lDepthTex[5],shadowCoord,shadowProj[i].w,lDepth[i].z);  }
#endif
#if loopCount>6    
    else if (i == 6) { shadow = getShadowVal(lDepthTex[6],shadowCoord,shadowProj[i].w,lDepth[i].z);  }
#endif
#if loopCount>7
    else if (i == 7) { shadow = getShadowVal(lDepthTex[7],shadowCoord,shadowProj[i].w,lDepth[i].z); }
#endif
       
    accum += shadow * lights[i].lInt * mDiff * lights[i].lDiff * NdotL;
#else
    accum += lights[i].lInt * mDiff * lights[i].lDiff * NdotL;
#endif

    #if hasSpecularMap
      spec2 = lights[i].lSpec * texture2D(specularMap, vec2(texCoord.s, texCoord.t)).rgb * pow(NdotHV,mShine);
    #else
      spec2 = lights[i].lSpec * mSpec * pow(NdotHV,mShine);
    #endif

    #if hasShadow
        spec2 *= shadow;
    #endif

    specTotal += spec2;
    
    #if hasShadow
//      accum = texture2D(lDepthTex[0], vec2(shadowCoord.s, shadowCoord.t)).rgb;
    #endif
    
    }
 }
  
  color.rgb *= accum;
  color.rgb += specTotal;

#endif


#if lightSpot
  vec3 specTotal = vec3(0.0,0.0,0.0);
  vec3 spec2 = vec3(0.0,0.0,0.0);

  vec3 halfVector;
  float spotEffect;
  float spotDot;
  float power;
  
  for (int i = 0; i < loopCount; i++) {
    vec3 l = lights[i].lPos-vPosition.xyz;
    
    float dist = length(l);

    float att = clamp(((lights[i].lDist-dist)/lights[i].lDist), 0.0, 1.0)*lights[i].lInt;

    att = clamp(att,0.0,1.0);

    spotDot = dot(normalize(-l), normalize(lights[i].lDir));

    if ( spotDot < cos((lights[i].lCut/2.0)*(3.14159/180.0)) ) {
      spotEffect = 0.0;
    }
    else {
      spotEffect = pow(spotDot, 1.0);
    }

    att *= spotEffect;

    vec3 v = normalize(-vPosition.xyz);
    vec3 h = normalize(l + v);

    float NdotL = max(0.0, dot(n, normalize(l)));
    float NdotH = max(0.0, dot(n, h));

    if (NdotL > 0.0) {
      power = pow(NdotH, mShine);
    }
    else {
      power = 0.0;
    }

#if hasShadow
    vec4 shadowCoord = shadowProj[i] / shadowProj[i].w;
    
    shadowCoord.z = DepthRangeA(ConvertDepth3A(shadowCoord.z,lDepth[i].x,lDepth[i].y),lDepth[i].x,lDepth[i].y);

    vec4 shadowSample;

    float shadow = 1.0;
// this seems to get around a shader crash ...    
    if (shadowCoord.s >= 0.000&&shadowCoord.s <= 1.000 && shadowCoord.t >= 0.000 && shadowCoord.t <= 1.000) if (i == 0) { shadow = getShadowVal(lDepthTex[0],shadowCoord,shadowProj[i].w,lDepth[i].z);} 
#if loopCount>1    
    else if (i == 1) { shadow = getShadowVal(lDepthTex[1],shadowCoord,shadowProj[i].w,lDepth[i].z); }
#endif
#if loopCount>2    
    else if (i == 2) { shadow = getShadowVal(lDepthTex[2],shadowCoord,shadowProj[i].w,lDepth[i].z); }
#endif
#if loopCount>3
    else if (i == 3) { shadow = getShadowVal(lDepthTex[3],shadowCoord,shadowProj[i].w,lDepth[i].z);  }
#endif
#if loopCount>4    
    else if (i == 4) { shadow = getShadowVal(lDepthTex[4],shadowCoord,shadowProj[i].w,lDepth[i].z);  }
#endif
#if loopCount>5    
    else if (i == 5) { shadow = getShadowVal(lDepthTex[5],shadowCoord,shadowProj[i].w,lDepth[i].z);  }
#endif
#if loopCount>6    
    else if (i == 6) { shadow = getShadowVal(lDepthTex[6],shadowCoord,shadowProj[i].w,lDepth[i].z);  }
#endif
#if loopCount>7
    else if (i == 7) { shadow = getShadowVal(lDepthTex[7],shadowCoord,shadowProj[i].w,lDepth[i].z); }
#endif
       
     att = att * shadow;
#endif

    accum += att * lights[i].lDiff * mDiff * NdotL;    
    
    #if hasSpecularMap
      spec2 = lights[i].lSpec * texture2D(specularMap, vec2(texCoord.s, texCoord.t)).rgb * power;
    #else
      spec2 = lights[i].lSpec * mSpec * power;
    #endif

#if hasShadow
    spec2 *= shadow;
#endif

    specTotal += spec2*spotEffect;

  }  
  
  
  color.rgb *= accum;
  color.rgb += specTotal;

  #if hasShadow
  //  color = texture2D(lDepthTex[0], vec2(texCoord.s, texCoord.t)).rgba;

  #endif
#endif


#if hasReflectMap
  float environmentAmount = texture2D( reflectMap, texCoord).r;
#endif

#if hasEnvSphereMap
#if hasNormalMap
  vec3 r = reflect( u, n );
  float m = 2.0 * sqrt( r.x*r.x + r.y*r.y + (r.z+1.0)*(r.z+1.0) );

  vec3 coord;
  coord.s = r.x/m + 0.5;
  coord.t = r.y/m + 0.5;
  
  #if hasReflectMap
    color.rgb += mColor*accum*texture2D( envSphereMap, coord.st).rgb * environmentAmount;
   #else
    color.rgb += mColor*accum*texture2D( envSphereMap, coord.st).rgb * envAmount;
   #endif

#else
  #if hasReflectMap
     color.rgb += mColor*accum*texture2D( envSphereMap, vEnvTextureCoord).rgb * environmentAmount;
  #else
     color.rgb += mColor*accum*texture2D( envSphereMap, vEnvTextureCoord).rgb*envAmount;
  #endif
#endif

#endif



#if hasAmbientMap
#if lightPoint||lightDirectional||lightSpot||lightArea
  color.rgb += texture2D(ambientMap, texCoord).rgb*(vec3(1.0,1.0,1.0)+mColor*mAmb);
#else
  color.rgb = color.rgb*texture2D(ambientMap, texCoord).rgb;              
#endif
#else
#if !hasColorMap
  color.rgb += mColor*mAmb;
#else
  color.rgb += mAmb*texture2D(colorMap, texCoord).rgb;
#endif
#endif

#if alphaDepth
#if !hasAlpha
  float linear_depth = DepthRange( ConvertDepth3(gl_FragCoord.z) );

  color.a = linear_depth;
#endif
#endif


gl_FragColor = clamp(color,0.0,1.0);

#endif // !depthPack

#if depthPack

#if hasAlphaMap
  float alphaVal = texture2D(alphaMap, texCoord).r;
  if (alphaVal < 0.9) discard;
#endif

  gl_FragColor = packFloatToVec4i(DepthRange( ConvertDepth3(gl_FragCoord.z)));
#endif

}

</script>
    <script id="cubicvr-fx-general-vs" type="x-shader/x-vertex">
attribute vec3 aVertex;
attribute vec2 aTex;
varying vec2 vTex;

void main(void)
{
	vTex = aTex;
	vec4 vPos = vec4(aVertex.xyz,1.0);
	gl_Position = vPos;
}

</script>
    <script id="cubicvr-alpha-depth-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D srcTex;
varying vec2 vTex;

void main(void)
{
  float v = texture2D(srcTex,vTex).a+0.2;
                
  gl_FragColor = vec4(v,v,v,1.0);
}
</script>
    <script id="cubicvr-invert-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D srcTex;
varying vec2 vTex;

void main(void)
{
  vec4 c;

  c = vec4(vec3(1.0,1.0,1.0)-texture2D(srcTex,vTex).rgb,1.0);

  gl_FragColor = c;	  
}

</script>
    <script id="cubicvr-dof-6tap-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D srcTex;
uniform sampler2D captureTex;
varying vec2 vTex;
uniform vec3 texel;
uniform vec3 depthInfo;

vec2 filterTaps[6];

uniform float near_depth;
uniform float far_depth;

void main(void)
{
  filterTaps[0] = vec2(-0.326212, -0.405805);
  filterTaps[1] = vec2(-0.840144, -0.073580);
  filterTaps[2] = vec2(-0.695914,  0.457137);
  filterTaps[3] = vec2(-0.203345,  0.620716);
  filterTaps[4] = vec2( 0.962340, -0.194983);
  filterTaps[5] = vec2( 0.473434, -0.480026);

  float depth_test = texture2D(captureTex, vTex.xy).a;

  vec4 color = vec4(0.0,0.0,0.0,1.0);

  float depthSample = 1.0;

  vec2 radius = vec2(texel.x*2.0,texel.y*2.0);
  float effect = 0.0;
  vec2 ofsSample;

  //	  float colorDiv = 0.0;
  
  float dNear = near_depth;
  float dFar = far_depth;

  bool dln = depth_test < dNear;
  bool dgf = depth_test > dFar;
/*  
  if (dgf) color.rgb+=vec3(1.0,0.0,0.0);
  if (dln) color.rgb+=vec3(0.0,0.0,1.0);
  if (!dgf&&!dln) color.rgb+=vec3(0.0,1.0,0.0);
	*/
/* */
  for (int i = 0; i < 6; i++)
  {
	  depthSample = texture2D( captureTex, vec2(vTex.x+filterTaps[i].x*radius.x*effect,vTex.y+filterTaps[i].y*radius.y*effect)).a; 
	  effect = 0.0;

	  bool ds_gf = depthSample > dFar;
	  bool ds_ln = depthSample < dNear;

	  if (dln || ds_gf)
	  {
			effect = (depthSample > depth_test)?((depthSample-dFar)/(1.0-dFar))*2.0:((depth_test-dFar)/(1.0-dFar));	// far		  
	  }
	  else if (dln || ds_ln)
	  {
			effect = ((depthSample < depth_test)?(1.0-1.0/(dNear/depthSample)):(1.0-1.0/(dNear/depth_test))); // near
	  }
	  else if ((dln && ds_gf)||(dln && ds_ln))
	  {
		  effect = (dln && ds_gf)?(1.0-1.0/(dNear/depth_test)): //near
		  ((depth_test-dFar)/(1.0-dFar));	// far		  
	  }
    
    if (ds_ln) effect *= 8.0;
    
    effect *= 3.0;

	  ofsSample = vec2(vTex.x+filterTaps[i].x*radius.x*effect,vTex.y+filterTaps[i].y*radius.y*effect);

	  if (abs(ofsSample.x)>1.0 || abs(ofsSample.y)>1.0 || abs(ofsSample.x)<0.0 || abs(ofsSample.y)<0.0) ofsSample = vTex.xy;

	  color += texture2D( srcTex, ofsSample);   
  }
  color /= 6.0;
  /* */

  gl_FragColor = vec4(color.rgb,1.0);
}
</script>
    <script id="cubicvr-ssao-fs" type="x-shader/x-fragment">
#ifdef GL_ES
	precision highp float;
	#endif
  uniform sampler2D srcTex;
  uniform sampler2D captureTex;
	varying vec2 vTex;

	  uniform float near_depth;
	  uniform float far_depth;
	  uniform vec3 texel;

	  float compareDepths( in float depth1, in float depth2, float aoMultiplier ) 
	  {
	  float aoCap = 3.0;
	  float depthTolerance=0.015;
	  float aorange = 20.0;// units in space the AO effect extends to (this gets divided by the camera far range
	  float diff = sqrt( clamp(1.0-(depth1-depth2) / (aorange/(far_depth-near_depth)),0.0,1.0) );
	  float ao = min(aoCap,max(0.0,depth1-depth2-depthTolerance) * aoMultiplier) * diff;
	  return ao;
	  }

	  void main(void)
	  {	
	  vec2 texCoord = vTex.xy;
	  float depth = texture2D( captureTex, texCoord ).w;
	  float d;

	  float pw = texel.x;
	  float ph = texel.y;

	  float aoCap = 1.0;

	  float ao = 0.0;

	  float aoMultiplier=10000.0;

	  float aoscale=1.0;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;         
                                                               
	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;         
                                                               
	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;         
                                                               
	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  pw*=2.0;
	  ph*=2.0;
	  aoMultiplier/=2.0;
	  aoscale*=2.0;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  pw*=2.0;
	  ph*=2.0;
	  aoMultiplier/=2.0;
	  aoscale*=2.0;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  pw*=2.0;
	  ph*=2.0;
	  aoMultiplier/=2.0;
	  aoscale*=2.0;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

    ao/=16.0;
	  // ao/=16.0;

    ao = clamp(1.0-ao,0.0,1.0);


	  gl_FragColor = vec4(ao * texture2D(srcTex,texCoord).rgb,1.0);
}
</script>
    <script id="cubicvr-bloom-6tap-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D srcTex;
uniform sampler2D captureTex;
varying vec2 vTex;
uniform vec3 texel;

vec2 radius;
#define colorCap 0.90

vec2 filterTaps[6];

vec3 rangeValHDR(vec3 src)
{
  return (src.r>colorCap||src.g>colorCap||src.b>colorCap)?(src):vec3(0.0,0.0,0.0);
}

vec3 hdrSample(float rad)
{
  vec3 accum = vec3(0.0,0.0,0.0);
  float c = 0.0;
  vec3 ctemp;
  
  for (int i = 0; i < 6; i++)
  {      		    
    accum += rangeValHDR(texture2D(srcTex, vec2(vTex.x+filterTaps[i].x*radius.x*rad,vTex.y+filterTaps[i].y*radius.y*rad)).rgb).rgb;      		    
  }

  accum /= 4.0;

  return accum.rgb;
}


void main(void)
{
  vec3 color;
  radius = vec2(texel.x,texel.y);

  filterTaps[0] = vec2(-0.326212, -0.405805);
  filterTaps[1] = vec2(-0.840144, -0.073580);
  filterTaps[2] = vec2(-0.695914,  0.457137);
  filterTaps[3] = vec2(-0.203345,  0.620716);
  filterTaps[4] = vec2( 0.962340, -0.194983);
  filterTaps[5] = vec2( 0.473434, -0.480026);    		  


  color = hdrSample(4.0);
  color += hdrSample(6.0);
  color += hdrSample(12.0);
  gl_FragColor.rgb = color/4.0;
  gl_FragColor.a = 1.0;
}
</script>
		<script>
      var shaderList = [];
      var fxChain;
      var shaders = {};
      var gl;
			var canvas_w, canvas_h, aspect;
			var canvas, scene;
      var audioData = "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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANZD8AEdAAAAoAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5D8ACPA4AAjwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ACgA/AA1gPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5MEACPAAAAvgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANZD8ADWA/AAoAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5D8AC+A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ACgA/AA1gPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5MEAAAAAAAvgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHRAAAR1AAADWA/AAoAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC+A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9D8ACgA/ABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1MCAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9D8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1MEAEdAAAAjwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9DgAAAAAAAjwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ACPA/ABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AEdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9MEACPA/AAjwOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANZD8AEdAAAAoAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5D8ACPA4AAjwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ACgA/AA1gPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5MEACPAAAAvgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANZD8ADWA/AAoAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC+A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPBD8ACgA/AA1gPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQBAAAR1AAADWA/AA8APwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9D8ADwA/ABHUwgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1MCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9D8ADWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1MEAEdTBAAjwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9DgAAAAAAAjwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ACPA/ABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AEdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9MEACPA/AAjwOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANZD8AEdAAAAoAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5D8ACPA4AAjwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ACgA/AA1gPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5MEACPAAAAvgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANZD8ADWA/AAoAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5D8AC+A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ACgA/AA1gPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5MEAAAAAAAvgPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABfRAAAR1AAADWA/AAoAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC+A/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9D8ACgA/ABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1MCAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9D8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR1MEAEdAAAAjwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9DgAAAAAAAjwPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ACPA/ABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AEdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9MEACPA/AAjwOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANZD8AEdAAAAoAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5D8ACPA4AAjwAAAAAAAAC+0AAAvjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ACgA/AA1gPwAAAAAAC+cAAAAAoDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAoDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5MEACPAAAAvgPwAAAAAAC+cAAAAAoDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBD8ADWA/AAoAPwAAAAAAC+0AAAvjoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwgAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwgC+A/AAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwgAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI9D8ACgA/AAoAPwAAAAAAC+cAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAA/AAAATCAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAATCAAAAAAC+cAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATCAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABxWAAAR1AAACgA/AAjwPwAL4wAAC+kAAQ1gAAER0fAwAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAABMIAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHYAAAAAAAAAABMIAoAAAAAAKBAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAABMIAAAAAAAAKBAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4PwAI9D8ACPA/ABHUwgAAAKBAC+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAR1MCAAAAAAAAAAAAAAKBAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHYAAAI9D8ACgAAAAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAR1MEAEdTBAAjwPwAL7QAAC+oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABxWAAAI9DgAAAAAAAjwPwAAAAAAC+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHeAAAKBD8ACPA/ABHQAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AEdAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABU/AAAI9MEACPA/AAjwOAAAAAAAC+sAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABxWAAANZD8AEdAAAAoAPwAL5wAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAj+AAAL5D8ACPA4AAjwAAAL5cIAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAA4AAAAAAAL4AAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4AAAKBD8ACgA/AA1gPwAL5QAAC+kAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABHYAAAL5MEACPAAAAvgPwAL5wAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABHeAAANZD8ADWA/AAoAPwAL7QAAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABU/AAAL5D8AC+A/AAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABxWAAAKBD8ACgA/AA1gPwAAAAAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AAAA/AAAAAAAAAAAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABHYAAAL5MEAAAAAAAvgPwAL58IAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAL4AAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABxWAAAR1AAADWA/AAoAPwAL5wAAC+kAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAPwAAAAAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABHYAAAAAAAAC+A/AAAAAAAL5QAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAAAAAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4PwAI9D8ACgA/ABHQAAAAAAAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAR1MCAAAA/AAAAAAAAAAAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABU/AAAI9D8AAAAAAAAAAAAL5QAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAACOukEAR1MEAEdAAAAjwPwAL7QAAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHQAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABxWAAAI9DgAAAAAAAjwPwAAAAAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAADgAAAAAAAAAAAAAAAAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABU/AAAKBD8ACPA/ABHQAAAL5QAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AEdAAAAAAAAAL5wAAC+ygoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABHeAAAI9MEACPA/AAjwOAAL7cIAC+sAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABxWAAANZD8AEdAAAAoAPwAAAAAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABHYAAAL5D8ACPA4AAjwAAAL5cIAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAA4AAAAAAAL4AAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAj4PwAKBD8ACgA/AA1gPwAL5QAAC+kAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAj+AAAL5MEACPAAAAvgPwAL5wAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAqvAAANZD8ADWA/AAoAPwAL7QAAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABU/PwAAAAAAC+A/AAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABHeAAAPBD8ACgA/AA1gPwAAAAAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAA/AAAAAAAAAAAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxAANYAAAAAAAAAAAAAAL58IAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL4AAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAB/GAAAR1AAADWA/AA8APwAL4wAAC+kAAQ8AAAEUAvAwAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQIAAAAAAAAAAAAAA1gAAAAAKBAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAAAKBAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoIPwAI9D8ADwA/ABHUwgAAAKBAC+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAR1MCAAAAAAAAAAAAAAKBAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQIAAAI9D8ADWAAAAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAR1MEAEdTBAAjwPwAL7QAAC+oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/GAAAI9DgAAAAAAAjwPwAAAAAAC+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQOAAAKBD8ACPA/ABHQAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AEdAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABffAAAI9MEACPA/AAjwOAAAAAAAC+sAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAB/GAAANZD8AEdAAAAoAPwAL5wAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOAAAL5D8ACPA4AAjwAAAL5cIAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAA4AAAAAAAL4AAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAoIAAAKBD8ACgA/AA1gPwAL5QAAC+kAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABQIAAAL5MEACPAAAAvgPwAL5wAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABQOAAANZD8ADWA/AAoAPwAL7QAAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABffAAAL5D8AC+A/AAAAAAAAAAAAAAAAABDQwgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/GAAAKBD8ACgA/AA1gPwAAAAAAC+wAAA8AwwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AAAA/AAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQIAAAL5MEAAAAAAAvgPwAL58IAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAL4AAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABU2AAAR1AAADWA/AAoAPwAL5wAAC+kAABQAAAENYQAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAPwAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1oAAAAAAAAC+A/AAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABrIPwAI9D8ACgA/ABHQAAAAAAAAC+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAR1MCAAAA/AAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/vAAAI9D8AAAAAAAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABrOkEAR1MEAEdAAAAjwPwAL7QAAC+oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABU2AAAI9DgAAAAAAAjwPwAAAAAAC+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAADgAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/vAAAKBD8ACPA/ABHQAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8AEdAAAAAAAAAL5wAAC+ygoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1uAAAI9MEACPA/AAjwOAAL7cIAC+sAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABU2AAANZD8AEdAAAAoAPwAAAAAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAA1oAAAL5D8ACPA4AAjwAAAL5cIAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAA4AAAAAAAL4AAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABrIPwAKBD8ACgA/AA1gPwAL5QAAC+kAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABrOAAAL5MEACPAAAAvgPwAL5wAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAf/AAAKBD8ADWA/AAoAPwAL7QAAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAEwgAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAA/vPwAAAEwgC+A/AAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAEwgAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAA1uAAAI9D8ACgA/AAoAPwAAAAAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAA/AAAATCAAAAAAAACgoAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAxAAKAAAAAAAAAAAATCAL58IAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATCAL4AAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAB/GAAAR1AAADWA/AA8APwAL4wAAC+kAAQ8AAAEUAvAwAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQIAAAAAAAAAAAAAA1gAAAAAKBAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAAAKBAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoIPwAI9D8ADwA/ABHUwgAAAKBAC+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAR1MCAAAAAAAAAAAAAAKBAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQIAAAI9D8ADWAAAAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAR1MEAEdTBAAjwPwAL7QAAC+oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/GAAAI9DgAAAAAAAjwPwAAAAAAC+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQOAAAKBD8ACPA/ABHQAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AEdAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABffAAAI9MEACPA/AAjwOAAAAAAAC+sAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAB/GAAANZD8AEdAAAAoAPwAL5wAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOAAAL5D8ACPA4AAjwAAAL5cIAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAA4AAAAAAAL4AAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAoIAAAKBD8ACgA/AA1gPwAL5QAAC+kAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABQIAAAL5MEACPAAAAvgPwAL5wAAC+wAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABQOAAANZD8ADWA/AAoAPwAL7QAAC+oAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAAAAAAAAAAAAAAAAAAAAAAAABffAAAL5D8AC+A/AAAAAAAAAAAAAAAAABDQwgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAMEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/GAAAKBD8ACgA/AA1gPwAAAAAAC+wAAA8AwwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAD8AAAA/AAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQIAAAL5MEAAAAAAAvgPwAL58IAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAL4AAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABU2AAAR1AAADWA/AAoAPwAL5wAAC+kAABQAAAENYQAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAPwAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1oAAAAAAAAC+A/AAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABrIPwAI9D8ACgA/ABHQAAAAAAAAC+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwIAR1MCAAAA/AAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/vAAAI9D8AAAAAAAAAAAAL5QAAAACgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAABMIAAAYBAL4MEAAABMIAAAAAAPBD8AI6A/AAvgPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAATCER2aDwAABgEAAAAAAR1AAAC0A/AA1gPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAAYBAX0MEAAABMIAAAAAAX1D8AC+A/AA8APwAAAAAAAAAAAAAAAAAAAAAAAABMIAAATCEX2aDwAABMIAAAAAAjpD8ADWA/ABHQAAAAAAAAAAAAAAAAAAAAAAAAAABMIAAAYBAR0MEAAABMIAAAAAAP5D8ADwA/ABfQPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAATCEP6aDwAABgEAAAAAAX1D8AEdAAACOgPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAAYBAX0MEAAABMIAAAAAAjpD8AF9A/AA/gPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAATCEX2aDwAABMIAAAAAAPBD8AI6A/ABfQPwAAAAAAAAAAAAAAAAAAAAAAAABgEAAAYBAP4MEAAABMIAAAAAAX1D8AD+A/ACOgPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAATCEPCaDwAABMIAAAAAAjpD8AF9A/AA8APwAAAAAAAAAAAAAAAAAAAAAAAABMIAAAYBAX0MEAAABMIAAAAAAL5D8AI6A/ABfQPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAATCEX2aDwAABgEAAAAAAX1D8ADwA/ACOgPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAAYBAPAMEAAABMIAAAAAAjpD8AF9A/AAvgPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAATCEL6aDwAABMIAAAAAALRD8AI6A/ABfQPwAAAAAAAAAAAAAAAAAAAAAAAABgEAAAYBAX0MEAAABMIAAAAAAX1D8AC+A/ACOgPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAATCEX2aDwAABgEAAAAAAL5D8AF9A/AAtAPwAAAAAAAAAAAAAAAAAAAAAAAABMIAAAYBAL4MEAAABMIAAAAAAX1D8AI6A/ABfQPwAAAAAAAAAAAAAAAAAAAAAAAABMIQvoECEWiaDwAABgEBaIAAAR1AAAC0A/AAvgPwEWggAAAAAAAAAAAAELQvBgAABMIQtIPwAWgMEAAABMIAAAAA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AAAAAAAAAAAAvtwQAAAMOgAABgEAAAYBAAAAAAAAAAAAAAwDAAAD8AAAAAAAAAPwAAAAAAAAAAAAAAAAAAAMOQAABMEAAAYBAAAMAAAACgEAAAwCAX0FAQF9A/ACOgPwAAAAAAAAAAAAAAAAAAAMOAAABgEAAAYBAAAAAAAACgEAAAwBAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMNwAABMEAAAYBAAAAAAAACgEAAAwAAjoD8AI6A/AA/gPwAAAAAAAAAAAAAAAAAAAMNgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMNQAABMEAAAYBAAAAAAAACgEAAAAAAPAFAQD+A/ABfQPwAAAAAAAAAAAAvgwEAAAMNAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMMwAABMEAAAYBAAAAAAAACgEAAAAAAX0D8AF9A/ACOgPwAAAAAAAAAAAAAAAAAAAMMgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAABQEAAAPwAAAAAAAAAAAAAAAAAAAMMQAABMEAAAYBAAAAAAAACgEAAAAAAjoFAQI6A/AA8APwAAAAAAAAAAAAAAAAAAAMMAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMLwAABMEAAAYBAAAAAAAACgEAAAAAAL4D8ADwA/ABfQPwAAAAAAAAAAAAAAAAAAAMLgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMLQAABMEAAAYBAAAAAAAACgEAAAAAAX0FAQF9A/ACOgPwAAAAAAAAAAAAAAAAAAAMLAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMKwAABMEAAAYBAAAAAAAACgEAAAAAAjoD8AI6A/AAvgPwAAAAAAAAAAAAAAAAAAAMKgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAABQEAAAPwAAAAAAAAAAAAAAAAAAAMKQAABMEAAAYBAAAAAAAACgEAAAAAALQFAQC+A/ABfQPwAAAAAAAAAAAAAAAAAAAMKAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMJwAABMEAAAYBAAAAAAAACgEAAAAAAL4D8AF9A/ACOgPwAAAAAAAAAAAAAAAAAAAMJgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMJQAABMEAAAYBAAAAAAAACgEAAAAAANYFAQI6A/AAtAPwAAAAAAAAAAAAAAAAAAAMJAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMIwAABMEAAAYBAAAAAAAACgEAAAAAAPAD8AC0A/AAvgPwAAAAAAAAAAAAAAAAAAAMIgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAABQEAAAPwAAAAAAAAAAAAAAAAAAAMIQAABMEAAAYBAAAAAAAACgEAAAAAAR0FAQC+A/AA1gPwAAAAAAAAAAAAAAAAAAAMIAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMHwAABMEAAAYBAAAAAAAACgEAAAAAAX0D8ADWA/AA8APwAAAAAAAAAAAAAAAAAAAMHgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMHQAABMEAAAYBAAAAAAAACgEAAAAAAjoFAQDwA/ABHQPwAAAAAAAAAAAAAAAAAAAMHAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMGwAABMEAAAYBAAAAAAAACgEAAAAAAP4D8AEdA/ABfQPwAAAAAAAAAAAAAAAAAAAMGgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAABQEAAAPwAAAAAAAAAAAAAAAAAAAMGQAABMEAAAYBAAAAAAAACgEAAAAAAX0FAQF9A/ACOgPwAAAAAAAAAAAAAAAAAAAMGAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMFwAABMEAAAYBAAAAAAAACgEAAAAAAjoD8AI6A/AA/gPwAAAAAAAAAAAAAAAAAAAMFgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMFQAABMEAAAYBAAAAAAAACgEAAAAAAPAFAQD+A/ABfQPwAAAAAAAAAAAAAAAAAAAMFAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMEwAABMEAAAYBAAAAAAAACgEAAAAAAX0D8AF9A/ACOgPwAAAAAAAAAAAAAAAAAAAMEgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAABQEAAAPwAAAAAAAAAAAAAAAAAAAMEQAABMEAAAYBAAAAAAAACgEAAAAAAjoFAQI6A/AA8APwAAAAAAAAAAAAvtAAAAAMEAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMDwAABMEAAAYBAAAAAAAACgEAAAAAAL4D8ADwA/ABfQPwAAAAAAAAAAAAAAAAAAAMDgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMDQAABMEAAAYBAAAAAAAACgEAAAAAAX0FAQF9A/ACOgPwAAAAAAC+cAAAAAAAAAAMDAAABgEAAAYBAAAAAAAACgEAAAAAAAAFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMCwAABMEAAAYBAAAAAAAACgEAAAAAAjoD8AI6A/AAvgPwAL46BAAAAAAAvtAAAAAMCgAABgEAAAYBAAAAAAAACgEAAAAAAAAD8AAABQEAAAPwAAAKBAAAAAAAAAAAAAAMCQAABMEAAAYBEKCEwQAACgEAAAAAALQFAQC+A/ABfQPwAAAKBAAAAAAAAAAAAAAMCAAABgEAAAYBAAAEwgAACgEAAAAAAAAFAQAAA/AAAAUBAAAKBAAAAAAAAAAAAAAMBwAABMEAAAYBAAAEwgAACgEAAAAAAX0D8AF9A/ACOgPwAAAKBAC+fDAAAAAAAAAMBgAABgEAAAYBAAAEwgAACgEAAAAAAAAD8AAAA/AAAAPwAAAKBAC+AAAAAAAAAAAMBQAABMEAAAYBEL6D8AAACgEAAAAAAL4FAQI6A/AAtAPwAAAKBAAAAAAAvtAAAAAMBAAABgEAAAYBAAAEwgAACgEAAAAAAAAFAQAAA/AAAAUBAAAKBAAAAAAAAAAAAAAMAwAABMEAAAYBEKCMEAAACgEAAAAAAX0D8AC0A/ABfQPwAAAKBAAAAAAAvtAAAAAMAgAABgEAAAYBAAAEwgAACgEAAAAAAAAD8AAABQEAAAPwAAAKBAAAAAAAAAAAAAAMARFAQAAQoIAAEvo8IAAABMIBxWAAAR1AAACgA/AAjwPwAL4wAAC+kAAQ1gAAER0fAxCPTBgQj4MCAAAAAAAABMIAAAwIAAAAAAAABMIAAAAAAAAAAAAACgoAAAAAAAAAABEdQAAAAAMCAAAAAAAABMIBHYAAAAAAAAAABMIAoAAAAAAKBAAACgoAAAAAAAAAABFATBgAAAMCAAAAAAAABMIAAAwIAAAAAAAABMIAAAAAAAAKBAAACgoAAAAAAAAAABCPQAAAAAMCEvowAAAABMIAj4PwAI9D8ACPA/ABHUwgAAAKBAC+wAAAAAAAAAAAABEdTBgAAAMCAAAAAAAABgEAAAwIAR1MCAAAAAAAAAAAAAAKBAAACgoAAAAAAAAAABFAUAAAAAMCAAAAABCgjBgBHYAAAI9D8ACgAAAAAAAAAL5QAAAACgoAAAAAAAAAABCPTBgAAAPwAAAAAACPAwIAAAAAAAAAAAAAAAAAAAAAAL5QAAAACgoAAAAAAAAAABEdUAAAAATCAAAAAAAAAwIAAAwIAR1MEAEdTBAAjwPwAL7QAAC+oAAAAAAAAAAAABFAXBgAAATCAAAAAAAAAwIAAAAAAAAAAAAAAAABHQAAAAAAAAAAAAAAAAAAAAAAABCPUAAAAATCEvo8GAAAAwIBxWAAAI9DgAAAAAAAjwPwAAAAAAC+wAAAAAAAAAAAABEdXBgAAATCAAAAAAAAAwIAAAAAAAADgAAAAAAAAAAAAAAAAAAACgoAAAAAAAAAABFAYAAAAATCAAAAAAAAAwIBHeAAAKBD8ACPA/ABHQAAAL5QAAAACgoAAAAAAAAAABCPXBgAAATCAAAAAAAAA/AAAAwIAAAD8AEdAAAAAAAAAAAAAAAACgoAAAAAAAAAABEdYAAAAATCAAAAAAAABMIBU/AAAI9MEACPA/AAjwOAAAAAAAC+sAAAAAoBAAAAABFAbBgAAATCAAAAAAAABMIAAAwIAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAoBAAAAABCPYAAAAATCAvoMCAAABMIBxWAAANZD8AEdAAAAoAPwAL5wAAC+wAAAAAoBAAAAABEdbBgAAATCAAAAAAAABMIAAAwIAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAABFAUAAAAATCAAAAAAAABMIAj+AAAL5D8ACPA4AAjwAAAL5cIAC+oAAAAAoBAAAAABCPbBgAAATCAAAAAAAABMIAAAwIAAAMEAAAA4AAAAAAAL4AAAAAAAAAAAoBAAAAABEdUAAAAATCAAAAAAAABMIAj4AAAKBD8ACgA/AA1gPwAL5QAAC+kAAAAAoBAAAAABFAXBgAAATCAAAAAAAABMIAAAwIAAAD8AAAA/AAAAAAAAAAAAAAAAAAAAoBAAAAABCPUAAAAATCAvoMAwAABMIBHYAAAL5MEACPAAAAvgPwAL5wAAC+wAAAAAoBAAAAABEdXBgAAATCAAAAAAAABMIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAABFAQAAAAAwYAAAAAAAABMIBHeAAANZD8ADWA/AAoAPwAL7QAAC+oAAAAAoBAAAAABCPXBgAAATCAAAAAAAABMIAAAAAAAAMEAAAAAAAAAPwAAAAAAAAAAAAAAoBAAAAABEdQAAAAATCAAAAAAAABMIBU/AAAL5D8AC+A/AAAAAAAAAAAAAAAAAAAAoBAAAAABFATBgAAATCAAAAAAAABMIAAAwIAAAMEAAAAAAAAAAAAAAAAAAAAAAAAAoBAAAAABCgQAAQoIAAAvoMAQAABMIBxWAAAKBD8ACgA/AA1gPwAAAAAAC+wAAAAAoBAAAAABEdTBgAAAAAAAAAAAAABMIAAAwIAAAD8AAAA/AAAAAAAAAAAAAACgoAAAoBAAAAABCPQAAQj4PwAAAAAAAADAgBHYAAAL5MEAAAAAAAvgPwAL58IAAACgoAAAoBAAAAABCgTBgAAAPwAAAAAAAABMIAAAwIAAAAAAAAAAAAAAAAAL4AAAAACgoAAAoBAAAAABFAQAAQvoMQAAAAAAAABMIBxWAAAR1AAADWA/AAoAPwAL5wAAC+kAAAAAoBAAAAABCPTBgAAAPwAAAAAAAABMIAAAwIAAAAAAAAAAAAAAPwAAAAAAAACgoAAAoBAAAAABEdQAAAAATBAAAAAACgDBgBHYAAAAAAAAC+A/AAAAAAAL5QAAAACgoAAAoBAAAAABFATBgAAATBAAAAAAAAAAAAAAwIAAAAAAAAAAAAAAAAAAAAAAAACgoAAAoBAAAAABCPQAAAAATBAAAAAACPA/AAj4Pw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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AhoFAQAABQEAAAUBAAAAAAAAAAAAAAAAAAAMMAAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQIaA/ABaAUBAAAAAAAAAAAAAAAAAAAMLwAABgEAAAYBAAAAAAAACgEAAAAAAQ0FAQAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMLgAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQENA/ACGgPwAAAAAAAAAAAAAAAAAAAMLQAABgEAAAYBAAAAAAAACgEAAAAAAWgFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMLAAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQFoA/ABDQUBAAAAAAAAAAAAAAAAAAAMKwAABgEAAAYBAAAAAAAACgEAAAAAAhoD8AAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMKgAABMEAAAYBAAAAAAAACgEAAAAAAAAD8AIaA/ABaAPwAAAAAAAAAAAAAAAAAAAMKQAABgEAAAYBAAAAAAAACgEAAAAAAQ0FAQAABQEAAAUBAAAAAAAAAAAAAAAAAAAMKAAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQENBQECGgUBAAAAAAAAAAAAAAAAAAAMJwAABgEAAAYBAAAAAAAACgEAAAAAAWgFAQAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMJgAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQFoA/ABDQPwAAAAAAAAAAAAAAAAAAAMJQAABgEAAAYBAAAAAAAACgEAAAAAAhoFAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMJAAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQIaA/ABaAUBAAAAAAAAAAAAAAAAAAAMIwAABgEAAAYBAAAAAAAACgEAAAAAAQ0D8AAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMIgAABMEAAAYBAAAAAAAACgEAAAAAAAAD8AENA/ACGgPwAAAAAAAAAAAAAAAAAAAMIQAABgEAAAYBAAAAAAAACgEAAAAAAWgFAQAABQEAAAUBAAAAAAAAAAAAAAAAAAAMIAAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQFoBQEBDQUBAAAAAAAAAAAAAAAAAAAMHwAABgEAAAYBAAAAAAAACgEAAAAAAhoFAQAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMHgAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQIaA/ABaAPwAAAAAAAAAAAAAAAAAAAMHQAABgEAAAYBAAAAAAAACgEAAAAAAQ0FAQAAA/AAAAUBAAAAAAAAAAAAAAAAAAAMHAAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQENA/ACGgUBAAAAAAAAAAAAAAAAAAAMGwAABgEAAAYBAAAAAAAACgEAAAAAAWgD8AAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMGQAABMEAAAYBAAAAAAAACgEAAAAAAAAD8AFoA/ABDQPwAAAAAAAAAAAAAAAAAAAMFwAABgEAAAYBAAAAAAAACgEAAAAAAhoFAQAABQEAAAUBAAAAAAAAAAAAAAAAAAAMFQAABMEAAAYBAAAAAAAACgEAAAAAAAAFAQIaBQEBaAUBAAAAAAAAAAAAAAAAAAAMEwAABgEAAAYBAAAAAAAADAAAAAAAAQ0FAQAAA/AAAAPwAAAAAAAAAAAAAAAAAAAMEQAADAAAAAYBAAAAAAAAAAAAAAAAAAAFAQENA/ACGgPwAAAAAAAAAAAAAAAAAAAMDwAAAAAAAAYBAAAAAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMDQAAAAAAAAYBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMCwAAAAAAAAYBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMCQAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPHwAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AgYDBAIEAAkDCAMAAAYECv8DAgMABQgEBQEBBgv+AgIAAw4AAwUAAAcDBwYBAAkGAAIDCQgHBAIIAAcAAgMDCgMAAAADAQUIAwUBDgEJ/wMAAw4CAwD7BwEDAwIHCA4HAgUFAAkACQr6AAICB/8FAwr/AwkBAAICAwgKAAgAAAgIAAIDAgQGAAMBCAYHBgYFBgAFBQMDBQADAgYAAwUCBAYACwgAAQEFCQgA/wcHAwsAAwQCAwYGAP4ABQYFCAYABgULAAEBBgUDBQkC+wAEBwYCBwAHDAMCAf4JBwMDBwACBQYDBwMABwEDBQAABQoACQMAAwcDAAMHBQUABQYDBAAKAQYDBwYBAgIFBv8GAAAIBwMECgAJCQAAAAMBCAADDP4CBQMDAQUDBwgFCf/7BQ4CBQMFAAMFAAcD/gkIDgcBAAAKBAMDAAAEBAYAAAAHAQgCCf4KCAAHBQIAAAIFBQAJCQIFAwgEBAMDCAMHAwAAAQgBAQMDAgcCBgACAAMLAAkDAAgFBwUIAAMMBwYFAAICAwAOAAAHAAMLBQADBwUJAgACAgMFCgACAgAHBgUAAwMJCAQAAgkDAwoDCfsCAgAFAwQJ/wIIBwIHAAcHBgcDBQAHBgAJ+QQCAAgHBgADDAAQAAAIBAUCCgECAwAICP8CBgMCBgcDAv4AAwUCAggFAAwCAgYABwUOCAADAAMH/QYICAMDBwAAAwIBBAUHAwAHBQQBBgUCAQAJBwMCAgUDAgn9AwIFCQUFAwADBgUDBQoHCAYCBAAAAAkAAwcABQIAAwYHAAYHAwoCAAUDAAUEBQEDBAQDBQEIBQgEAwAACQMACgMEBQYABQP9BQUAAQQABQcDBQkHAwkA/wcCBgQDBAcFBAMAAAcCCQMAAAIFAAkEBAYDBQkDAwAKAAYFAgIBAAIACgIDBwYICAIAAAIABwkAAAMDAwUCBwcDAgn/AgACAwgDAwYGAAcAAQoFBwMDAwAKAAAGAwoIAwAAAwIGBAMDAAMHCAUAAwcFBQMAAgAGCQAEAAUFAAoIBgACBwcHAAAAAwgDCAUCAwcDAwUCAAUDAwcD/QAJAAUDAgQIBAAJAwcHBwADCgIAAAAKBgIHCAH+BAgEBAMACAgIAgAAAAgFAAIAAwQFBQQHBQUIAwcAAAIGBgcAAwMEBQEHBQQIAAACAgECAgUIBAAACAUFBgIJCAADAAAAAgMHCQIDBwUGAgMCBQcGBAYAAwICBwACBQQG/gQHAgoBBAIJAwMHAwMHBAYBBQAFAwMLAgIDBwn/CAADBwMDCf8AAgUFBQUFAgIACQQDBQMJBwgAAAIABQAGCQACAQkEBAADBgkFAAIIAAcDBQADCQAHAAAFAwIHAwIDCQEAAgUCCwMJBwADBgkEAAMDBwMAAAICBgcHCAIAAwIDBAMDAgMDAwEAAwYFBQUJAQADBwUIBgcHCAAGAgAACAUBAQIABwMABwgKCAIAAwD9CAUFAAIJAQMAAgMGCgkCAgEDBwACBwUKAggDAAUACQMAAvsHAAAFAwcCCAYEBAAICAIHBgUCBgAFAQUFBQQFBwP/AAQDAwcCBAUDCQIDAAYJAgUAAAIABAoHBAYJAAMAAAEHAgQGAgMDBQIECAcJBAICAQMABQMCAgcEAwMCAAoIBAUAAAcDAgUAAggIBwQIAAMDAgcGAwACBQkHBQUDAAgEAAAAAAkICAgCAAAMAAcDAgQDAgEDAP4HCA4DBgcCBAAHCAEH/wgC/gIEAAYGCQ4BAAIBAAcGAwACAAYFAwADAAkJAgMAAwcFBgMIAwMFBAcFAwAACQMA/wAGAgQIBgUAAAgAAwMACQMKBQAEAAgGBQgBBgMEBgAAAgYFBQoCAwADAwUFAAUDAAIAAAgIAAIJCgADAgIHBwUFAwEACAMACAYCBgcCAAIACAgCBwcAAAUDAwADBAMDAQIDAgQDCAYEBgEDCQIF/gUCAgUABwMABwUKCAAEAgcDAwECBwMDBwAAAwUFBgYFBQAAAgAIBwcDCggBAwAACQIHCQIAAAACBQoABQQFCQAAAgMJAgUJAQIBBQEFAwAEBQEFBQMFDAAGBgAACgMDAwcDBwABAwMAAwIJCAUDAAIDAAIACQQDBwAFAAAIBQgHBwYABgEBBAUOCAEFAAYAAAADAwUICAACBQUIBAACBQAHBAMABQUHCAIABQAICAgBAgIIAAABBQMEAQkFBAEDAAIFBQUAAAMFAAIFBgUHAwUGAwAHAwQGAwQGBQAACAAGAwIBAwIHAgEDCgkFAQMCAQICBgMDAgQGBQIAAwkJCAAAAAYCAwMFAwcIAQQEAAcEBQkCAAAEAAAJAwIGBQQIAAMDBQMFBwAAAwYDBQYDAAcBCAAACAgIAAgGAgYBAwcBAwQAAAAAAAkGAQoECAoFAAAEAAkKAAMAAAgDBQAHCQgKAgMDAAUDBwUAAgUFAgIBAAgGAgQCAgMBAwkFAAAFCAoCAggDBQYDAAMCAAwFBAcAAwcGAAMHAAYDAAQDAAIJAwMCCAgAAAAHCgMHBgUBAwcAAQAFCAkAAQAABQYEAwMIBwoCBAMAAgUHBQAAAAcEAwMEBQQEAwcC/wMJCAUDAgEFAwIFBQECBQUABgAFCgIHAwACAAQDBQYCCgICAwAACAcDAwIECQAAAwcEBAUDAAIACAgDBQUFBgMAAAAGAQYFAQUFAwADBwAGBAMFBAACBQIACgUEBQMFBQACBwcDAwcCAwAACQADAQIFBQYAAwYHCgUABAACBAkDAwAEBwYCAgIGBQkFAQAFAwMFBgACAwACAwIDBQMFCQQCAgADAwIEBgMFBQMACAMDBAYEDQIAAwECAgMHBQUAAAcCAwMEBQQJBQAAAAEHBQIEBQAFCgMFAwAJBgMCBQEDBwUDAgECAwIDBwUGBQAIAwIFBQYFBQYDAgAAAwQDBwMCAAYDAgUEBAcHBAMFAAAHAAcFAgMHAgMHBgIDAgUJAf4FAgIEBQYCBAUJAgMEAgIABwkABQAJBAACAwcDAAkDBQQEAAMGAAUCAAMFBQcGAAMFAQUIAwIDBAgDAgIDAwkEAwACBQUAAgUJAgMFAQIBAAUCAwIFBAMHBQIECAgAAwYDAgMABQYDAgcCAwYFAwQFAgYGAAIDAAUBBQYHAwAFAgICAQUDBAMDBQYFAgcJBgUAAwUFBgEBAAQEAwMEAwMGBwUA/wIEBwgHAwUCBQkAAAMDBQUHAAIDAAcEBAgEAgQIAwMCAgMFAgMEAQIDAAcHBgMICAUDAgECAgMCCAMDBQUCBAYCAAQAAgYFAwQBBQgGAQUEAAUGBgUAAgIHBQMDAgMIBAMAAAEFCAQGBwMDAwQCAQMHBgMAAwIABAAIBwMECAMBAwMABwEFBgAAAwQDBQUDBQYGBAMAAwMFAwICAgMFBwADAwIHBgUEAgUFCQEEBgADAgAAAAMGBwMFBwMFBwMABwUFBgABBQYFBQUAAwIDAwMEAwQFBwMCAgEFBQUHAwQBBQMDBgMABQQFAgADBQMDBQMCAwUFAwAFBgUJBAYBAwMABgAABwIJBwAAAwkHAwUABQQAAAECAwUFBgQCAAcCBgADAgMFAwQEBQYECAEDAwICAwIDAgMCAwUEBAUFCQICAgADAQUDAwUDBQIACQMDAgcHAwAAAQUCAgUICAgHBgACAAIDAAIEBwcDBQMFBQUIAQEDBAMCAwIFAQYJBAIDBQUABAAEAwAHBAAFAgQGAwUAAwcDBQQDAgIGAgcGBQgEAwMFAAADAAcGAgUDAgYHAwAFBgUDAAIDAgEFBQcFBAIHAwICAAcAAAQDBwUEBwMGBgYAAAMHAwMCAgICAgcDAAMHBgkHBQMABAUEAgEFBAQDAAIFAAUCBAgBAQIGBwYFBQQGAgMAAgACBAMFBAMDCAkCBwUCAgEAAgIDAwoCAAUDAAMDAwgIBAMDAgMEAAIFBQUFCQEDAgMGBgUEAAQFCAAAAgUFBQMCAQIDBQMDAgcFBQUHBAMDAwcBAAABBQMHBQUGAAMDAwQBBQMIBgQDAAIJAwUEBwUDAAEEAwIHBQYFAgIAAgIFBQUHBgIBAgUDBAAABwYCAgIFBgcGBgIAAAkFAwMEAwQGAwMAAAUIBgIDBQAEBQMFAwIDBAUDAwMDAwUHBwMAAwICAAMHAgMFBwMABQIGBQQGBAAABAICBwcDBAICAwQCBwMEBwcDAAEDBQgHBgEDAAMCAwACBQQIAwAFBAMFBwUFBgMDBAIEBQIECAMFBAQDAQIBBgEBBQMCAwYEBQUDAgMCAwMFBQYEBQUDAgADBwcGBQMCAgMDAwUDBQUDAgACAwcGAwMDBQMABgMFBwUHAwIBAgUABAIDBwMDCAcFBgkEAgMAAgMAAAMCAwgGAgcDBAgDBgMEAwIIAAUAAQMEAwQEAwAFBQkCAwADBwYBAwMDBQUDAwABAAUDAgQCBQUDBQcDBQYCAwMCAgEEAAcJBAYBAgMEBQQFAAMHAwQCAgMFCAcGAAAFAgIDAwMDBAIGBAIDBQUGBQUABQMCBgMDAwIFBgUEAwcEBQYCAAAFAgMFAwUDAgMFAgIFBgMFAwIFAQIFBQgHBAMDAwAFAwICBgcEAgADAwMIBQUAAQMDAwICAwUFBwMCAwUGBQMCAgUAAwMEBAQFBQcGAAUDAwIDBQQAAwIFAwQHAwMHBQQCAAIFBgQDAwMEBAADBwQDAwIEAwACBQUGBwYCAwIBBAMDAwMEBAUEAAAHBQkFAAAFBAIGAgIEAgYGBQACAgQGBgIDAAIHAgAFCAcFAwMFBQAFBQUFAwIAAQEDBwMFBQQDAwMEBAQEBwUDAgMDAwQGAgcDAAMCBQUFAwIIAwQDAAUGBAMFBAABAgUFAwMHBwYEBAIDAwMFBQMFBQUAAAIBCAMEBQUDAgQDAgcCBAMCAgMCAQYJAgQBBQUDAwUFAwIGAwICAgYGBQYDAgICBgMDAwIFBAQAAgMFBwcFBQIBAgcAAwICCAcBAwIDBgYCAwcEBAUBAAQCAwUFAwQDAgQCAgMGBgYEAwMCBwMHBQACAwMAAgMABwUFBgIDAwUHBQUAAgMCAgECBgUGBwUCAAMDBQYBAwIDBQIBAgYJBQYAAwIDBwMDAAcGBAUBAgUDBQMFAgEDAwUDAgMFBwMDAwICBQQEAgMEBQMABgUBCAcFAwICAwMAAwQCBQMHAwUDAwcFAwMAAQADBAQDAgUIBAEDAwkFBQMDAwIGAwIFBAgDBAACAwIDBwEDAgMFBAACBgYFCAQAAgAFBgMDAgQFBQUCBAMGBQYFAQICAgMDAwMFBQUHAwACAQIHBQQDAgMGBQIGBgIHBQICAgUFBQMDBQACBQIDBAUFAwIDAwUDBQUEAwMDAAAEAwcHBwMCBAIHAAIFAwYFBAMCAwIGBAQGAgQFBQIFAwAFBAUGAQADAwMHBQUCBQMDBQAABQUGAwMCAgcFBQQEAgUFAQUGAgQEAwQDAAMGAwIGAwUEAQMEBAMFBQACAgIEAAIDBQkEBQUFBQEFAwQDAgUDAAIBBQMFBAQFBQQDAAcFAwMCAwQCAQIHBAUCAgICAwMEBQUGAwkFAwMFAwMDAgICAAUFAwIFBQQGAwMCAwIBAgMHBAMFBwYDBAcFAgMCAwMAAQIFBgMCAAgGAgcFBwMCAwICAAMHBQcDBAMDAwIDAwUDBAUDAwQEBQMDAgQDAAICAwUEBgMECAYCBAUDAgIDBQMAAwQEAgYFBQUCAwgDAwIBBQUCAwMCAgYHBgIBAwcDAwMCAwQFBAMCBQUECAMBAgICAwACBQgDBwMCBgUABQMDBAMDBAMAAwcFBQMDBAQDAwMCBQYEBAYCAwIDBgMAAgMEAgUFAwQDBQUEBQMDBAUFAwADBAMDAwEBBgUDBAECBgYDAwMCBAcDBAMCAwcHAwACAgUFAwIEAwMFAgICAAMFBAYEAwIFBAIDBQUHAwMDAwICAwUFBQIFBQMDBAUDAwUDAwIDBAUCAgMDAgUDAwMHBQYFAwIFBAQCAgAFBgMFAgEEBwcDAgIFBAMFAwABBQgGAwACBAUGBQMCBAIFAgECAgMGBQQBAwIGBwYEAgQDAgIDBQMEBAUFAgIDAwIEBAMEBQQDAgIEBAEFAgMHBQUAAwIFBgIGAwADBQUDAAIFBgUEAgIGBwUEAwQFAwMFAgICBQMFAAAFBAUFAwMFBAUGBQQDBQQEAgECAgUGBQYDAgIFAgIFAAUHBQMAAwECAwMHAwQFBQQCAgMDBwYDAwMFBAMDAwUDAwcDAAIEBQMDAAUEBAUDBQIEAwMFAAIFBwYDAgUDAgIDAgUFBQUEBQMDAgYFBQICBAQDAAQCAwUDBQYDAwMDBQMAAgUDAwMCAgUFBwYDAwUDAwIEAgYDAwQCAgMEBQMFAAQDBQMCAwQICAIDBAUDBQIAAwEABQUAAwYEBAcFAgYDAwcCBAMDAgQHAwMFAgMDBQQBAQIDAwIDBAMFBQUEBQcDBQMEAwAAAQMDBAcGBgMCAgIEBQIDBQYDBQICAwYEBQIBBAUBAQUDAgcGBwMCBQUGAAMDAgQEBQMCBQMEAwQFAgMEBQMDAwAAAwUDBQQFCQMEBQMAAgMDBgUDBAQDBQYCBAcDBQMDAAACAgQDBQQEBQECAgMDAwMGBgYDAwUEBQUEAwACAgIFAQMFBgcDAgEFBgIDBQMDAwMDAgIDBwUFBQMCBgUDAwMCAgMCAwIEBQUGAwUFAgMCAwQFBQAEBQUFAwMFAgMEBAIAAgMFBQQGAwMGAgIDBgUEBQQGAwADAwUFBQMAAgMCAwMEBQQHBQMCAgcEBQQFAAADBQMBAAUFBgUFBQQGAwUGAgMEAwMEAwIDAwIFAwAFBAACBwYFAwIFBwMDAwQCAgMCAgICBwYGBQYDAAIDAwUEAwMHAwMDAgMDAwUFAwICAQMFAwADAwUGAgMHAwMFBwMDAgIEBQIDBAUHBgMAAgICAwMDAwQFAwUDAwUCAwMDAgIDAwQGBQMDAgUEAgMFAwIDAwQDAgcHBQQDAwIFAwIHAwUFAgICAwIDBQUEBQUFBAEAAQUDBQQCAwUEBQMCAgcGAQMCAwMEBQUFAwQEAgMDAwUDBAMCAwQFAwQDAwQDAAIDBQMGBwcDAwMFBQQAAwICAwMDAgQFBQYDBAMABQYDBAICAwMCAgICBAcGBQUDAwYEAgICBgYCAwMDAwMHAwMCBQQCAQIDAwMHBQMDBgMCAgMDBQQDBQQDBwUDBAUEAwMDAwMCAwQEBQMCBAUFAwIDAwMCAwQBAwMDBQMDAAMFBQcDAwUEAwIFAQMEBQYFBAADBAQEAwMGBgMCAgIBBAUDAwMDBwIDAwUFBQcDBAQBAgMDAgMCAwQDAgQFBAUFAwUDAwMFBQQFAgMCAgEDBQMFBQUDAwMCAwMFBQMEBQQBAwcEAwQDAgIDBQUDAwQFBAMCAgQFBQQDBAQDAgQDAgMDBwUDAgMFAwQFAwQGBQMEAgEEAwQFBAMDBAIDBAIDBAQEBQMDAgUEBAQDAwMCAwQEAwQFBQQDAwMHBQMFAgQCAwICBAQFAwIDAAMDBAMDAwMFAgAEAwMFBgYFAwQFBQIBBAQGBAMCAgIDBQQDBQIDAwICAQMFBQYDAwIDAwMDBAUFAwUEBQMDAwUEAwIDAQMHBAMDAwUDAwIGBgQEBQMCAgMDAwICBAUEAwIDBQYFBQMDBAUDAgICAwIGBQMAAwQFBQMDBQMDBAUBBQYEBQMEAwMCAgUFBAQFAwMEAwMCBAMDBQQEAwMDBAQDBQMEBAMDAwMCAwIDBgQDAgMDBQYDBQMDBQUDAwMDBAUEAwIDAwcHAwMCAwQDAwMFBQIEAgECAwMEBQUCAwMEBQIFBgQDAgQDAwQDBAUGBgIDAgMEAwQCAwUDBAMDAgMDBAUDAgQDAwMEBAMEAgMFAgQFAQMEBwMDAwMHBQUFAwIBAwMDAwIEBgUDAAIFBAQFBAUABAMDAgIFAwUFBAQDAwQDAwMFAgMDAwMDAgMFBQQFAwIDAwUFAgMDBQMDBAQDAwQFBAIBAwMDAwUEAwMFAwQDAwMCAwcEAwIDAwMEBQQDAgIFBQMCAQYFBQQDBAMEBQYFAQIEAwACAwMFBQUFAwMDBAQEBQUCAwICAgMDAgYDAwQBAwMDBQUFAgMEAwUDAwQDAwQDAgIFBQQFBAYDAwUDAwIDAwIDAwUDAwUDBAQFBAICBQUDAgMDAwUDBAMDBAUGAwMCAgQEAwQDBQYFBQMCAgMDAwQCAwMDBQMCAwUFAwQDAwQCAwQFBQMEBAMEBQIDAgMDBwMCAwMDBQUDAwMDBQQDBAMDAwQFAwMCAwMDBwUDAgIFBQMDAwMEBQUEAwACBAUFAwMDBAUFBgMDAwQFAQACBQEFBQMDAwQGBAMFBgQCAwICAgIDBQQGBgQDAwMDAwID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/QAA9wQA+gAAAAD6Cfr7APcA/QAAAAAA//z3AAAA/AEA8wAAAPb8+wAA/f/9+wD3+/kAAPr7APz2Bvz//wD9AAAD/AD///QD9wD/APf7APMA/PcD+f8A9/sA/QD/AADxAAD2A/33AwD6APcAAAD//f8H7/z8APYA+foA+QAG8wAA+gAA+gH/9gH9AAD2AAD69wD5APz/+QAA+gAA9wAD/AQAAAMAAAMAAAAAAAD/AAb/AAAAAPcBAAD7AP39AAAAAAAA9wAAAPr9AAD9/wD/+QAA/wAAAAD0Cfz8AQD6/Pz/APcB/wAA+gQAAAAAAPv9A/cAAAAA8gAAAPcAAP/6AP/9AAAAAPoA9wAA9wAAAAAA+gD6/f0AAPYA/fz7APf7APsA9gQA9/v9/f8AAAD6+/0A/PcA9/f7APv6/fcA/wAA/P0AAAD8AAAAAAD8AAAAAAAA/AAA/P0A+/3//f8A/QD8AAAA9wAA+wAAAQD2Cf33/wAAAAAAAPcAAP0A+vz9/QAA+QD/AAAAAAAAAAD7B/cAAf0A/QAAAAD3BgAAAAD3APsB/wAA+QAA+gD3AAAA/AD7AAAA//f7APr8+QD9APcAAAD6AADyAAAAAAAAAAAA//8A+f8AAAAA/wD3AAD7AAAA/AAAAAAAAPsAAAAAAAD9Af8AAPcB/P8A/QD/AP0A/P8AAAAAAAD8AAD6AP3/+QX8//0AAP//AAAA/QAAAAAA/Pr9AAAAAAD8AAAAAP8AAAD9AAD7/wAAAAD/AAAA/wAA/AAA+gD9AAAA/AAAAAAAAAAAAPsAAPv9AAD3AAD7/AD7AAD6AP/9AAD/AP8AAAAA+wD7APsA/fcB+gAAAP0A/P8A/AAAAP0AAAAA+gAA9wD9APoBAAD//AD//PwAAAAAAP8AAAAA+wABAAAA+wAAAAAA/QAAAP8AAAAAAAD9/wAAAAAAAAAAAAD8AAAA+gAAAAAA9wAAAAAA/QAAAPz9AAD9/QP9//8AAAD8AAAAAAAAAAAAAPoAAPcB/P//AAAAAAAAAP0A9wD3AAD/AAD9AAD6AAAAAAAA/QAAAPcA+/oA/fwA/PwAAAAA+gAAAAD7AAD/AAD8AAD9AAAA/wAAAAAAAAD/9wAA+vwA//wA/QAAAAAA/QD8AP37AAAAAAD6/AAAAAAAAPv////8APwA/wAAAAAA/P8F/P8AAAAAAfcAAAAAAAD7AP8AAPsAAPwAAAAAAPwAAP0AAAAAAP8AAPwAAAAAAAAAAP8AAPz9AAAAAP8A/wAAAAAA/AAA+wAAAAAAAAD/AAAAAPwAAAD///8AAAAAAAAAAAAAAAD9AAD9AAAAAAD8APsAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAD7AAAA+wAAAAAAAAAAAAAAAAAAAAAAAAAAAP0BAP8A/f8AAPsAAP//AAD9AP//AAAAAPwAAP8AAAAA/QAAAAAB/wAAAP8A/AAAAAAAAAAAAAAAAAAAAAAAAAAA/QAAAAD7AAAAAAAA+v8AAPsAAAAAAAAAAAD7AAAAAAAAAAAAAAD8AAAA+wEA/wAAAAD8AP8AAAAAAAAAAAAAAAAAAAAAAAAAAAD8AAAAAAAAAAD8APwAAPv/AP0AAAAAAPsB/wAAAAAA/wAAAAAAAAAAAAAA/QAAAP8AAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAA/wAAAAAA/f0AAP0AAAAAAAAA/AD7AAAAAAAAAAD/AAD8AAAAAAAAAAAA/AAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0AAAAAAAAAAAAAAP8AAAD9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/QAA+wAA/QAA/AAAAAAAAAAAAP8AAAAAAP0AAAAAAP0AAAAAAP0AAAAAAAAAAAD/AP8AAAAAAAAAAAAAAP8AAAAAAAAA/wAA/wAAAAD/AAAAAAAAAAAAAAAAAAAAAAD8AAAAAAAAAAAAAAAAAAAAAAAAAAD9AAAAAAAAAAAAAPoAAAAAAAAAAAD9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0A/QAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAP8AAP0AAP0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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/QAAAP/6APwAAP38/AD+/f/+AP//+////AD/AP36APcA/wD9/QAA/QAA+wAAAAD/BAAAAQAAAAAA/AD9AP8AAAL+AAAAAP8AAAD/AP0AAAAAAPsAAAD+APwAAAAAAAAA/QD9APoA/gAA/AD9AfwA//n/APoA+gAA/AD//wD8AAAAAAAAAAAB+wAAAAAAAAAAAAAAAAQAAAAAAAAAAAL+AAAA/wAA/AAAAAD/AAAA/QAAAAAAAP4AAAAAAAD9/wAAAP78/QD/APoA/gH//QD+/gD8AAAAAAAA/wD/AP4AAAAAAAAAAAAAAAAAAP3/AAAAAAAAAAAAAAAAAAAAAP8AAAAAAP7///kA/QAA/gD/+gAA/v8A/QD/AP8A/QAAAAD7/QAAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAAAAAP8AAAD/AAD/AP4A/wAAAP4A/gAA/QAAAAD+/QAA/AAA/wAAAAD/AAAA/wAA/wD+AAAAAAAAAAAA/gAAAAD+AAD+AAAA/gAAAAAAAAAAAAAAAAAA/wAA/wD8AAAAAP8AAP8AAP8A/wAAAAAA/wAAAP0A/wAA/QD//wAAAAAAAP8A/QAAAAAAAAAAAAAA/wAAAAAAAAAAAAD9AAD/AAAAAAAAAAAAAAAAAAAAAAAAAAD+AAAAAAAAAAAAAAD+APwAAPsAAP4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf8AAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/wAAAAAAAAAAAAAAAAAAAAAA/gAAAAAAAAAAAAAAAAAAAAAA/wAAAAAAAAAAAAAAAP4AAAAAAAAAAAAAAAAAAv8AAAAAAAAAAAAAAAAAAAAAAAAAAP8AAP8AAP4A/wAAAAAAAAAAAAD/AAAAAAAA/wAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP8AAAD/AAAA/gAAAAAAAAD//wAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPIA/wAAAAAAAPv7+/cA8vr7APv3APf6+gD3/ADzAAAAAADu+vom+9RW8+0VAA8AAB0iGBfi8jYkIwQRGvsbHikAJAAZOfY3B95WqShWqQxWEamp/bdWJMNF2UIkvNLAqalLqqk2A8CpqcCpqampvMqpqQCpqampqampqeupqampqbapqa6tw6qxsb7Hyqm8uNK2ucfA6c/SAAm62PP39+sABwAACSApHBUVTzlWVjNWVj1WVj1WVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVk9QT0hPS0o/PTI5KCItKSAsExgRFQkGAAH869np4tnm7dLPysO4vKmqqanDqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqa2qsbG8wMfUzc7Pz9zl3Onp7+/vAPH5+fsMBgMJBwcHDhMTGhsaHiQgIikkMSQxMiw5MDw8Oj09OUdFQlZQS1JWRUdKUFZWVlZWU1ZUVlZWVlZWVlZWVlZWVk9SUlZWVlZWUlZPVlRSS1NUUlZWT09WVlNUUklLQkdJQUhEQT1GQTY6Ni48LScpJCgoLCkjKyMiHRkTFxEgFxETCQkA9wAA9vzx9//v2eLn2N7P2NrV1dPVysfP0srDwMHBx7/KvLXEu7G+sbapsa2pqampqqmqqqmpqqmpqampqamxqamxqamurqm3qarJsbXDysO+x83E0srQ09Ta09Tk2uLi2OPj3PHo8+vz6/r39O76+/39A/kEAAAHAAQJAAoGBw8BDAoADwkJDBMTABURERoDGRcREgYSFQ0PFRIREgcJEQ4ACQAAEgf8AAD/+QDt8vb09/f38e3v8+7j7+nk7eDi6OLn5N7o4tTi3drZ4N7e2NnT1NnX3d3X4+DY49rX2eDU2OLi3N7e6OTi2uLv497n4OTr3u7m9+/v+/fr9/f//AAB/QUAAAEACQkJCgYXDwUSHREXER4eGRciIiceLCQkLi0oLSc3NikyPSwxMzY2Nj05M0Q9QkFAS0FARkA/T0BPRDpLPT9LOUE6Njw5OS48MzI8NystKCspKy0tKCcaIyISFxcMGR4VEQwREQQY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7vDv8PHy/AAABQgFBQUC/gDv7+ji3NfQys3KycnJys3P2NPU1NTU09DHxMC7t7Gtp6SnpqSkpKSkpsDY7AodNk1RYWFhYWFhUz0uHxAA//nw8fL8ABAdKTZDUVxfYWFhXFhJQTEmGg8EAPv///8AAAkOHBspMC41OTY1KSghEwoA+/rq5uQAAGFNAEyZZrwS0vvlydzkp/WmsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKy06yysri3yMlR8GEmsWZNTU1NTUhOTU1NTU1NTU1NTU1NTU1NH1arZk1NpVwR5ev/+PD28PEzmbKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrISqdkYHvoYEhsjQC7HZk1FT01N/F0/UNlcIlZNTU1NTU0HWhILJx0cHhwcHBSZX5mysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysvykAwnpAf4AnwTf8Sw5GFlNTU1NTU1NH1ZNTU1NTU1NTU1NTQxaTU1NTU0MWrhK3uoA7/b18PHx8S3AqrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyweD7Ef0HCxIgKCpKN1ErU01N8GA9UU0mG1lNTU1NTU1NTRgnECIkIhwcHBQY1c/9ounYqLKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKy2/AN5QAAnwDY6fAkNhBaTU1NTU1NTU1NTU1NTU1NTU1NTU1NTStTTU1NB1r4DPTi+PDx8fHs7u6n2OumsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrLb+RX1AhESGSQvN1JNTU1N9UpARU9NJhtZSE5NTU1NTU1NIPc9ICQiIhgdFNbPx9eqyNzdy6yysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyshry6PwAzsft5uvzLjdTMlFNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU0gVgDKGMAA8Ozu7u7up7Wy46jAr7KysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyHKwq6AcEFBUkOzBTTU1NTU1NTTtRTS1TTU1NTU1NTU1NTU0AHDInKCEYHBTfyrbhqMivtbXV28q/r7KysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrL11w/gx8Hi3ujk8Tg4Uk1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1N/F3A/NP36+zs7Ozs7LHdqdOss7K4sbKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyss3uCecNAAkVIChXRE9NTU1NTU1NTU0YWD1RTU1NTU1NTU1NBys0LS0jIiIc3dW1r8O5tLW1srLUrNirJpuysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyBKJKmb/b093k6DP3YSRAUU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NrxqmAuTv5eHk5KrfqbLDr8OvuLexsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyss2u/gDh/QkBFBk4U0RPTURPTU1NTU1NTU1NTU1NTU1NTU1NTU0zTQBALCglHOPYvuWnyrW0tbW1srKy4Qbw6gD8oLywsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKy/KTPytTZ4OgkOVMwUk1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NHzJFmTev/N/k5OKnsrKysrKyt7G1trexsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrK8sPP/2Pf/DwAkKlZIG1crU01NTU1NTU1NTU1NTU1NTU1NTU1NTR9WAEAlKx+cGqWxy7+/uLC1tbKy9aYSz98H9/+f7KeysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyssOvw6/8xefkIzcQWk1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTQdINcYpCN0Gr/bgp7K4sbKysrK3sbOyza6ysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrIgtuvuBv0WG1k2DVoaV01NTU1NTU1NTU1NTU1NTU1NTU1NTU1NH1YAOSQonx7woty4wb+4tLKyza7gsuXQ0wHhE53zzqqysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysum4TRgQWydUTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU0AXA4TIuYWBs8Ira+3sbKysrKysrK3sbywuLGysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKy1/DQ6/MICAVf7kAwUD5RTU1NTU1NTU1NTU1NTU1NTU1NTU1NTSBWQAE55egE+KDutL/Av7iw06zVuMHj0Njb2N/qpssQn7KysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKytyoAAGEfVk1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTQ4y9i3cEwMCAsar28CvsrKysrKysrK3sbK3sbixsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyshKy4OQA7wxW1TUwLDhCTE5NTU1NTU1NTU1NTU1NTU1NTU1NTU1NH1Y9AMYY9/+f3cDGxsSv6a7AzMrC8NHZ396nCdGostTjp7Kys7jxprKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrIstu8tWSNVTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU0HN/UtGOcMAQKe89TYqbKysrKysrKysrKyssOvuLGyvLCysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrLD78Pj+wD8DxsQAGAkQlFKTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU0mTP765Q23r+DCxMbEvsDA76bgv9XE89aoCM/p5Nqo873WqsHYx62yw7OxsrKysrKysrKysrKysrKysrKysrKysrKysrKyILbr5jNXJEpPTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NAPgyFxzfEv8An/PO3KiysrKysrKysrKysrK8sLi+BqHD9cGtsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKyshKy8NwBrU/1E+skWSRGS05NTU1NTU1NTU1NTU1NTU1NTU1N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";

			document.addEventListener('DOMContentLoaded', function (e) {
        canvas = document.createElement('canvas');
        
        canvas.style.position="absolute";
        
  			aspect = 1280/720;
  			canvas_w = window.innerWidth;
  			canvas_h = canvas_w*(1.0/aspect);
  			if (canvas_h>window.innerHeight) canvas_h = window.innerHeight;

  			var toppx = (window.innerHeight/2)-(canvas_h/2);

        canvas.width = canvas_w;
        canvas.height = canvas_h;
        canvas.style.top = toppx+"px";
        canvas.style.left = "0px";
        
        gl = CubicVR.GLCore.init(canvas, 'cubicvr-core-vs', 'cubicvr-core-fs');
        
        if (!gl) {
          return;
        }

        // expose the alphaDepth buffer
        var shaderDepth = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-alpha-depth-fs",
        });
        shaders['depth'] = shaderDepth;


        // simple color invert
        var shaderInvert = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-invert-fs"
        });
        shaders['invert'] = shaderInvert;

        var shaderDOF6 = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-dof-6tap-fs",
          init: function(shader) {
            shader.addFloat("near_depth");
            shader.addFloat("far_depth");
          },
          onupdate: function(shader) {
            // linear depth
            var d = CubicVR.vec3.length(scene.camera.position, scene.camera.target);

            shader.setFloat("near_depth", (d - 0.5 - scene.camera.nearclip) / scene.camera.farclip);
            shader.setFloat("far_depth", (d + 4 - scene.camera.nearclip) / scene.camera.farclip);
          }
        });
        shaders['dof'] = shaderDOF6;

        var shaderSSAO = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-ssao-fs",
        });
        shaders['ssao'] = shaderSSAO;


        // Bloom + 1/2 divisor + blend
        var shaderHalfBloom = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-bloom-6tap-fs",
          outputMode: CubicVR.enums.post.output.ADD,
          outputDivisor: 2
        });
        shaders['halfbloom'] = shaderHalfBloom;


        // Bloom + 1/4 divisor + blend
        var shaderQuarterBloom = new CubicVR.PostProcessShader({
            shader_vertex: "cubicvr-fx-general-vs",
            shader_fragment: "cubicvr-bloom-6tap-fs",
            outputMode: CubicVR.enums.post.output.ADD,
            outputDivisor: 4
        });
        shaders['quarterbloom'] = shaderQuarterBloom;

        /*
        var i = 0;
        var shaderActive = 0;

        fxSelect = document.getElementById("shaderSelector");
        fxSelect.options[i] = new Option("Depth Buffer View", i++);
        fxSelect.options[i] = new Option("Invert Color", i++);
        fxSelect.options[i] = new Option("Screen-Space Ambient Occlusion", i++);
        fxSelect.options[shaderActive = i] = new Option("6-Tap Depth Of Field", i++);
        fxSelect.options[i] = new Option("6-Tap Bloom, 1/2 blend", i++);
        fxSelect.options[i] = new Option("6-Tap Bloom, 1/4 blend", i++);
        //fxSelect.selectedIndex = fxSelect.options.length-1;
        fxSelect.selectedIndex = shaderActive;
        */

        shaderList.push(shaderDepth);
        shaderList.push(shaderInvert);
        shaderList.push(shaderSSAO);
        shaderList.push(shaderDOF6);
        shaderList.push(shaderHalfBloom);
        shaderList.push(shaderQuarterBloom);

        fxChain = new CubicVR.PostProcessChain(canvas.width, canvas.height, true);
        fxChain.setBlurOpacity(1.0);
        fxChain.setBlurIntensity(0.0);

        for (var i = 0; i < shaderList.length; i++) {
          fxChain.addShader(shaderList[i]);
          shaderList[i].enabled = false;
        } //for

        //shaderList[fxSelect.selectedIndex].enabled = true;

        var fft;
        var audioBuffer;
        var signal = new Float32Array(4096);
        var audioEngine = new AudioEngine(audioData, function (data) {
          fft.forward(data);
          audioBuffer = data;
          audioEngine.audioBuffer = data;
          for (var i=0, l=4096; i<l; ++i) {
            if (fft.spectrum[i] > signal[i]) {
              signal[i] = fft.spectrum[i];
            }
            else {
              signal[i]*=0.45;
            } //if
          } //for
        });

        audioEngine.playMod('mod.mod');
        audioEngine.audioObject.volume = 1;

        var basePlayer = Popcorn.baseplayer();
        basePlayer.timeupdate = function () {
          //purposely empty
        };
        var popcorn = Popcorn(basePlayer);

        fft = new FFT(4096, 44100);
        audioEngine.fft = fft;

        scene = new CubicVR.Scene(canvas.width, canvas.height, 80);

        scene.camera.position = [0, 0.5, 2];
        scene.camera.target = [0, 0, 0];
        CubicVR.setGlobalDepthAlpha(true, scene.camera.nearclip, scene.camera.farclip);
       
        for (var i=0, s=SegmentList.segments, l=s.length; i<l; ++i) {
          var startTime = s[i].startTime;
          popcorn.code({
            start: startTime,
            end: startTime+1,
            onStart: function (options) {
              SegmentList.nextSegment();
            },
          });
        } //for      

        SegmentList.prepareSegments({
          popcorn: popcorn,
          audioEngine: audioEngine,
          scene: scene,
          canvas: canvas,
        });

        CubicVR.MainLoop(function(timer, gl) {
          var seconds = timer.getSeconds();

          SegmentList.updateSegments(timer);

          basePlayer.currentTime = seconds;
          basePlayer.dispatchEvent('timeupdate');

          scene.evaluate(seconds);

          scene.updateShadows();

          fxChain.begin();
          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          scene.render();
          fxChain.end();
          fxChain.render();
        });

        document.body.appendChild(canvas);

        popcorn.play();
        basePlayer.readyState = 2;

			}, false);

      function selectShaderFX(elem) {
        fxSelect = document.getElementById("shaderSelector");

        for (var i = 0; i < fxSelect.length; i++) {
          shaderList[i].enabled = (fxSelect.options[i].selected) ? true : false;
        }
      }

      function setSize() {
          if (!gl) {
            return;
          }

          var width  = window.innerWidth,
              height = width / aspect;

          function resize(elem) {
            elem.width = width;
            elem.height = height;
            elem.style.top= ((window.innerHeight/2) - (elem.height/2)) + 'px';
          }

          resize(canvas);

          gl.viewport(0, 0, canvas.width, canvas.height);
          scene.camera.setDimensions(canvas.width, canvas.height);
          fxChain.resize(canvas.width, canvas.height);
        };


      window.addEventListener('resize',  function()  { setSize(); }, false);

		</script>
	</head>
	<body>
  <!--
        <div style='position:absolute; top:10px; left:10px; color:white; font-family:Arial; font-size:14px;'>
            &nbsp;&nbsp;Change FX (multi):
            <a href="javascript:void(0)" onclick="document.getElementById('fxDiv').style.display=(document.getElementById('fxDiv').style.display=='none')?'':'none';"
            style='text-decoration:none'>( toggle )</a>
            <div style='display:none' id='fxDiv'>
                <br />
                <select id="shaderSelector" onchange="selectShaderFX(this)" multiple size="15" style='vertical-align:top'>
                </select>
                <br/>
                Blur opac:
                <input type='text' onchange="fxChain.setBlurOpacity(parseFloat(this.value))" size='4'
                value="1">
                intens:
                <input type='text' onchange="fxChain.setBlurIntensity(parseFloat(this.value))" size='4'
                value="0">
                <br/>
            </div>
        </div>
  -->
    <img class="data-image" id="img/fract_reflections.jpg" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4gxYSUNDX1BST0ZJTEUAAQEAAAxITGlubwIQAABtbnRyUkdCIFhZWiAHzgACAAkABgAxAABhY3NwTVNGVAAAAABJRUMgc1JHQgAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLUhQICAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFjcHJ0AAABUAAAADNkZXNjAAABhAAAAGx3dHB0AAAB8AAAABRia3B0AAACBAAAABRyWFlaAAACGAAAABRnWFlaAAACLAAAABRiWFlaAAACQAAAABRkbW5kAAACVAAAAHBkbWRkAAACxAAAAIh2dWVkAAADTAAAAIZ2aWV3AAAD1AAAACRsdW1pAAAD+AAAABRtZWFzAAAEDAAAACR0ZWNoAAAEMAAAAAxyVFJDAAAEPAAACAxnVFJDAAAEPAAACAxiVFJDAAAEPAAACAx0ZXh0AAAAAENvcHlyaWdodCAoYykgMTk5OCBIZXdsZXR0LVBhY2thcmQgQ29tcGFueQAAZGVzYwAAAAAAAAASc1JHQiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAABJzUkdCIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWFlaIAAAAAAAAPNRAAEAAAABFsxYWVogAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z2Rlc2MAAAAAAAAAFklFQyBodHRwOi8vd3d3LmllYy5jaAAAAAAAAAAAAAAAFklFQyBodHRwOi8vd3d3LmllYy5jaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABkZXNjAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZGVzYwAAAAAAAAAsUmVmZXJlbmNlIFZpZXdpbmcgQ29uZGl0aW9uIGluIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAALFJlZmVyZW5jZSBWaWV3aW5nIENvbmRpdGlvbiBpbiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHZpZXcAAAAAABOk/gAUXy4AEM8UAAPtzAAEEwsAA1yeAAAAAVhZWiAAAAAAAEwJVgBQAAAAVx/nbWVhcwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAo8AAAACc2lnIAAAAABDUlQgY3VydgAAAAAAAAQAAAAABQAKAA8AFAAZAB4AIwAoAC0AMgA3ADsAQABFAEoATwBUAFkAXgBjAGgAbQByAHcAfACBAIYAiwCQAJUAmgCfAKQAqQCuALIAtwC8AMEAxgDLANAA1QDbAOAA5QDrAPAA9gD7AQEBBwENARMBGQEfASUBKwEyATgBPgFFAUwBUgFZAWABZwFuAXUBfAGDAYsBkgGaAaEBqQGxAbkBwQHJAdEB2QHhAekB8gH6AgMCDAIUAh0CJgIvAjgCQQJLAlQCXQJnAnECegKEAo4CmAKiAqwCtgLBAssC1QLgAusC9QMAAwsDFgMhAy0DOANDA08DWgNmA3IDfgOKA5YDogOuA7oDxwPTA+AD7AP5BAYEEwQgBC0EOwRIBFUEYwRxBH4EjASaBKgEtgTEBNME4QTwBP4FDQUcBSsFOgVJBVgFZwV3BYYFlgWmBbUFxQXVBeUF9gYGBhYGJwY3BkgGWQZqBnsGjAadBq8GwAbRBuMG9QcHBxkHKwc9B08HYQd0B4YHmQesB78H0gflB/gICwgfCDIIRghaCG4IggiWCKoIvgjSCOcI+wkQCSUJOglPCWQJeQmPCaQJugnPCeUJ+woRCicKPQpUCmoKgQqYCq4KxQrcCvMLCwsiCzkLUQtpC4ALmAuwC8gL4Qv5DBIMKgxDDFwMdQyODKcMwAzZDPMNDQ0mDUANWg10DY4NqQ3DDd4N+A4TDi4OSQ5kDn8Omw62DtIO7g8JDyUPQQ9eD3oPlg+zD88P7BAJECYQQxBhEH4QmxC5ENcQ9RETETERTxFtEYwRqhHJEegSBxImEkUSZBKEEqMSwxLjEwMTIxNDE2MTgxOkE8UT5RQGFCcUSRRqFIsUrRTOFPAVEhU0FVYVeBWbFb0V4BYDFiYWSRZsFo8WshbWFvoXHRdBF2UXiReuF9IX9xgbGEAYZRiKGK8Y1Rj6GSAZRRlrGZEZtxndGgQaKhpRGncanhrFGuwbFBs7G2MbihuyG9ocAhwqHFIcexyjHMwc9R0eHUcdcB2ZHcMd7B4WHkAeah6UHr4e6R8THz4faR+UH78f6iAVIEEgbCCYIMQg8CEcIUghdSGhIc4h+yInIlUigiKvIt0jCiM4I2YjlCPCI/AkHyRNJHwkqyTaJQklOCVoJZclxyX3JicmVyaHJrcm6CcYJ0kneierJ9woDSg/KHEooijUKQYpOClrKZ0p0CoCKjUqaCqbKs8rAis2K2krnSvRLAUsOSxuLKIs1y0MLUEtdi2rLeEuFi5MLoIuty7uLyQvWi+RL8cv/jA1MGwwpDDbMRIxSjGCMbox8jIqMmMymzLUMw0zRjN/M7gz8TQrNGU0njTYNRM1TTWHNcI1/TY3NnI2rjbpNyQ3YDecN9c4FDhQOIw4yDkFOUI5fzm8Ofk6Njp0OrI67zstO2s7qjvoPCc8ZTykPOM9Ij1hPaE94D4gPmA+oD7gPyE/YT+iP+JAI0BkQKZA50EpQWpBrEHuQjBCckK1QvdDOkN9Q8BEA0RHRIpEzkUSRVVFmkXeRiJGZ0arRvBHNUd7R8BIBUhLSJFI10kdSWNJqUnwSjdKfUrESwxLU0uaS+JMKkxyTLpNAk1KTZNN3E4lTm5Ot08AT0lPk0/dUCdQcVC7UQZRUFGbUeZSMVJ8UsdTE1NfU6pT9lRCVI9U21UoVXVVwlYPVlxWqVb3V0RXklfgWC9YfVjLWRpZaVm4WgdaVlqmWvVbRVuVW+VcNVyGXNZdJ114XcleGl5sXr1fD19hX7NgBWBXYKpg/GFPYaJh9WJJYpxi8GNDY5dj62RAZJRk6WU9ZZJl52Y9ZpJm6Gc9Z5Nn6Wg/aJZo7GlDaZpp8WpIap9q92tPa6dr/2xXbK9tCG1gbbluEm5rbsRvHm94b9FwK3CGcOBxOnGVcfByS3KmcwFzXXO4dBR0cHTMdSh1hXXhdj52m3b4d1Z3s3gReG54zHkqeYl553pGeqV7BHtje8J8IXyBfOF9QX2hfgF+Yn7CfyN/hH/lgEeAqIEKgWuBzYIwgpKC9INXg7qEHYSAhOOFR4Wrhg6GcobXhzuHn4gEiGmIzokziZmJ/opkisqLMIuWi/yMY4zKjTGNmI3/jmaOzo82j56QBpBukNaRP5GokhGSepLjk02TtpQglIqU9JVflcmWNJaflwqXdZfgmEyYuJkkmZCZ/JpomtWbQpuvnByciZz3nWSd0p5Anq6fHZ+Ln/qgaaDYoUehtqImopajBqN2o+akVqTHpTilqaYapoum/adup+CoUqjEqTepqaocqo+rAqt1q+msXKzQrUStuK4trqGvFq+LsACwdbDqsWCx1rJLssKzOLOutCW0nLUTtYq2AbZ5tvC3aLfguFm40blKucK6O7q1uy67p7whvJu9Fb2Pvgq+hL7/v3q/9cBwwOzBZ8Hjwl/C28NYw9TEUcTOxUvFyMZGxsPHQce/yD3IvMk6ybnKOMq3yzbLtsw1zLXNNc21zjbOts83z7jQOdC60TzRvtI/0sHTRNPG1EnUy9VO1dHWVdbY11zX4Nhk2OjZbNnx2nba+9uA3AXcit0Q3ZbeHN6i3ynfr+A24L3hROHM4lPi2+Nj4+vkc+T85YTmDeaW5x/nqegy6LzpRunQ6lvq5etw6/vshu0R7ZzuKO6070DvzPBY8OXxcvH/8ozzGfOn9DT0wvVQ9d72bfb794r4Gfio+Tj5x/pX+uf7d/wH/Jj9Kf26/kv+3P9t////4QDWRXhpZgAATU0AKgAAAAgABwESAAMAAAABAAEAAAEaAAUAAAABAAAAYgEbAAUAAAABAAAAagEoAAMAAAABAAIAAAExAAIAAAAeAAAAcgEyAAIAAAAUAAAAkIdpAAQAAAABAAAApAAAAAAAAABIAAAAAQAAAEgAAAABQWRvYmUgUGhvdG9zaG9wIENTMyBNYWNpbnRvc2gAMjAwODoxMDoyNiAwMjoyNDoyMAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAgKADAAQAAAABAAAAgAAAAAD/2wBDAAICAgICAQICAgICAgIDAwYEAwMDAwcFBQQGCAcICAgHCAgJCg0LCQkMCggICw8LDA0ODg4OCQsQEQ8OEQ0ODg7/2wBDAQICAgMDAwYEBAYOCQgJDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg7/wAARCACAAIADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD95ZJEhhaSV0jQDJZjgCvN/EnxR8NaBC/+nW80qj+/8teTPquvan4sk0zU/Ml07tczsSy+vTtXzd8ZbHUbLJsreC602TIEsMeduPWgD1DxX+1qmj6q0VolnJGP7g5H51xUn7Z22AyvdRwL33IuBX5gfFHT9Xg1KbVLPUpw5XAgh4b6Y6V5F4d+H3ifxZI91ql/qMOnlvlDSEtIf7o7UAfspF+2vpMlysUuvxxuxxjatdtYftJ3urwrLp2szPGf4kiRh/KvxO1n4P3+m6d9p0K31ybUovmRNnJx9TivYvhSvxI8PPZHWRHPp1w37xJAqPCPcdKAP2KsPjbqccEZvLqeXcOC8CgH8hXVaf8AHS0MoW+giEf/AD0zt/8ArV8o+FfG2gxaNi9aHU40TalujBSWx29a3tGj0zxvrz2upafqVlbkYjZHBC56ZWgD6Xvfj1pcLn7JYQ3oB6LcHJ/Sm2vx806aMGbQp4c9P9KU/wBK+VPGfhC38LzRXmkanqLw27ES2gYKze5B4xS+Gf7N8VatHY21zHo+ruAEecKMg9T6fjQB9o2vxa0288sW9g0sjfwLOMj9K7uw19L6NWazltiezODXxUvh3xH4e1S9iM0GpNAcedApZnB7jHGPevfvh9plwNEGq6kt5LMcBIZJQSPfb2oA913Zj3IN5xwAawdS1+LSk33tu8aZwCHBJ/CqGreIrHw/ojXl80EcrH5I0Yc+xweDUOmeLbDVNLa9i025WLqd5QkfX0oA2tK12DVh+5truMdzJHgVt1yEnjfw9HdrAl2JJidpVVwFOM4J9aZqniu0tIhazpd2VzOgML4yORkHIoA+Yr7xvYeDvhNe65q+qS3l04zDBgfuscsCe/Hevkzxp+0bZeJvgXf3tlp1oVFzstpNxXzTzwcdea9w8YTfD34gfBfV7e2upIrqG2bFq3KK44Ylh3IB61+Ui+FdV1Xxlf6RbPFaaLG8wsYIG3R+fn5W474z19qAMzxH8SoTrdk2pWVpPLPuEsbMcJyODjtX138KYtJ8V2GiWeiaZCYHcbohhcMBnKjsPrXwRH8E/H9/rVzAdJkS7JLhGJOcHBJbFfYHw6nf4QK13NJ5Wo2enb2QHd5PUN+PT86APR/idoes+CUnv7e5kkucMEto1BRR3GR096+bPCviWXx547uYtSmFlFA6wM0bhQWzySO/evobXtQ8QePrXUbi1s2voFsfMlSKX95kjrgevpXyJ4k8E6l4J+Kmm3kNubaNsSXvmSYWXB4GOxyTQB+i/wALvhfbXXi61u5LuGXRFj+dgwwcc7h7+1fVvgnRdN0r4qrqd7qlrNo0cwW1CEZ6cbh7GvlLwR4w0nSvA+iqdSNq72vmXAMeI2bbnj1AHX1xXgnxH+O0+ieIbpPDd8l5ZQtiW4zgRysOABnp/jQB+s3xJ8GaX4o8M6tqlvqVvM3l/LCijByP1NfJ3hX4Wa1onxWt769uZ1gZCscRiIZR+Pb3r2b9kvXNS8W/B6x1jWYo5boQ+WZAoKsMBsgduTj86+gfHFpb201hrshQeTmNwU6jBxz2AoA5zwD4WtPtl3d3T3E1zHhVOQV2sOn1xVH4j6RPpGnS6la689pHj5bBPlaXHTn6+leheDmtv+EG+2WEaSCe5ZjhuoyAPpgV4H8TZtcuNU1HUtTs7m2NnMxtESQFQirwSe2TnrQB8p+INQ+JPiHxtYR2oluLU3QEsau2Suf7vr0zmvtSTTNb8JfAIXRZk1hrPdJbrCWwMdM/WvA/AHxL0eP4n6KdQt7dNQkcmYoA27PGTjnpjmvonx58QzNrGmaF4eS1uv7QSSNrxxnyyVxgA+tAHxfoWr+OdW8a3WswX0WlkbnEEjEF2BPODTLr4p+Pbr4iS6Xdzy3E9vBGtvKjj58k5H5/lXKeNrjxTovxs0yzvri2aytoVMvlEKpO45U47/SvTtG0XwpomlL4vjMGoalJNl42P+ry3AUt2B9KAPEP7L8QeD/FhtoIU+w3kT/2is+drKSQSp9Rkjmuo+Enwq0LVNL8SXduY47yGdZLMIQFNw5CgEnrkenc16f4+8I6pqk2oX2n4fT47JBeknHks0hPGe/QY963PhP4Tg8D6Vpfiq7guLjQ0QsS4IiLRksH9zgYoA6QfCeS51a4CWssc0MKs8ghAJAPzA/jkfSvzD/bA0mfSvjT9p0W/fTtGvIz/aZDDhuM7ffA6V+tur/tJ+EtU8Ia1a6RFGl82lPLMxcHywwZUbI68j9K/Kf4x/Dbxl8RfE+l3qalNc6dHZxSTKAMK5ODuA7k5oA85+Bnxa1fwDq1tHBew6lYXs6xSrMcv5WR83P8IGAa9v8Ai94W8SeLDoniPTVspNKuxLJuUFlQIwyR7YJFfJ2j+GpPCWo3l14vxA9hqB8pXIUiMMR19CcH86/Uz4dR+HvHv7DGhXwvILWd3aKCJEJaJcBs4HY8/rQB8/aj8PdR1X9nS41fRpStzpFo8hHIIJj+6K+DvAukXPiuK8sL2+mtGuNRxtxzLLjjr2U8H0r9t9J8OaZpul+IvDDJJ5+vWIURn/llGFUb8didxNfCPxD+D03wr1Oe9sLaWSxVJ76F2UnaDknJx1IANAH2p+xvonivw54Ujgvb0NaJG/lKq/u1AByD+XWvfPir4iu5/Bslrban5qBFe+bBUqu4/d7dPxr5y+CPxA0u6+H+karbg2fm2KJLFvPyuVByfc88fWtvW/iEuufF82MEduukRARx24ztmX5ct9Mk8daAPsv4VWqWvwV02NGLgu5yeuM8D8sVseMdH0zUvA+qR31p56zQhJCnDHnA+uCRXJeBYLiX4JSWAuprPUI5CIvnBeM7QwwB2I9a63wmbweD1/tie6nuJSZSLvG4KWIAAx06fnQB+ZPxB8OQ/Dj4lT+MLe5ksfsdpDBDv6vL5hB7YztPPvXu/wAIfE+ieK/hI3iZbW5upbS4aSORiCI5B2/Enp71w/7XFnb682seANPlH9r29ql9H5f+sAB38/kK1/gJY33hn9hfxDqt0gWCMKAjDiTgksPxGMe1AHxD8Wfi2+m/tA+KLDxA5i0+AyjT5uADNt3Z47EiuV+D/wAQvGPxF8U+HdJtpInt2u5gts7ncUPzZP0IzXln7Q96fFfxcsNB02x3aldTfa/N2YAjK4+vHJP096+yv2Y/2fLzwVYeGPE2qubk3WoedFKy4EMKqSxH+zu/nQB9F+AvGT+M/Esvg1rC5it570edJ5u4SlGHmk5PQjGK9a+MPia28H/s2aXpsam2hFjKxidAURCSgJ/A1wH7ItzoU2g3+qatZQ/2s8++1vJCB5ZIwYx6nkCul/ac8Ean4x1ex0qznnt7CRCs5Vfk27S233BIFAHxP8EtCuPE3xN8Y2Go2z2vh8RB475gAiwgZEfqQScjNfQPw08CXHiHxVeaC4lFtb2zIkxOBdMSQuMf3TzXu/wE+E+nwfsyL/aMaz3d/ZvbmQgAyBdygk/pn2rY8NeFJfAvxVa8lvP9BtZJDOmMKibAQQfTrQB+EH7Uum6jZfte33htLppLeXZ5MIPyodzJg+uCCc+9em/Djx/478JeELXwnYaHqk0EVuttb3CLgKygHd15wTj8av8A7U+mac37Xt7cmDyb++1FX08BjughfjPPGM5P41+ln7N/we0fU/hTpOt64kc19JaCVoXGSHcYLfoD+NAHwB4U+M/j/Uv2tvD13qFtqmn2Uvm2F/LO/wC6iMYXByD2Kng8V9h/tf61p13+xDJf6Bte+t9LH2maMcqCeM9vmyR7bq9F+M/wg8JeFfh7r+q2GjQIJJ5JlY5ADso3tkd85P518HaR45tfiLpPjXwUL5byKKzEcSh/kZE29R/wHj8KAO6/Zm0a51b4G/2r9p8p1tI2UuMosu1eFB6kZNfTWq/DeLRYvCEyzqNRu7t0u3wBsUnKk+mccYr5w+CPxf8AB/hPwzqXhDULOztkhn3x7z/qyI1ww9+M19bWd1B4l8FT+ImvhParcokUJHzRSEHZg9ufm/GgDt9b8Xad4X+HF7dRXEceqqo/eK5LSErtGD/wHNbHiLUdT0b9ifV/FtxrF9c6ja6U0wmTkqV5yM+4r5G+IWpT+D73Tl1qdL63aOJoLdjzNPnG0E9+SSPY19DePfE8afsF+JkkQpZP4dmuTk5K4IHln6A9KAPmTwxe3Xxn+Fvh/wCI93K+n+IdR05ftV7J94JtUbT6k5/SvoC20s2n7KmsaFp2pxyQ28kpESHduMQ5J7AEsfxrw/8AZqjttd/Yph1qCSGDSdPtVJLDjYikZP1IH5CvWPgfqNlND4jtdXnguZ7pJBFbbfl/f/d/I4oA+LtH+EuneMf2wPAOoXmsxWUr6WF+zsAd/wA2JF/Liv0r+JENp8Ofg3oENgsE8dqRY2dvG2POMn38Y7cGvy/8U6nq+nftx6PBZWh0ZNAufIuJA25VG5mdj/6Dj6V67qvxavfHaQw3epeSmkz7YQW+VmbIWT8OaAOd/Z08ezLqkGg3R+yX8NxIz2gOSrADB/UH2NfqXLcXt9+z7c6zrmni11M6eNisQzAjGMehOP1r8V/g58OfFsH7WN98Qzczy6GJzLsUnbIjnke3AH1r9efHvii11j4b6NpehahGT9mW6vsZLQoqgAMPXdnj2oA4DVPjK3w5+IfgrwBpMEN5Z39oXBcAFCxUkDP9zn65rqNS+J/hK4S4bWNStYF1Cdo5VYZCLtCfkBk81+XfjDx/b337flnPBrR1B/DllOBbjnziwBHT2z+dO8deJH8Y2unaVpNwbRHVZLi9hlG5FUliefc4P0NAHtnxu8G+FPFfxlfWLFrTUXs7Yrb3H8L8Bkb65P6V9ofCHxpolhBoPh793DKdNV5p2bGxsHK/T5c+1fA+maPL4U8O2n9u312t5qMMH2FX5yNx56dDjPtRpPjxdI+Md093ciwureze7MbyAL5GCqjH+1n9DQB7b+0z8Wol+KGk+FZtTNrpd3q4YBmJWWMBVKEDsQc18Oz2emeF/jJfeKPDlpDb+HpJ3tb0xpgL1I/DA/UV4N8V/F+p/E39rz7Lb3k1nDFcMLLMu4bsbhj0+6BX294G0Gx1L9jrxno9zPBd6nPG7R3DoWcvsAyCOhBP6UAea6RY+CdV8c2+oLNA3nRM8kW3ncocKPqeK+/vFepWHhb9lTRbvSYUjjaOF5ET/lqwZd7+vHzDNfjTpHhzxV4C+L2ivfXd1DpSzpbyXMpyC5/edO/Qj8DX6OeO/iHo3jf4F/DPQdDuESaOC5keBDtNyoCkbh1xmgD0fxdZ6N40/Zv1eaeNbyXR4xe22rSjDJuIAb8ORjvXzr4r+O2jal8INa8DLqsN5qH9keQ9mWIMxZBheOxxX0P4bjtrv9hTxd4fCpZ6pfxJEUkYhwc8AA9gTX5jx/s4+MrH4y/bb+68q3ttQjeQlTuKYDHL5wOw59aAPvr4Aa3B4O/Yg0zwmiRT3U+lmW5t2X/XuxXKntwCW49K9mvdP8O+CtV8Nat4b1eDUXuprb7RGqkbPT8c814bqEGn6J8MvC9pYW+y9u7OeNWRs4JYFQPfHHtWr8PPGFjpfg7U9C16K3u7+xQXNtdTSqDIyFWC+wGD+dAHAftHaRdaT4qGt2tn5V1rWpG5kaMfMYChw2fQtnP0rl/BPhwp4FutSbT/ALbem0e2W1KjMkgOAx7cbv1r3P4rePtA8b6toclrZW5t7eySOMIMiXcHyPbG7ivHPBHiWPwZ451XVvEt0IdPsWeeC3dgEnQH5jz3LbTQB93/AAe8DacP2btcgnt4YNVZBKjPkbCoAK59Djt618Lr8RvF3/DbHjrS4bCeDQzFFZpiQhDg5Y+g7fmM19yfDXxBeeLvAlrp2i6nFbXt1A5ljU4ZwvJVe2AMZr538cWOm/D/AOGnjHxBr+nJHqouZTHdbefL/hLdsk8fhQB84eMvAMOiftLaL4v0q1iuLbV7OQOyDI3KoAUjsc55r27QvB2ganq1o9lpQS7uoo/OgRcFdnEvB9dw/GuV+EUF78SNM0e81zU7ZUY7bW0PPy5O0cdCeDX6J/Dz4TW2meGLDUrryT4isxLDCV4DoxDOGz1JIGD2oA8/+I/wvgvNN8CpbQbr2K3Lk7c+VjgZz2A/lX50/GLwlf6R8dNV+yoIn1XTHhRnORapEc4JHY7unvX6Pw/EXUtM+J3ic+L0hhg+yNHpsTvlYSFKlm/AcY9TXxR8ZfGPhjXLCCbSdQgOpmR4ixQ9CpyAR3OB+dAH5T+I7i8074qXlxFPtu4ZQySKOQSP58mvtT9nLxpq+r2fhXw5Dpc9417qYguLkSnLKrjccZ5zwDXzX4i0saX8RdO1LxJpyHSrhlkvyq/MYicAD34z+Br9Lf2UtI+HVt448EarpsKwaVBeFkedhsZ3yVYH1BxntQAfFPwHoN78UbnT2t0t47K+SS3ifJJnKMC3sOeM+tei/DP4VafqNnpviqzis/P0mwlg+wsDuBDjPUYwcA/Q13/7ZuhWZ8B2/iDwlMjeIJLyN777KwYBQyYcgcivU/hdYadoXwGl1O9vnFgNLlWeYDpIeS2OowfWgDD8BeFrTxZqE0V69tZ7LcGZCoXYW+bn3xkVS+LfgTw7pkPh9oriG3kmWWO4gZsGY4xhj6AYPrxXylqn7Qlh4B8fXMd9qC3GnX3K4cKrSocKW+i84rxPWf2ldb+If7QHh/SbaS1utCaSR1VnG9QMcnnHIB4oA+/PCnwn0TxZPpNjFfBL22tC1sG5EW1eW/4Hnr9K+ef2kvADeAfECNYlFMlt/pCqQDtPBOf9rB4r6n/ZmvTrfxJ1y/3eZa2dmIrfeMMgyAB78V43+1X4d8Yan+0DZgRBvCiyme5mmO5WZVyqAegB5FAHyZbTXwudAtVMdhHFbyNdQkZYKACh9fu964zwnHN8Z/ib4rsbZjeaZZTC2jRyPmhCqXkx2G7PT1r6VtPC9nfaRquoLcade+IZ7VY1ZW+VFkTYB/n0r5/+BsKfCHx/4z1XV5pI2aZ8bwC2RISAQex9aAPr/wDYi1qaL4nyWNzG8iTaUssSyH/j234yQe+cdK9V/bU+EN744+FBXSJp9PhmKrcGEbg+SeCvQDOD9M1P8EdA0vwVqGkvpmhzGcqHnkmfBhXHIPrX0t8Td2t+AYNJglMQvAXkiYYfaBmgD8fPh+mpfDTwLa29nHc6tdWuwm5GNpKkg4zX3L8HPjTqup2UDy3BQ3eIre3uFIDNnrz0NZ+ueDPDugeEwb4RQ3N1iMxp8zpnPIHfNcNoHhKSx8R6c1neSfYElwkgQEIDgjj+9mgDR/aEg1XxDoL29vaLpt3czbby4SQhmiAPQdBnOM18F6hpWp6JeQrDG93pxdikki7zKQM4J7DORX35401uB/Dt1peqQwTXhJW1v+SQo6ggdBx1NeF+DNElsvijHYX9sb6yY+bA0zfu9zZO3HfnJz6UAfnT8SNduvEuqSDT4ClrDmK4twuSCOpHcYIr6m/Znvta0rxr4RjlEiaEIY1RJANry5wX9hg/rXqPjD4Ixan42lu47O2sLa5mLyGJQGbcecZr0O68OeH/AAFovh7TPD04h1F41M4uPm2/TPQ/SgD2O1sdbvv2m7X7YqatoU14v7okYK55Uj6Dj6V9G+N7DQ7L4PeNPClot1DNdRGSIw5+VGXJ59AO1fFei/EBV8dO1/qTWZWYJFcRJnczAKePoOvavqrw/qMGs69DFrVxeahZTsEhOCMjAGCfT2oA/Az45eFfEOhePGgvZZr+xEzGzlZfmKNyB+HA969C/Zw+Dmt+MPiVorW+mTSX0N4rNE2UJUnGN3oQK/Y/4v8A7LHhvx94l0G3s9LH2SIZu5ndQSOcY46/4V6p8GfgRo/wmN5NBNHeXUqhIm2AGMDvn1oAm+E/wquvAmt3Wo74rO3uIcPZqdxycYJPtjFZv7Ri6OPhXC1/FIJwWKSoudqnAPHc/XpX0XXy9+0Y+pahoVvoFuYoLO4ibzZ9uXTjt+NAH5/f2l4b0TUpIru/+z2cMJiRVO3c68qCRx/hXzB461LULjW9StBNaS2FxE9yJd2WdQQVX69a9G+I3giKXwt/ZNjrd/eXFo5e4EUZAZiME18xWXhC/l+I9kqxapqUanY0cZO2Nc9CaAP6MPDNroNhaWyXv2byY1/dtO5Uqvpgf1qp47+Ivh/T7CQ6etrrFxFHhFEm3YPb1P418M678YLtopEg1MMhBz2P868A8S/FvxDaGRtO0/7a5B5Lrz+BNAHt3xG8dpr2qzXkR1C3nzgw5DRrj0PY1zHhv4y3ugsYdMkSWYf8srhdwDDv1/lXxp4h+JXivUJZRNpMlkGPzGLHP5GuITxnqEEm5wtu4/j8o7vzzQB+vHh278I+M7c3OtX8FpqM5Bu5HGVx6D0r0TQZvg3peoT2bXcc84+5cyJhVI6AZPT3FfjxpPxe8SWMWy11aCFWGDuiOT+tR3/xC1u9mDyXJnzz+5l2UAfq9451/wAD2HiCx1S1gtXntWBSQTAxSexwc18w/FDXW1rWpvFNjcaafJQ4t4kyU/3TnrXyhp/jC9uoRDeQF4f+mkpethniuoWWGOZVf7yrMFH60Aew6X4hsNb0mK7UTwalGAdnkYd29QTwTX1b8LPiLrNhLZx3iGZoSGj+0LuYj3x2r428I6ppWiLG02lvJKMfO1yOa990T416do8S/ZdMsY5APvSASH9aAPtrUfiX4gury21Cy0bzXwFG2Qooz3Ga978MXWoX/hm1u7+Tc8kf3Co3g++K/Ntf2k7Qx/6TFAZAODGiqo/DNVZf2ob63Rks7+JIz/yzZ9tAH6myFFhYyP5a4+9uxivnv4n+DBqWjNJp+tSM8zcJOxcgHsPQV8K3P7SfiC8csurW0IPQfaAwH61Ef2h/EMsYS61y1u0HQFhkUAew6d+z8NY8TTW+tapFaBgTE1scs3+8ep+legW37Nngzw3ZpqjtFcXBbny/vN6nHY187ad8f5lYMZw79isuP5V1Fr8dbi6YebfeSh7Bw1AH/9k%3D
"/>
    <img class="data-image" id="img/logo.jpg" src="data:image/jpeg;base64,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%3D
"/>
    <img class="data-image" id="img/logo-alpha.jpg" src="data:image/jpeg;base64,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QXBwbGllZD0iVHJ1ZSIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMSIgeG1wOkNyZWF0ZURhdGU9IjIwMTEtMDUtMTVUMDE6NDQtMDQ6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDExLTA1LTE2VDIwOjIwOjQ2LTA0OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDExLTA1LTE2VDIwOjIwOjQ2LTA0OjAwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgTWFjaW50b3NoIiBkYzpmb3JtYXQ9ImltYWdlL2pwZWciIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDc4MDExNzQwNzIwNjgxMThFMjRERkJGMzVBQzI1MjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMThFMjRERkJGMzVBQzI1MjQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExOEUyNERGQkYzNUFDMjUyNCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjAyODAxMTc0MDcyMDY4MTE4RTI0REZCRjM1QUMyNTI0IiBzdEV2dDp3aGVuPSIyMDExLTA1LTE2VDIwOjE3OjQ1LTA0OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDc4MDExNzQwNzIwNjgxMThFMjRERkJGMzVBQzI1MjQiIHN0RXZ0OndoZW49IjIwMTEtMDUtMTZUMjA6MjA6NDYtMDQ6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDUzUgTWFjaW50b3NoIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+4ADkFkb2JlAGQAAAAAAP/bAEMAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAwMDAwMDAwMDA//AAAsIAbQCAAEBEQD/3QAEAED/xABYAAEAAgIDAQEBAQAAAAAAAAAACgsICQUGBwQCAQMQAAAGAwABBAIBAgQDBgcBAAACAwQFBgEHCAkREhMKIRQVMRYiMiMXQWEkUaFCMyUYcZHBkmUmJxn/2gAIAQEAAD8Ar/wAAAAAAAAAAAAAAAAAAAAAAAAAc1Xa3YLfNxtaqsJKWKwTDpNlFQsKxcyUnIOlc+hEGjJomq4XUz/X0KXPpjGc5/GMiWFw79PjyGdBryct1rYaxwxT2eGWYlOcTqe9dj2ortAzgy8bTNcbKawcCxaez4nGZmcj36apy+xksXBjFyh60+lR0LQKpK2nj3qSq9CTLBNkZrqzY9Kbacs0vlZ82auyxFzPdrHS1lWbZczkxX/8WTKSBykUOqZNM0UbsPx/9j8BXKPofX2hbdpWwzDc7uEzMOa9YK9Ptk1FElF6/cqXNWWnTyRFUTlyZm/WxgyZsf1Kb0w7AAAAAAAAAAAAAB//0K/8AAAAAAAAAAAAAAAAAAAAAAAAZ38aeMvufv8AkF23J/Ol82vFRstGw0/b49CNhaPWncqosm0xP3OzyMHWIvCmGqxsfM7J/hRUzn0wQ+SzION/pQJQtmibT3Z1XX7bBxko3Wfah56r1lRjrNHJqEO4byO27ctVJ+JI5SwZP42deKqU2cKYc/4cpmmZ8kcJ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%3D%3D
"/>
	</body>
</html>
