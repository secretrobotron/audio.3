<!DOCTYPE html>
<html>
	<head>
    <base target="_blank">
    <style type="text/css">
      body {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        overflow: hidden;
        background: #000000;
      }

      .data-image {
        display: none;
      }
    </style>
		<script type="text/javascript">
var channelCountByIdentifier = {
	'TDZ1': 1, '1CHN': 1, 'TDZ2': 2, '2CHN': 2, 'TDZ3': 3, '3CHN': 3,
	'M.K.': 4, 'FLT4': 4, 'M!K!': 4, '4CHN': 4, 'TDZ4': 4, '5CHN': 5, 'TDZ5': 5,
	'6CHN': 6, 'TDZ6': 6, '7CHN': 7, 'TDZ7': 7, '8CHN': 8, 'TDZ8': 8, 'OCTA': 8, 'CD81': 8,
	'9CHN': 9, 'TDZ9': 9,
	'10CH': 10, '11CH': 11, '12CH': 12, '13CH': 13, '14CH': 14, '15CH': 15, '16CH': 16, '17CH': 17,
	'18CH': 18, '19CH': 19, '20CH': 20, '21CH': 21, '22CH': 22, '23CH': 23, '24CH': 24, '25CH': 25,
	'26CH': 26, '27CH': 27, '28CH': 28, '29CH': 29, '30CH': 30, '31CH': 31, '32CH': 32
}

function ModFile(mod) {
	function trimNulls(str) {
		return str.replace(/\x00+$/, '');
	}
	function getWord(str, pos) {
		return (str.charCodeAt(pos) << 8) + str.charCodeAt(pos+1)
	}

	this.data = mod;
	this.samples = [];
	this.sampleData = [];
	this.positions = [];
	this.patternCount = 0;
	this.patterns = [];
	
	this.title = trimNulls(mod.substr(0, 20))

	this.sampleCount = 31;

	for (var i = 0; i < this.sampleCount; i++) {
		var sampleInfo = mod.substr(20 + i*30, 30);
		var sampleName = trimNulls(sampleInfo.substr(0, 22));
		this.samples[i] = {
			length: getWord(sampleInfo, 22) * 2,
			finetune: sampleInfo.charCodeAt(24),
			volume: sampleInfo.charCodeAt(25),
			repeatOffset: getWord(sampleInfo, 26) * 2,
			repeatLength: getWord(sampleInfo, 28) * 2,
		}
	}
	
	this.positionCount = mod.charCodeAt(950);
	this.positionLoopPoint = mod.charCodeAt(951);
	for (var i = 0; i < 128; i++) {
		this.positions[i] = mod.charCodeAt(952+i);
		if (this.positions[i] >= this.patternCount) {
			this.patternCount = this.positions[i]+1;
		}
	}
	
	var identifier = mod.substr(1080, 4);
	
	this.channelCount = channelCountByIdentifier[identifier];
	if (!this.channelCount) {
		this.channelCount = 4;
	}
	
	var patternOffset = 1084;
	for (var pat = 0; pat < this.patternCount; pat++) {
		this.patterns[pat] = [];
		for (var row = 0; row < 64; row++) {
			this.patterns[pat][row] = [];
			for (var chan = 0; chan < this.channelCount; chan++) {
				b0 = mod.charCodeAt(patternOffset);
				b1 = mod.charCodeAt(patternOffset + 1);
				b2 = mod.charCodeAt(patternOffset + 2);
				b3 = mod.charCodeAt(patternOffset + 3);
				var eff = b2 & 0x0f;
				this.patterns[pat][row][chan] = {
					sample: (b0 & 0xf0) | (b2 >> 4),
					period: ((b0 & 0x0f) << 8) | b1,
					effect: eff,
					effectParameter: b3
				};
				if (eff == 0x0E) {
					this.patterns[pat][row][chan].extEffect = (b3 & 0xF0) >> 4;
					this.patterns[pat][row][chan].extEffectParameter = (b3 & 0x0F);
				}
				patternOffset += 4;
			}
		}
	}
	
	var sampleOffset = patternOffset;
	for (var s = 0; s < this.sampleCount; s++) {
		this.samples[s].startOffset = sampleOffset;
		this.sampleData[s] = TypedArray(this.samples[s].length, "uint8");
		var i = 0;
		for (var o = sampleOffset, e = sampleOffset + this.samples[s].length; o < e; o++) {
			this.sampleData[s][i] = mod.charCodeAt(o);
			i++;
		}
		sampleOffset += this.samples[s].length;
	}
	
}

</script>
		<script type="text/javascript">
/*
	http://www.fileformat.info/format/xm/corion.htm
	
	Sample data is stored "Delta compressed like protracker"
		algorithm: http://www.fileformat.info/format/protracker/corion-algorithm.htm
*/
function XMFile(mod) {
	function trimNulls(str) {
		return str.replace(/\x00+$/, '');
	}
	function getWord(str, pos) {
		//little-endian this time
		return (str.charCodeAt(pos)) + (str.charCodeAt(pos+1) << 8)
	}
	function getDword(str, pos) {
		var value =
			(str.charCodeAt(pos+3) << 24) +
			(str.charCodeAt(pos+2) << 16) +
			(str.charCodeAt(pos+1) << 8) +
			str.charCodeAt(pos);
		return value;
	}
	function getBytes(str, pos, len) {
		return (str.substr(pos, len));
	}
	function getString(str, pos, len) {
		return trimNulls(getBytes(str, pos, len));
	}
	function getArray(str, pos, len) {
		var s = getBytes(str, pos, len);
		var arr = Array(s.length);
		for (var i = 0; i < s.length; i++) {
			arr[i] = s.charCodeAt(i);
		}
		return arr;
	}

	//this.data = mod;
	this.samples = [];
	this.positions = [];
	this.patternCount = 0;
	this.patterns = [];
	this.instruments = [];
	this.speed = 6;
	this.bpm = 125;
	
	this.title = getString(mod, 0x11, 20);				//0x11		Song name
	this.positionCount = getWord(mod, 0x40);			//0x40		Song length in patterns
	this.positionLoopPoint = getWord(mod, 0x42);		//0x42		Restart position
	this.channelCount = getWord(mod, 0x44);				//0x44		Number of channels
	this.patternCount = getWord(mod, 0x46);				//0x46		Number of patterns (0 - 255)
	this.instrumentCount = getWord(mod, 0x48);			//0x48		Number of instruments (0 - 127)
	this.speed = getWord(mod, 0x4C);					//0x4C		Default ticks/row
	this.bpm = getWord(mod, 0x4E);						//0x4E		Default bpm
	
	//0x50 - pattern order table
	for (var i = 0; i < 256; i++) {
		this.positions[i] = mod.charCodeAt(0x50+i);
	}
	
	var patternOffset = 0x50 + 256;
	var track, packBit, rowCount, dataSize;
	for (var pat = 0; pat < 1; pat++) {
		var headerLength = getDword(mod, patternOffset);	//Why? Isn't it always 9?
		rowCount = getWord(mod, patternOffset + 5);
		dataSize = getWord(mod, patternOffset + 7);
		this.patterns[pat] = {
			rowCount: rowCount,
		}
		
		//move pointer to first track of row then loop over each one
		patternOffset += 9;
		for (var row = 0; row < this.patterns[pat].rowCount; row++) {
			this.patterns[pat][row] = [];
			for (var chan = 0; chan < this.channelCount; chan++) {
				track = getArray(mod, patternOffset, 5);
				//console.log(track[0].toString(2), track);
				
				//If the most significant bit of a note is NOT set, then read data like normal
				//If it IS set, check the other bits and see what kind of data comes next
				//These are bitflags so 1 to 5 bytes may follow depending on how many are set
				//		bit 0 set: Note byte follows
				//		bit 1 set: Instrument byte follows
				//		bit 2 set: Volume column byte follows
				// 		bit 3 set: Effect byte follows
				//		bit 4 set: Effect data byte follows
				var packBit = track[0] & 0x80;
				var packFlags = track[0] & 0x1F; 	//00011111b
				var noteByte = 0, instrByte = 0, volByte = 0, effByte = 0, effParamByte = 0;
				
				if (packBit) {
					var o = 1; //offset
					//check each bit in order. If set, read byte and increment pointer
					if (packFlags & 0x01) { noteByte = track[o]; o++; }			
					if (packFlags & 0x02) { instrByte = track[o]; o++; }			
					if (packFlags & 0x04) { volByte = track[o]; o++; }
					if (packFlags & 0x08) { effByte = track[o]; o++; }
					if (packFlags & 0x10) { effParamByte = track[o]; o++; }
					patternOffset += o;
				} else {
					//no compression
					noteByte = track[0];
					instrByte = track[1];
					volByte = track[2];
					effByte = track[3];
					effParamByte = track[4];
					patternOffset += 5;
				}
				
				this.patterns[pat][row][chan] = {
					note: noteByte,
					instrument: instrByte,
					volume: volByte,
					effect: effByte,
					effectParameter: effParamByte
				}
			}
		}
	}





	
}
</script>
		<script type="text/javascript">
/*
	Useful docs
		Explains effect calculations: http://www.mediatel.lu/workshop/audio/fileformat/h_mod.html

*/

/*
ModPeriodTable[ft][n] = the period to use for note number n at finetune value ft.
Finetune values are in twos-complement, i.e. [0,1,2,3,4,5,6,7,-8,-7,-6,-5,-4,-3,-2,-1]
The first table is used to generate a reverse lookup table, to find out the note number
for a period given in the MOD file.
*/
var ModPeriodTable = [
	[1712, 1616, 1524, 1440, 1356, 1280, 1208, 1140, 1076, 1016, 960 , 906,
	 856 , 808 , 762 , 720 , 678 , 640 , 604 , 570 , 538 , 508 , 480 , 453,
	 428 , 404 , 381 , 360 , 339 , 320 , 302 , 285 , 269 , 254 , 240 , 226,
	 214 , 202 , 190 , 180 , 170 , 160 , 151 , 143 , 135 , 127 , 120 , 113,
	 107 , 101 , 95  , 90  , 85  , 80  , 75  , 71  , 67  , 63  , 60  , 56 ],
	[1700, 1604, 1514, 1430, 1348, 1274, 1202, 1134, 1070, 1010, 954 , 900,
	 850 , 802 , 757 , 715 , 674 , 637 , 601 , 567 , 535 , 505 , 477 , 450,
	 425 , 401 , 379 , 357 , 337 , 318 , 300 , 284 , 268 , 253 , 239 , 225,
	 213 , 201 , 189 , 179 , 169 , 159 , 150 , 142 , 134 , 126 , 119 , 113,
	 106 , 100 , 94  , 89  , 84  , 79  , 75  , 71  , 67  , 63  , 59  , 56 ],
	[1688, 1592, 1504, 1418, 1340, 1264, 1194, 1126, 1064, 1004, 948 , 894,
	 844 , 796 , 752 , 709 , 670 , 632 , 597 , 563 , 532 , 502 , 474 , 447,
	 422 , 398 , 376 , 355 , 335 , 316 , 298 , 282 , 266 , 251 , 237 , 224,
	 211 , 199 , 188 , 177 , 167 , 158 , 149 , 141 , 133 , 125 , 118 , 112,
	 105 , 99  , 94  , 88  , 83  , 79  , 74  , 70  , 66  , 62  , 59  , 56 ],
	[1676, 1582, 1492, 1408, 1330, 1256, 1184, 1118, 1056, 996 , 940 , 888,
	 838 , 791 , 746 , 704 , 665 , 628 , 592 , 559 , 528 , 498 , 470 , 444,
	 419 , 395 , 373 , 352 , 332 , 314 , 296 , 280 , 264 , 249 , 235 , 222,
	 209 , 198 , 187 , 176 , 166 , 157 , 148 , 140 , 132 , 125 , 118 , 111,
	 104 , 99  , 93  , 88  , 83  , 78  , 74  , 70  , 66  , 62  , 59  , 55 ],
	[1664, 1570, 1482, 1398, 1320, 1246, 1176, 1110, 1048, 990 , 934 , 882,
	 832 , 785 , 741 , 699 , 660 , 623 , 588 , 555 , 524 , 495 , 467 , 441,
	 416 , 392 , 370 , 350 , 330 , 312 , 294 , 278 , 262 , 247 , 233 , 220,
	 208 , 196 , 185 , 175 , 165 , 156 , 147 , 139 , 131 , 124 , 117 , 110,
	 104 , 98  , 92  , 87  , 82  , 78  , 73  , 69  , 65  , 62  , 58  , 55 ],
	[1652, 1558, 1472, 1388, 1310, 1238, 1168, 1102, 1040, 982 , 926 , 874,
	 826 , 779 , 736 , 694 , 655 , 619 , 584 , 551 , 520 , 491 , 463 , 437,
	 413 , 390 , 368 , 347 , 328 , 309 , 292 , 276 , 260 , 245 , 232 , 219,
	 206 , 195 , 184 , 174 , 164 , 155 , 146 , 138 , 130 , 123 , 116 , 109,
	 103 , 97  , 92  , 87  , 82  , 77  , 73  , 69  , 65  , 61  , 58  , 54 ],
	[1640, 1548, 1460, 1378, 1302, 1228, 1160, 1094, 1032, 974 , 920 , 868,
	 820 , 774 , 730 , 689 , 651 , 614 , 580 , 547 , 516 , 487 , 460 , 434,
	 410 , 387 , 365 , 345 , 325 , 307 , 290 , 274 , 258 , 244 , 230 , 217,
	 205 , 193 , 183 , 172 , 163 , 154 , 145 , 137 , 129 , 122 , 115 , 109,
	 102 , 96  , 91  , 86  , 81  , 77  , 72  , 68  , 64  , 61  , 57  , 54 ],
	[1628, 1536, 1450, 1368, 1292, 1220, 1150, 1086, 1026, 968 , 914 , 862,
	 814 , 768 , 725 , 684 , 646 , 610 , 575 , 543 , 513 , 484 , 457 , 431,
	 407 , 384 , 363 , 342 , 323 , 305 , 288 , 272 , 256 , 242 , 228 , 216,
	 204 , 192 , 181 , 171 , 161 , 152 , 144 , 136 , 128 , 121 , 114 , 108,
	 102 , 96  , 90  , 85  , 80  , 76  , 72  , 68  , 64  , 60  , 57  , 54 ],
	[1814, 1712, 1616, 1524, 1440, 1356, 1280, 1208, 1140, 1076, 1016, 960,
	 907 , 856 , 808 , 762 , 720 , 678 , 640 , 604 , 570 , 538 , 508 , 480,
	 453 , 428 , 404 , 381 , 360 , 339 , 320 , 302 , 285 , 269 , 254 , 240,
	 226 , 214 , 202 , 190 , 180 , 170 , 160 , 151 , 143 , 135 , 127 , 120,
	 113 , 107 , 101 , 95  , 90  , 85  , 80  , 75  , 71  , 67  , 63  , 60 ],
	[1800, 1700, 1604, 1514, 1430, 1350, 1272, 1202, 1134, 1070, 1010, 954,
	 900 , 850 , 802 , 757 , 715 , 675 , 636 , 601 , 567 , 535 , 505 , 477,
	 450 , 425 , 401 , 379 , 357 , 337 , 318 , 300 , 284 , 268 , 253 , 238,
	 225 , 212 , 200 , 189 , 179 , 169 , 159 , 150 , 142 , 134 , 126 , 119,
	 112 , 106 , 100 , 94  , 89  , 84  , 79  , 75  , 71  , 67  , 63  , 59 ],
	[1788, 1688, 1592, 1504, 1418, 1340, 1264, 1194, 1126, 1064, 1004, 948,
	 894 , 844 , 796 , 752 , 709 , 670 , 632 , 597 , 563 , 532 , 502 , 474,
	 447 , 422 , 398 , 376 , 355 , 335 , 316 , 298 , 282 , 266 , 251 , 237,
	 223 , 211 , 199 , 188 , 177 , 167 , 158 , 149 , 141 , 133 , 125 , 118,
	 111 , 105 , 99  , 94  , 88  , 83  , 79  , 74  , 70  , 66  , 62  , 59 ],
	[1774, 1676, 1582, 1492, 1408, 1330, 1256, 1184, 1118, 1056, 996 , 940,
	 887 , 838 , 791 , 746 , 704 , 665 , 628 , 592 , 559 , 528 , 498 , 470,
	 444 , 419 , 395 , 373 , 352 , 332 , 314 , 296 , 280 , 264 , 249 , 235,
	 222 , 209 , 198 , 187 , 176 , 166 , 157 , 148 , 140 , 132 , 125 , 118,
	 111 , 104 , 99  , 93  , 88  , 83  , 78  , 74  , 70  , 66  , 62  , 59 ],
	[1762, 1664, 1570, 1482, 1398, 1320, 1246, 1176, 1110, 1048, 988 , 934,
	 881 , 832 , 785 , 741 , 699 , 660 , 623 , 588 , 555 , 524 , 494 , 467,
	 441 , 416 , 392 , 370 , 350 , 330 , 312 , 294 , 278 , 262 , 247 , 233,
	 220 , 208 , 196 , 185 , 175 , 165 , 156 , 147 , 139 , 131 , 123 , 117,
	 110 , 104 , 98  , 92  , 87  , 82  , 78  , 73  , 69  , 65  , 61  , 58 ],
	[1750, 1652, 1558, 1472, 1388, 1310, 1238, 1168, 1102, 1040, 982 , 926,
	 875 , 826 , 779 , 736 , 694 , 655 , 619 , 584 , 551 , 520 , 491 , 463,
	 437 , 413 , 390 , 368 , 347 , 328 , 309 , 292 , 276 , 260 , 245 , 232,
	 219 , 206 , 195 , 184 , 174 , 164 , 155 , 146 , 138 , 130 , 123 , 116,
	 109 , 103 , 97  , 92  , 87  , 82  , 77  , 73  , 69  , 65  , 61  , 58 ],
	[1736, 1640, 1548, 1460, 1378, 1302, 1228, 1160, 1094, 1032, 974 , 920,
	 868 , 820 , 774 , 730 , 689 , 651 , 614 , 580 , 547 , 516 , 487 , 460,
	 434 , 410 , 387 , 365 , 345 , 325 , 307 , 290 , 274 , 258 , 244 , 230,
	 217 , 205 , 193 , 183 , 172 , 163 , 154 , 145 , 137 , 129 , 122 , 115,
	 108 , 102 , 96  , 91  , 86  , 81  , 77  , 72  , 68  , 64  , 61  , 57 ],
	[1724, 1628, 1536, 1450, 1368, 1292, 1220, 1150, 1086, 1026, 968 , 914,
	 862 , 814 , 768 , 725 , 684 , 646 , 610 , 575 , 543 , 513 , 484 , 457,
	 431 , 407 , 384 , 363 , 342 , 323 , 305 , 288 , 272 , 256 , 242 , 228,
	 216 , 203 , 192 , 181 , 171 , 161 , 152 , 144 , 136 , 128 , 121 , 114,
	 108 , 101 , 96  , 90  , 85  , 80  , 76  , 72  , 68  , 64  , 60  , 57 ]];
	 
var SineTable = [
	0,24,49,74,97,120,141,161,180,197,212,224,235,244,250,253,
	255,253,250,244,235,224,212,197,180,161,141,120,97,74,49,
	24,0,-24,-49,-74,-97,-120,-141,-161,-180,-197,-212,-224,
	-235,-244,-250,-253,-255,-253,-250,-244,-235,-224,-212,-197,
	-180,-161,-141,-120,-97,-74,-49,-24
];

var ModPeriodToNoteNumber = {};
for (var i = 0; i < ModPeriodTable[0].length; i++) {
	ModPeriodToNoteNumber[ModPeriodTable[0][i]] = i;
}

function ModPlayer(mod, rate) {
	/* timing calculations */
	var ticksPerSecond = 7093789.2; /* PAL frequency */
	var ticksPerFrame; /* calculated by setBpm */
	var ticksPerOutputSample = Math.round(ticksPerSecond / rate);
	var ticksSinceStartOfFrame = 0;
	
	function setBpm(bpm) {
		/* x beats per minute => x*4 rows per minute */
		ticksPerFrame = Math.round(ticksPerSecond * 2.5/bpm);
	}
	setBpm(125);
	
	/* initial player state */
	var framesPerRow = 6;
	var currentFrame = 0;
	var currentPattern;
	var currentPosition;
	var currentRow;
	var exLoop = false;		//whether E6x looping is currently set
	var exLoopStart = 0;	//loop point set up by E60
	var exLoopEnd = 0;		//end of loop (where we hit a E6x cmd) for accurate counting
	var exLoopCount = 0;	//loops remaining
	var doBreak = false;	//Bxx, Dxx - jump to order and pattern break
	var	breakPos = 0;
	var	breakRow = 0;
	var delayRows = false; //EEx pattern delay.
	
	var channels = [];
	for (var chan = 0; chan < mod.channelCount; chan++) {
		channels[chan] = {
			playing: false,
			sample: mod.samples[0],
			finetune: 0,
			volume: 0,
			pan: 0x7F,	//unimplemented
			volumeDelta: 0,
			periodDelta: 0,
			fineVolumeDelta: 0,
			finePeriodDelta: 0,
			tonePortaTarget: 0, //target for 3xx, 5xy as period value
			tonePortaDelta: 0,
			tonePortaVolStep: 0, //remember pitch slide step for when 5xx is used
			tonePortaActive: false,
			cut: false,			//tick to cut at, or false if no cut
			delay: false,		//tick to delay note until, or false if no delay
			arpeggioActive: false
		};
	}
	
	function loadRow(rowNumber) {
		currentRow = rowNumber;
		currentFrame = 0;
		doBreak = false;
		breakPos = 0;
		breakRow = 0;

		for (var chan = 0; chan < mod.channelCount; chan++) {
			var channel = channels[chan];
			var prevNote = channel.prevNote;
			var note = currentPattern[currentRow][chan];
			if (channel.sampleNum == undefined) {
					channel.sampleNum = 0;
			}
			if (note.period != 0 || note.sample != 0) {
				channel.playing = true;
				channel.samplePosition = 0;
				channel.ticksSinceStartOfSample = 0; /* that's 'sample' as in 'individual volume reading' */
				if (note.sample != 0) {
					channel.sample = mod.samples[note.sample - 1];
					channel.sampleNum = note.sample - 1;
					channel.volume = channel.sample.volume;
					channel.finetune = channel.sample.finetune;
				}
				if (note.period != 0) { // && note.effect != 0x03
					//the note specified in a tone porta command is not actually played
					if (note.effect != 0x03) {
						channel.noteNumber = ModPeriodToNoteNumber[note.period];
						channel.ticksPerSample = ModPeriodTable[channel.finetune][channel.noteNumber] * 2;
					} else {
						channel.noteNumber = ModPeriodToNoteNumber[prevNote.period]
						channel.ticksPerSample = ModPeriodTable[channel.finetune][channel.noteNumber] * 2;
					}
				}
			}
			channel.finePeriodDelta = 0;
			channel.fineVolumeDelta = 0;
			channel.cut = false;
			channel.delay = false;
			channel.retrigger = false;
			channel.tonePortaActive = false;
			if (note.effect != 0 || note.effectParameter != 0) {
				channel.volumeDelta = 0; /* new effects cancel volumeDelta */
				channel.periodDelta = 0; /* new effects cancel periodDelta */
				channel.arpeggioActive = false;
				switch (note.effect) {
					case 0x00: /* arpeggio: 0xy */
						channel.arpeggioActive = true;
						channel.arpeggioNotes = [
							channel.noteNumber,
							channel.noteNumber + (note.effectParameter >> 4),
							channel.noteNumber + (note.effectParameter & 0x0f)
						]
						channel.arpeggioCounter = 0;
						break;
					case 0x01: /* pitch slide up - 1xx */
						channel.periodDelta = -note.effectParameter;
						break;
					case 0x02: /* pitch slide down - 2xx */
						channel.periodDelta = note.effectParameter;
						break;
					case 0x03: /* slide to note 3xy - */
						channel.tonePortaActive = true;
						channel.tonePortaTarget = (note.period != 0) ? note.period : channel.tonePortaTarget;
						var dir = (channel.tonePortaTarget < prevNote.period) ? -1 : 1;
						channel.tonePortaDelta = (note.effectParameter * dir);
						channel.tonePortaVolStep = (note.effectParameter * dir);
						channel.tonePortaDir = dir;
						break;
					case 0x05: /* portamento to note with volume slide 5xy */
						channel.tonePortaActive = true;
						if (note.effectParameter & 0xf0) {
							channel.volumeDelta = note.effectParameter >> 4;
						} else {
							channel.volumeDelta = -note.effectParameter;
						}
						channel.tonePortaDelta = channel.tonePortaVolStep;
						break;
					case 0x09: /* sample offset - 9xx */
						channel.samplePosition = 256 * note.effectParameter;
						break;
					case 0x0A: /* volume slide - Axy */
						if (note.effectParameter & 0xf0) {
							/* volume increase by x */
							channel.volumeDelta = note.effectParameter >> 4;
						} else {
							/* volume decrease by y */
							channel.volumeDelta = -note.effectParameter;
						}
						break;
					case 0x0B: /* jump to order */
						doBreak = true;
						breakPos = note.effectParameter;
						breakRow = 0;
						break;
					case 0x0C: /* volume */
						if (note.effectParameter > 64) {
							channel.volume = 64;
						} else {
							channel.volume = note.effectParameter;
						}
						break;
					case 0x0D: /* pattern break; jump to next pattern at specified row */
						doBreak = true;
						breakPos = currentPosition + 1;
						//Row is written as DECIMAL so grab the high part as a single digit and do some math
						breakRow = ((note.effectParameter & 0xF0) >> 4) * 10 + (note.effectParameter & 0x0F);
						break;
						
					case 0x0E:
						switch (note.extEffect) {	//yes we're doing nested switch
							case 0x01: /* fine pitch slide up - E1x */
								channel.finePeriodDelta = -note.extEffectParameter;
								break;
							case 0x02: /* fine pitch slide down - E2x */
								channel.finePeriodDelta = note.extEffectParameter;
								break;
							case 0x05: /* set finetune - E5x */
								channel.finetune = note.extEffectParameter;
								break;
							case 0x09: /* retrigger sample - E9x */
								channel.retrigger = note.extEffectParameter;
								break;
							case 0x0A: /* fine volume slide up - EAx */
								channel.fineVolumeDelta = note.extEffectParameter;
								break;
							case 0x0B: /* fine volume slide down - EBx */
								channel.fineVolumeDelta = -note.extEffectParameter;
								break;
							case 0x0C: /* note cute - ECx */
								channel.cut = note.extEffectParameter;
								break;
							case 0x0D: /* note delay - EDx */
								channel.delay = note.extEffectParameter;
								break;
							case 0x0E: /* pattern delay EEx */
								delayRows = note.extEffectParameter;
								break;
							case 0x06:
								//set loop start with E60
								if (note.extEffectParameter == 0) {
									exLoopStart = currentRow;
								} else {
									//set loop end with E6x
									exLoopEnd = currentRow;
									//activate the loop only if it's new
									if (!exLoop) {
										exLoop = true;
										exLoopCount = note.extEffectParameter;
									}
								}
								break;
						}
						
						break;
						
					case 0x0F: /* tempo change. <=32 sets ticks/row, greater sets beats/min instead */
						var newSpeed = (note.effectParameter == 0) ? 1 : note.effectParameter; /* 0 is treated as 1 */
						if (newSpeed <= 32) { 
							framesPerRow = newSpeed;
						} else {
							setBpm(newSpeed);
						}
						break;
				}
			}
			
			//for figuring out tone portamento effect
			if (note.period != 0) { channel.prevNote = note; }
			
			if (channel.tonePortaActive == false) {
				channel.tonePortaDelta = 0;
				channel.tonePortaTarget = 0;
				channel.tonePortaVolStep = 0;
			}
		}
		
	}
	
	function loadPattern(patternNumber) {
		var row = doBreak ? breakRow : 0;
		currentPattern = mod.patterns[patternNumber];
		loadRow(row);
	}
	
	function loadPosition(positionNumber) {
		//Handle invalid position numbers that may be passed by invalid loop points
		positionNumber = (positionNumber > mod.positionCount - 1) ? 0 : positionNumber;	
		currentPosition = positionNumber;
		loadPattern(mod.positions[currentPosition]);
	}
	
	loadPosition(0);
	
	function getNextPosition() {
		if (currentPosition + 1 >= mod.positionCount) {
			loadPosition(mod.positionLoopPoint);
		} else {
			loadPosition(currentPosition + 1);
		}
	}
	
	function getNextRow() {
		/*
			Determine where we're gonna go based on active effect.
			Either:
				break (jump to new pattern),
				do extended loop,
				advance normally
		*/
		if (doBreak) {
			//Dxx commands at the end of modules are fairly common for some reason
			//so make sure jumping past the end loops back to the start
			breakPos = (breakPos >= mod.positionCount) ? mod.positionLoopPoint : breakPos;
			loadPosition(breakPos);
		} else if (exLoop && currentRow == exLoopEnd && exLoopCount > 0) {
			//count down the loop and jump back
			loadRow(exLoopStart);
			exLoopCount--;
		} else {
			if (currentRow == 63) {
				getNextPosition();
			} else {
				loadRow(currentRow + 1);
			}
		}
		
		if (exLoopCount < 0) { exLoop = false; }
	}

	function doFrame() {
		/* apply volume/pitch slide before fetching row, because the first frame of a row does NOT
		have the slide applied */

		for (var chan = 0; chan < mod.channelCount; chan++) {
			var channel = channels[chan];
			var finetune = channel.finetune;
			if (currentFrame == 0) { /* apply fine slides only once */
				channel.ticksPerSample += channel.finePeriodDelta * 2;
				channel.volume += channel.fineVolumeDelta;
			}
			channel.volume += channel.volumeDelta;
			if (channel.volume > 64) {
				channel.volume = 64;
			} else if (channel.volume < 0) {
				channel.volume = 0;
			}
			if (channel.cut !== false && currentFrame >= channel.cut) {
				channel.volume = 0;
			}
			if (channel.delay !== false && currentFrame <= channel.delay) {
				channel.volume = 0;
			}
			if (channel.retrigger !== false) {
				//short-circuit prevents x mod 0
				if (channel.retrigger == 0 || currentFrame % channel.retrigger == 0) { 
					channel.samplePosition = 0;
				}
			}
			channel.ticksPerSample += channel.periodDelta * 2;
			if (channel.tonePortaActive) {
				channel.ticksPerSample += channel.tonePortaDelta * 2;
				//don't slide below or above allowed note, depending on slide direction
				if (channel.tonePortaDir == 1 && channel.ticksPerSample > channel.tonePortaTarget * 2) {
					channel.ticksPerSample = channel.tonePortaTarget * 2;
				} else if (channel.tonePortaDir == -1 && channel.ticksPerSample < channel.tonePortaTarget * 2)  {
					channel.ticksPerSample = channel.tonePortaTarget * 2;
				}
			}
			
			if (channel.ticksPerSample > 4096) {
				channel.ticksPerSample = 4096;
			} else if (channel.ticksPerSample < 96) { /* equivalent to period 48, a bit higher than the highest note */
				channel.ticksPerSample = 96;
			}
			if (channel.arpeggioActive) {
				channel.arpeggioCounter++;
				var noteNumber = channel.arpeggioNotes[channel.arpeggioCounter % 3];
				channel.ticksPerSample = ModPeriodTable[finetune][noteNumber] * 2;
			}
		}

		currentFrame++;
		if (currentFrame == framesPerRow) {
			currentFrame = 0;
			//Don't advance to reading more rows if pattern delay effect is active
			if (delayRows !== false) {
				delayRows--;
				if (delayRows < 0) { delayRows = false; }
			} else {
				getNextRow();
			}
		}


	}
	
	this.getSamples = function(sampleCount) {
		samples = [];
		var i = 0;
		while (i < sampleCount) {
			ticksSinceStartOfFrame += ticksPerOutputSample;
			while (ticksSinceStartOfFrame >= ticksPerFrame) {
				doFrame();
				ticksSinceStartOfFrame -= ticksPerFrame;
			}
			
			leftOutputLevel = 0;
			rightOutputLevel = 0;
			for (var chan = 0; chan < mod.channelCount; chan++) {
				var channel = channels[chan];
				if (channel.playing) {
					channel.ticksSinceStartOfSample += ticksPerOutputSample;
					while (channel.ticksSinceStartOfSample >= channel.ticksPerSample) {
						channel.samplePosition++;
						if (channel.sample.repeatLength > 2 && channel.samplePosition >= channel.sample.repeatOffset + channel.sample.repeatLength) {
							channel.samplePosition = channel.sample.repeatOffset;
						} else if (channel.samplePosition >= channel.sample.length) {
							channel.playing = false;
							break;
						} else 
						channel.ticksSinceStartOfSample -= channel.ticksPerSample;
					}
					if (channel.playing) {
						
						var rawVol = mod.sampleData[channel.sampleNum][channel.samplePosition];
						var vol = (((rawVol + 128) & 0xff) - 128) * channel.volume; /* range (-128*64)..(127*64) */
						if (chan & 3 == 0 || chan & 3 == 3) { /* hard panning(?): left, right, right, left */
							leftOutputLevel += (vol + channel.pan) * 3;
							rightOutputLevel += (vol + 0xFF - channel.pan);
						} else {
							leftOutputLevel += (vol + 0xFF - channel.pan)
							rightOutputLevel += (vol + channel.pan) * 3;
						}
						/* range of outputlevels is 128*64*2*channelCount */
						/* (well, it could be more for odd channel counts) */
					}
				}
			}
			
			samples[i] = leftOutputLevel / (128 * 128 * mod.channelCount);
			samples[i+1] = rightOutputLevel / (128 * 128 * mod.channelCount);
			i += 2;
		}
		
		return samples;
	}
}

</script>
		<script type="text/javascript">
//Various helper functions


/*
	Creates a typed array (a view into an ArrayBuffer)
		Size is number of entries, not bytes
		Type is the kind of view
			can be "int8", "uint8", "int16", or "uint16"
			
	If unsupported (Opera) then it simply creates a normal array
*/

function TypedArray(size, type) {
	var multable = {int8: 1, uint8: 1, int16: 2, uint16: 2}
	var view;
	var supported = 
		(typeof ArrayBuffer !== "undefined") &&
		(typeof Int8Array !== "undefined") &&
		(typeof Int16Array !== "undefined") &&
		(typeof Uint8Array !== "undefined") &&
		(typeof Uint16Array !== "undefined");
		
	if (supported) {
		var buffer = new ArrayBuffer(size * multable[type]);
		switch (type) {
			case "int8": return new Int8Array(buffer); break;
			case "int16": return new Int16Array(buffer); break;
			case "uint8": return new Uint8Array(buffer); break;
			case "uint16": return new Uint16Array(buffer); break;
		}
	} else {
		return new Array(size);
	}

	return
	
}


</script>
		<script type="text/javascript">
/*
  Javascript port of CubicVR 3D engine for WebGL
  by Charles J. Cliffe
  http://www.cubicvr.org/

  May be used under the terms of the MIT license.
  http://www.opensource.org/licenses/mit-license.php
*/

/*globals alert: false */

/** Global Constants **/
var M_PI = 3.1415926535897932384626433832795028841968;
var M_TWO_PI = 2.0 * M_PI;
var M_HALF_PI = M_PI / 2.0;

var SCRIPT_LOCATION = "";

try {
  Array.forEach(document.querySelectorAll("script"), function (a) {
      var pos = a.src.lastIndexOf('/CubicVR.js');
      if (pos > -1) {
        SCRIPT_LOCATION = a.src.substr(0, pos) + "/";
      } //if
  });
}
catch(e) {
  // likely that 'document' is not defined (doesn't really matter)
} //try

(function(undef) {

  var CubicVR = this.CubicVR = {};

  var GLCore = {};
  var Materials = [];
  var Material_ref = [];
  var Textures = [];
  var Textures_obj = [];
  var Texture_ref = [];
  var Images = [];
  var ShaderPool = [];
  var MeshPool = [];

  var CoreShader_vs = null;
  var CoreShader_fs = null;

  var log;
  try {
    log = (console !== undefined && console.log) ?
      function(msg) { console.log("CubicVR Log: " + msg); } :
      function() {};
  }
  catch(e) {
    log = function() {};
  } //try

  var enums = {
    // Math
    math: {},

    frustum: {
      plane: {
        LEFT: 0,
        RIGHT: 1,
        TOP: 2,
        BOTTOM: 3,
        NEAR: 4,
        FAR: 5
      }
    },

    octree: {
      TOP_NW: 0,
      TOP_NE: 1,
      TOP_SE: 2,
      TOP_SW: 3,
      BOTTOM_NW: 4,
      BOTTOM_NE: 5,
      BOTTOM_SE: 6,
      BOTTOM_SW: 7
    },


    // Light Types
    light: {
      type: {
        NULL: 0,
        POINT: 1,
        DIRECTIONAL: 2,
        SPOT: 3,
        AREA: 4,
        DEPTH_PACK: 5,  // this lets us pass the shadow stage in as a light definition
        SPOT_SHADOW: 6,
        MAX: 7
      },
      method: {
        GLOBAL: 0,
        STATIC: 1,
        DYNAMIC: 2
      }
    },

    // Texture Types
    texture: {
      map: {
        COLOR: 0,
        ENVSPHERE: 1,
        NORMAL: 2,
        BUMP: 3,
        REFLECT: 4,
        SPECULAR: 5,
        AMBIENT: 6,
        ALPHA: 7,
        MAX: 8
      },
      filter: {
        LINEAR: 0,
        LINEAR_MIP: 1,
        NEAREST: 2,
        NEAREST_MIP: 3
      }
    },

    uv: {
      /* UV Axis enums */
      axis: {
        X: 0,
        Y: 1,
        Z: 2
      },

      /* UV Projection enums */
      projection: {
        UV: 0,
        PLANAR: 1,
        CYLINDRICAL: 2,
        SPHERICAL: 3,
        CUBIC: 4,
        SKY: 5
      }
    },

    // Shader Map Inputs (binary hash index)
    shader: {
      map: {
        COLOR: 1,
        SPECULAR: 2,
        NORMAL: 4,
        BUMP: 8,
        REFLECT: 16,
        ENVSPHERE: 32,
        AMBIENT: 64,
        ALPHA: 128
      },

      /* Uniform types */
      uniform: {
        MATRIX: 0,
        VECTOR: 1,
        FLOAT: 2,
        ARRAY_VERTEX: 3,
        ARRAY_UV: 4,
        ARRAY_FLOAT: 5,
        INT: 6
      }

    },

    motion: {
      POS: 0,
      ROT: 1,
      SCL: 2,
      FOV: 3,
      LENS: 4,
      NEARCLIP: 5,
      FARCLIP: 6,
      INTENSITY: 7,
      X: 0,
      Y: 1,
      Z: 2,
      V: 3
    },

    envelope: {
      shape: {
        TCB: 0,
        HERM: 1,
        BEZI: 2,
        LINE: 3,
        STEP: 4,
        BEZ2: 5
      },
      behavior: {
        RESET: 0,
        CONSTANT: 1,
        REPEAT: 2,
        OSCILLATE: 3,
        OFFSET: 4,
        LINEAR: 5
      }
    },

    /* Post Processing */
    post: {
      output: {
        REPLACE: 0,
        BLEND: 1,
        ADD: 2,
        ALPHACUT: 3
      }
    }
  };

  var cubicvr_identity = [1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0];

  /* Base functions */
  var vec2 = {
    equal: function(a, b) {
      var epsilon = 0.00000001;

      if ((a === undef) && (b === undef)) {
        return true;
      }
      if ((a === undef) || (b === undef)) {
        return false;
      }

      return (Math.abs(a[0] - b[0]) < epsilon && Math.abs(a[1] - b[1]) < epsilon);
    }
  };

  var vec3 = {
    length: function(pt) {
      return Math.sqrt(pt[0] * pt[0] + pt[1] * pt[1] + pt[2] * pt[2]);
    },
    normalize: function(pt) {
      var d = Math.sqrt((pt[0] * pt[0]) + (pt[1] * pt[1]) + (pt[2] * pt[2]));
      if (d === 0) {
        return [0, 0, 0];
      }
      return [pt[0] / d, pt[1] / d, pt[2] / d];
    },
    dot: function(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    },
    angle: function(v1, v2) {
      var a = Math.acos((v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]) / (Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]) * Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2])));

      return a;
    },
    cross: function(vectA, vectB) {
      return [
      vectA[1] * vectB[2] - vectB[1] * vectA[2], vectA[2] * vectB[0] - vectB[2] * vectA[0], vectA[0] * vectB[1] - vectB[0] * vectA[1]];
    },
    multiply: function(vectA, constB) {
      return [vectA[0] * constB, vectA[1] * constB, vectA[2] * constB];
    },
    add: function(vectA, vectB) {
      return [vectA[0] + vectB[0], vectA[1] + vectB[1], vectA[2] + vectB[2]];
    },
    subtract: function(vectA, vectB) {
      return [vectA[0] - vectB[0], vectA[1] - vectB[1], vectA[2] - vectB[2]];
    },
    equal: function(a, b) {
      var epsilon = 0.0000001;

      if ((a === undef) && (b === undef)) {
        return true;
      }
      if ((a === undef) || (b === undef)) {
        return false;
      }

      return (Math.abs(a[0] - b[0]) < epsilon && Math.abs(a[1] - b[1]) < epsilon && Math.abs(a[2] - b[2]) < epsilon);
    },
    moveViewRelative: function(position, target, xdelta, zdelta, alt_source) {
      var ang = Math.atan2(zdelta, xdelta);
      var cam_ang = Math.atan2(target[2] - position[2], target[0] - position[0]);
      var mag = Math.sqrt(xdelta * xdelta + zdelta * zdelta);

      var move_ang = cam_ang + ang + M_HALF_PI;

      if (typeof(alt_source) === 'object') {
        return [alt_source[0] + mag * Math.cos(move_ang), alt_source[1], alt_source[2] + mag * Math.sin(move_ang)];
      }

      return [position[0] + mag * Math.cos(move_ang), position[1], position[2] + mag * Math.sin(move_ang)];
    },
    trackTarget: function(position, target, trackingSpeed, safeDistance) {
      var camv = vec3.subtract(target, position);
      var dist = camv;
      var fdist = vec3.length(dist);
      var motionv = camv;

      motionv = vec3.normalize(motionv);
      motionv = vec3.multiply(motionv, trackingSpeed * (1.0 / (1.0 / (fdist - safeDistance))));

      var ret_pos;

      if (fdist > safeDistance) {
        ret_pos = vec3.add(position, motionv);
      } else if (fdist < safeDistance) {
        motionv = camv;
        motionv = vec3.normalize(motionv);
        motionv = vec3.multiply(motionv, trackingSpeed * (1.0 / (1.0 / (Math.abs(fdist - safeDistance)))));
        ret_pos = vec3.subtract(position, motionv);
      } else {
        ret_pos = [position[0], position[1] + motionv[2], position[2]];
      }

      return ret_pos;
    },
    get_closest_to: function(ptA, ptB, ptTest) {
      var S, T, U;

      S = vec3.subtract(ptB, ptA);
      T = vec3.subtract(ptTest, ptA);
      U = vec3.add(vec3.multiply(S, vec3.dot(S, T) / vec3.dot(S, S)), ptA);

      return U;
    }
  };

  var triangle = {
    normal: function(pt1, pt2, pt3) {
      
      var v10 = pt1[0] - pt2[0];
      var v11 = pt1[1] - pt2[1];
      var v12 = pt1[2] - pt2[2];
      var v20 = pt2[0] - pt3[0];
      var v21 = pt2[1] - pt3[1];
      var v22 = pt2[2] - pt3[2];
      
      return [v11 * v22 - v12 * v21, v12 * v20 - v10 * v22, v10 * v21 - v11 * v20];
    }
  };
  
  
  var mat3 = {
    transpose_inline: function(mat) {
        var a01 = mat[1], a02 = mat[2], a12 = mat[5];

        mat[1] = mat[3];
        mat[2] = mat[6];
        mat[3] = a01;
        mat[5] = mat[7];
        mat[6] = a02;
        mat[7] = a12;
    }
  }

  var mat4 = {
      lookat: function(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz) {
          var forward = [], side = [], up = [];
          var m = [];

          forward[0] = centerx - eyex;
          forward[1] = centery - eyey;
          forward[2] = centerz - eyez;

          up[0] = upx;
          up[1] = upy;
          up[2] = upz;

          forward = vec3.normalize(forward);

          /* Side = forward x up */
          var side = vec3.cross(forward, up);
          side = vec3.normalize(side);

          /* Recompute up as: up = side x forward */
          up = vec3.cross(side, forward);

          var m = [ side[0], up[0], -forward[0], 0, side[1], up[1], -forward[1], 0, side[2], up[2], -forward[2], 0, 0, 0, 0, 1];

          var t = new Transform(m);
          t.translate([-eyex,-eyey,-eyez]);

          return t.getResult();
      },
      multiply: function (m1, m2) {
          var mOut = [];

          mOut[0] = m2[0] * m1[0] + m2[4] * m1[1] + m2[8] * m1[2] + m2[12] * m1[3];
          mOut[1] = m2[1] * m1[0] + m2[5] * m1[1] + m2[9] * m1[2] + m2[13] * m1[3];
          mOut[2] = m2[2] * m1[0] + m2[6] * m1[1] + m2[10] * m1[2] + m2[14] * m1[3];
          mOut[3] = m2[3] * m1[0] + m2[7] * m1[1] + m2[11] * m1[2] + m2[15] * m1[3];
          mOut[4] = m2[0] * m1[4] + m2[4] * m1[5] + m2[8] * m1[6] + m2[12] * m1[7];
          mOut[5] = m2[1] * m1[4] + m2[5] * m1[5] + m2[9] * m1[6] + m2[13] * m1[7];
          mOut[6] = m2[2] * m1[4] + m2[6] * m1[5] + m2[10] * m1[6] + m2[14] * m1[7];
          mOut[7] = m2[3] * m1[4] + m2[7] * m1[5] + m2[11] * m1[6] + m2[15] * m1[7];
          mOut[8] = m2[0] * m1[8] + m2[4] * m1[9] + m2[8] * m1[10] + m2[12] * m1[11];
          mOut[9] = m2[1] * m1[8] + m2[5] * m1[9] + m2[9] * m1[10] + m2[13] * m1[11];
          mOut[10] = m2[2] * m1[8] + m2[6] * m1[9] + m2[10] * m1[10] + m2[14] * m1[11];
          mOut[11] = m2[3] * m1[8] + m2[7] * m1[9] + m2[11] * m1[10] + m2[15] * m1[11];
          mOut[12] = m2[0] * m1[12] + m2[4] * m1[13] + m2[8] * m1[14] + m2[12] * m1[15];
          mOut[13] = m2[1] * m1[12] + m2[5] * m1[13] + m2[9] * m1[14] + m2[13] * m1[15];
          mOut[14] = m2[2] * m1[12] + m2[6] * m1[13] + m2[10] * m1[14] + m2[14] * m1[15];
          mOut[15] = m2[3] * m1[12] + m2[7] * m1[13] + m2[11] * m1[14] + m2[15] * m1[15];

          return mOut;
      },
      vec4_multiply: function (m1, m2) {
          var mOut = [];

          mOut[0] = m2[0] * m1[0] + m2[4] * m1[1] + m2[8] * m1[2] + m2[12] * m1[3];
          mOut[1] = m2[1] * m1[0] + m2[5] * m1[1] + m2[9] * m1[2] + m2[13] * m1[3];
          mOut[2] = m2[2] * m1[0] + m2[6] * m1[1] + m2[10] * m1[2] + m2[14] * m1[3];
          mOut[3] = m2[3] * m1[0] + m2[7] * m1[1] + m2[11] * m1[2] + m2[15] * m1[3];

          return mOut;
      },
      vec3_multiply: function (m1, m2) {
          var mOut = [];

          mOut[0] = m2[0] * m1[0] + m2[4] * m1[1] + m2[8] * m1[2] + m2[12];
          mOut[1] = m2[1] * m1[0] + m2[5] * m1[1] + m2[9] * m1[2] + m2[13];
          mOut[2] = m2[2] * m1[0] + m2[6] * m1[1] + m2[10] * m1[2] + m2[14];

          return mOut;
      },
      perspective: function (fovy, aspect, near, far) {
          var yFac = Math.tan(fovy * M_PI / 360.0);
          var xFac = yFac * aspect;

          return [
          1.0 / xFac, 0, 0, 0, 0, 1.0 / yFac, 0, 0, 0, 0, -(far + near) / (far - near), -1, 0, 0, -(2.0 * far * near) / (far - near), 0];
      },
      determinant: function (m) {

          var a0 = m[0] * m[5] - m[1] * m[4];
          var a1 = m[0] * m[6] - m[2] * m[4];
          var a2 = m[0] * m[7] - m[3] * m[4];
          var a3 = m[1] * m[6] - m[2] * m[5];
          var a4 = m[1] * m[7] - m[3] * m[5];
          var a5 = m[2] * m[7] - m[3] * m[6];
          var b0 = m[8] * m[13] - m[9] * m[12];
          var b1 = m[8] * m[14] - m[10] * m[12];
          var b2 = m[8] * m[15] - m[11] * m[12];
          var b3 = m[9] * m[14] - m[10] * m[13];
          var b4 = m[9] * m[15] - m[11] * m[13];
          var b5 = m[10] * m[15] - m[11] * m[14];

          var det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

          return det;
      },
      coFactor: function (m, n, out) {
        // .. todo..
      },

      transpose: function (m) {
          return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
      },

      inverse_mat3: function(mat) {
          var dest = [];

          var a00 = mat[0], a01 = mat[1], a02 = mat[2],
          a10 = mat[4], a11 = mat[5], a12 = mat[6],
          a20 = mat[8], a21 = mat[9], a22 = mat[10];

          var b01 = a22*a11-a12*a21,
          b11 = -a22*a10+a12*a20,
          b21 = a21*a10-a11*a20;

          var d = a00*b01 + a01*b11 + a02*b21;
          if (!d) { return null; }
          var id = 1/d;

          dest[0] = b01*id;
          dest[1] = (-a22*a01 + a02*a21)*id;
          dest[2] = (a12*a01 - a02*a11)*id;
          dest[3] = b11*id;
          dest[4] = (a22*a00 - a02*a20)*id;
          dest[5] = (-a12*a00 + a02*a10)*id;
          dest[6] = b21*id;
          dest[7] = (-a21*a00 + a01*a20)*id;
          dest[8] = (a11*a00 - a01*a10)*id;

          return dest;
      },

      // not sure which is faster yet..
      
      inverse$1: function (m) {
          var tmp = [];
          var src = [];
          var dst = [];  

          // Transpose matrix
          for (var i = 0; i < 4; i++) {
            src[i +  0] = m[i*4 + 0];
            src[i +  4] = m[i*4 + 1];
            src[i +  8] = m[i*4 + 2];
            src[i + 12] = m[i*4 + 3];
          }

          // Calculate pairs for first 8 elements (cofactors) 
          tmp[0] = src[10] * src[15];
          tmp[1] = src[11] * src[14];
          tmp[2] = src[9]  * src[15];
          tmp[3] = src[11] * src[13];
          tmp[4] = src[9]  * src[14];
          tmp[5] = src[10] * src[13];
          tmp[6] = src[8]  * src[15];
          tmp[7] = src[11] * src[12];
          tmp[8] = src[8]  * src[14];
          tmp[9] = src[10] * src[12];
          tmp[10] = src[8] * src[13];
          tmp[11] = src[9] * src[12];

          // Calculate first 8 elements (cofactors)
          dst[0]  = tmp[0]*src[5] + tmp[3]*src[6] + tmp[4]*src[7];
          dst[0] -= tmp[1]*src[5] + tmp[2]*src[6] + tmp[5]*src[7];
          dst[1]  = tmp[1]*src[4] + tmp[6]*src[6] + tmp[9]*src[7];
          dst[1] -= tmp[0]*src[4] + tmp[7]*src[6] + tmp[8]*src[7];
          dst[2]  = tmp[2]*src[4] + tmp[7]*src[5] + tmp[10]*src[7];
          dst[2] -= tmp[3]*src[4] + tmp[6]*src[5] + tmp[11]*src[7];
          dst[3]  = tmp[5]*src[4] + tmp[8]*src[5] + tmp[11]*src[6];
          dst[3] -= tmp[4]*src[4] + tmp[9]*src[5] + tmp[10]*src[6];
          dst[4]  = tmp[1]*src[1] + tmp[2]*src[2] + tmp[5]*src[3];
          dst[4] -= tmp[0]*src[1] + tmp[3]*src[2] + tmp[4]*src[3];
          dst[5]  = tmp[0]*src[0] + tmp[7]*src[2] + tmp[8]*src[3];
          dst[5] -= tmp[1]*src[0] + tmp[6]*src[2] + tmp[9]*src[3];
          dst[6]  = tmp[3]*src[0] + tmp[6]*src[1] + tmp[11]*src[3];
          dst[6] -= tmp[2]*src[0] + tmp[7]*src[1] + tmp[10]*src[3];
          dst[7]  = tmp[4]*src[0] + tmp[9]*src[1] + tmp[10]*src[2];
          dst[7] -= tmp[5]*src[0] + tmp[8]*src[1] + tmp[11]*src[2];

          // Calculate pairs for second 8 elements (cofactors)
          tmp[0]  = src[2]*src[7];
          tmp[1]  = src[3]*src[6];
          tmp[2]  = src[1]*src[7];
          tmp[3]  = src[3]*src[5];
          tmp[4]  = src[1]*src[6];
          tmp[5]  = src[2]*src[5];
          tmp[6]  = src[0]*src[7];
          tmp[7]  = src[3]*src[4];
          tmp[8]  = src[0]*src[6];
          tmp[9]  = src[2]*src[4];
          tmp[10] = src[0]*src[5];
          tmp[11] = src[1]*src[4];

          // Calculate second 8 elements (cofactors)
          dst[8]   = tmp[0] * src[13]  + tmp[3] * src[14]  + tmp[4] * src[15];
          dst[8]  -= tmp[1] * src[13]  + tmp[2] * src[14]  + tmp[5] * src[15];
          dst[9]   = tmp[1] * src[12]  + tmp[6] * src[14]  + tmp[9] * src[15];
          dst[9]  -= tmp[0] * src[12]  + tmp[7] * src[14]  + tmp[8] * src[15];
          dst[10]  = tmp[2] * src[12]  + tmp[7] * src[13]  + tmp[10]* src[15];
          dst[10] -= tmp[3] * src[12]  + tmp[6] * src[13]  + tmp[11]* src[15];
          dst[11]  = tmp[5] * src[12]  + tmp[8] * src[13]  + tmp[11]* src[14];
          dst[11] -= tmp[4] * src[12]  + tmp[9] * src[13]  + tmp[10]* src[14];
          dst[12]  = tmp[2] * src[10]  + tmp[5] * src[11]  + tmp[1] * src[9];
          dst[12] -= tmp[4] * src[11]  + tmp[0] * src[9]   + tmp[3] * src[10];
          dst[13]  = tmp[8] * src[11]  + tmp[0] * src[8]   + tmp[7] * src[10];
          dst[13] -= tmp[6] * src[10]  + tmp[9] * src[11]  + tmp[1] * src[8];
          dst[14]  = tmp[6] * src[9]   + tmp[11]* src[11]  + tmp[3] * src[8];
          dst[14] -= tmp[10]* src[11 ] + tmp[2] * src[8]   + tmp[7] * src[9];
          dst[15]  = tmp[10]* src[10]  + tmp[4] * src[8]   + tmp[9] * src[9];
          dst[15] -= tmp[8] * src[9]   + tmp[11]* src[10]  + tmp[5] * src[8];

          // Calculate determinant
          var det = src[0]*dst[0] + src[1]*dst[1] + src[2]*dst[2] + src[3]*dst[3];
          
          var ret = [];

          // Calculate matrix inverse
          det = 1.0 / det;
          for (var i = 0; i < 16; i++) {
            ret[i] = dst[i] * det;
          }
            
            return ret;
      },

      inverse$2: function (m) {
        var inv = [];

        inv[0] =   m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15]
        + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10];
        inv[4] =  -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15]
        - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10];
        inv[8] =   m[4]*m[9]*m[15] - m[4]*m[11]*m[13] - m[8]*m[5]*m[15]
        + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9];
        inv[12] = -m[4]*m[9]*m[14] + m[4]*m[10]*m[13] + m[8]*m[5]*m[14]
        - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9];
        inv[1] =  -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15]
        - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10];
        inv[5] =   m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15]
        + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10];
        inv[9] =  -m[0]*m[9]*m[15] + m[0]*m[11]*m[13] + m[8]*m[1]*m[15]
        - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9];
        inv[13] =  m[0]*m[9]*m[14] - m[0]*m[10]*m[13] - m[8]*m[1]*m[14]
        + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9];
        inv[2] =   m[1]*m[6]*m[15] - m[1]*m[7]*m[14] - m[5]*m[2]*m[15]
        + m[5]*m[3]*m[14] + m[13]*m[2]*m[7] - m[13]*m[3]*m[6];
        inv[6] =  -m[0]*m[6]*m[15] + m[0]*m[7]*m[14] + m[4]*m[2]*m[15]
        - m[4]*m[3]*m[14] - m[12]*m[2]*m[7] + m[12]*m[3]*m[6];
        inv[10] =  m[0]*m[5]*m[15] - m[0]*m[7]*m[13] - m[4]*m[1]*m[15]
        + m[4]*m[3]*m[13] + m[12]*m[1]*m[7] - m[12]*m[3]*m[5];
        inv[14] = -m[0]*m[5]*m[14] + m[0]*m[6]*m[13] + m[4]*m[1]*m[14]
        - m[4]*m[2]*m[13] - m[12]*m[1]*m[6] + m[12]*m[2]*m[5];
        inv[3] =  -m[1]*m[6]*m[11] + m[1]*m[7]*m[10] + m[5]*m[2]*m[11]
        - m[5]*m[3]*m[10] - m[9]*m[2]*m[7] + m[9]*m[3]*m[6];
        inv[7] =   m[0]*m[6]*m[11] - m[0]*m[7]*m[10] - m[4]*m[2]*m[11]
        + m[4]*m[3]*m[10] + m[8]*m[2]*m[7] - m[8]*m[3]*m[6];
        inv[11] = -m[0]*m[5]*m[11] + m[0]*m[7]*m[9] + m[4]*m[1]*m[11]
        - m[4]*m[3]*m[9] - m[8]*m[1]*m[7] + m[8]*m[3]*m[5];
        inv[15] =  m[0]*m[5]*m[10] - m[0]*m[6]*m[9] - m[4]*m[1]*m[10]
        + m[4]*m[2]*m[9] + m[8]*m[1]*m[6] - m[8]*m[2]*m[5];

        det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];

        if (det == 0) return null;

        inverse_det = 1.0 / det;

        inv[0] *= inverse_det;
        inv[1] *= inverse_det;
        inv[2] *= inverse_det;
        inv[3] *= inverse_det;
        inv[4] *= inverse_det;
        inv[5] *= inverse_det;
        inv[6] *= inverse_det;
        inv[7] *= inverse_det;
        inv[8] *= inverse_det;
        inv[9] *= inverse_det;
        inv[10] *= inverse_det;
        inv[11] *= inverse_det;
        inv[12] *= inverse_det;
        inv[13] *= inverse_det;
        inv[14] *= inverse_det;
        inv[15] *= inverse_det;

        return inv;
      },
      
      inverse: function (m) {
          var a0 = m[0] * m[5] - m[1] * m[4];
          var a1 = m[0] * m[6] - m[2] * m[4];
          var a2 = m[0] * m[7] - m[3] * m[4];
          var a3 = m[1] * m[6] - m[2] * m[5];
          var a4 = m[1] * m[7] - m[3] * m[5];
          var a5 = m[2] * m[7] - m[3] * m[6];
          var b0 = m[8] * m[13] - m[9] * m[12];
          var b1 = m[8] * m[14] - m[10] * m[12];
          var b2 = m[8] * m[15] - m[11] * m[12];
          var b3 = m[9] * m[14] - m[10] * m[13];
          var b4 = m[9] * m[15] - m[11] * m[13];
          var b5 = m[10] * m[15] - m[11] * m[14];

          var determinant = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

          if (determinant != 0) {
              var m_inv = [];
              m_inv[0] = 0 + m[5] * b5 - m[6] * b4 + m[7] * b3;
              m_inv[4] = 0 - m[4] * b5 + m[6] * b2 - m[7] * b1;
              m_inv[8] = 0 + m[4] * b4 - m[5] * b2 + m[7] * b0;
              m_inv[12] = 0 - m[4] * b3 + m[5] * b1 - m[6] * b0;
              m_inv[1] = 0 - m[1] * b5 + m[2] * b4 - m[3] * b3;
              m_inv[5] = 0 + m[0] * b5 - m[2] * b2 + m[3] * b1;
              m_inv[9] = 0 - m[0] * b4 + m[1] * b2 - m[3] * b0;
              m_inv[13] = 0 + m[0] * b3 - m[1] * b1 + m[2] * b0;
              m_inv[2] = 0 + m[13] * a5 - m[14] * a4 + m[15] * a3;
              m_inv[6] = 0 - m[12] * a5 + m[14] * a2 - m[15] * a1;
              m_inv[10] = 0 + m[12] * a4 - m[13] * a2 + m[15] * a0;
              m_inv[14] = 0 - m[12] * a3 + m[13] * a1 - m[14] * a0;
              m_inv[3] = 0 - m[9] * a5 + m[10] * a4 - m[11] * a3;
              m_inv[7] = 0 + m[8] * a5 - m[10] * a2 + m[11] * a1;
              m_inv[11] = 0 - m[8] * a4 + m[9] * a2 - m[11] * a0;
              m_inv[15] = 0 + m[8] * a3 - m[9] * a1 + m[10] * a0;

              var inverse_det = 1.0 / determinant;

              m_inv[0] *= inverse_det;
              m_inv[1] *= inverse_det;
              m_inv[2] *= inverse_det;
              m_inv[3] *= inverse_det;
              m_inv[4] *= inverse_det;
              m_inv[5] *= inverse_det;
              m_inv[6] *= inverse_det;
              m_inv[7] *= inverse_det;
              m_inv[8] *= inverse_det;
              m_inv[9] *= inverse_det;
              m_inv[10] *= inverse_det;
              m_inv[11] *= inverse_det;
              m_inv[12] *= inverse_det;
              m_inv[13] *= inverse_det;
              m_inv[14] *= inverse_det;
              m_inv[15] *= inverse_det;

              return m_inv;
          }

          return null; 
      }
  };
  
  
  var util = {
    getScriptContents: function(id) {
      var shaderScript = document.getElementById(id);

      var str = "";
      var srcUrl = "";

      if (!shaderScript) {
        srcUrl = id;
      } else {
        if (shaderScript.src !== "" || shaderScript.attributes['srcUrl'] !== undef) {
          srcUrl = (shaderScript.src !== '') ? shaderScript.src : (shaderScript.attributes['srcUrl'].value);
        }
      }

      if (srcUrl.length !== 0) {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open('GET', srcUrl, false);
        xmlHttp.send(null);

        if (xmlHttp.status === 200 || xmlHttp.status === 0) {
          str = xmlHttp.responseText;
        }
      } else {
        var k = shaderScript.firstChild;
        while (k) {
          if (k.nodeType === 3) {
            str += k.textContent;
          }
          k = k.nextSibling;
        }
      }

      return str;
    },
    getURL: function(srcUrl) {
      try {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open('GET', srcUrl, false);
        xmlHttp.send(null);

        if (xmlHttp.status === 200 || xmlHttp.status === 0) {
          if (xmlHttp.responseText.length) {
            return xmlHttp.responseText;
          } else if (xmlHttp.responseXML) {
            return xmlHttp.responseXML;
          }
        }
      }
      catch(e) {
        alert(srcUrl + " failed to load.");
      }


      return null;
    },
    getXML: function(srcUrl) {
      try {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open('GET', srcUrl, false);
        xmlHttp.overrideMimeType("application/xml");
        xmlHttp.send(null);

        if (xmlHttp.status === 200 || xmlHttp.status === 0) {
          return xmlHttp.responseXML;
        }
      }
      catch(e) {
        try {
          alert(srcUrl + " failed to load.");
        }
        catch (ex) {
          throw(e);
        }
      }


      return null;
    },
    repackArray: function(data, stride, count) {
      if (data.length !== parseInt(stride, 10) * parseInt(count, 10)) {
        log("array repack error, data size !== stride*count: data.length=" +
            data.length + " stride=" + stride + " count=" + count);
      }

      var returnData = [];

      var c = 0;
      for (var i = 0, iMax = data.length; i < iMax; i++) {
        var ims = i % stride;

        if (ims === 0) {
          returnData[c] = [];
        }

        returnData[c][ims] = data[i];

        if (ims === stride - 1) {
          c++;
        }
      }

      return returnData;
    },
    collectTextNode: function(tn) {
      if (!tn) {
        return "";
      }

      var s = "";
      var textNodeChildren = tn.childNodes;
      for (var i = 0, tnl = textNodeChildren.length; i < tnl; i++) {
        s += textNodeChildren[i].nodeValue;
      }
      return s;
    },
    floatDelimArray: function(float_str, delim) {
//      if (!float_str) return [];
      var fa = float_str.split(delim ? delim : ",");
      for (var i = 0, imax = fa.length; i < imax; i++) {
        fa[i] = parseFloat(fa[i]);
      }
      if (fa[fa.length - 1] !== fa[fa.length - 1]) {
        fa.pop();
      }
      return fa;
    },
    intDelimArray: function(float_str, delim) {
//      if (!float_str) return [];
      var fa = float_str.split(delim ? delim : ",");
      for (var i = 0, imax = fa.length; i < imax; i++) {
        fa[i] = parseInt(fa[i], 10);
      }
      if (fa[fa.length - 1] !== fa[fa.length - 1]) {
        fa.pop();
      }
      return fa;
    },
    textDelimArray: function(text_str, delim) {
//      if (!text_str) return "";
      var fa = text_str.split(delim ? delim : ",");
      for (var i = 0, imax = fa.length; i < imax; i++) {
        fa[i] = fa[i];
      }
      return fa;
    }
  };


  var MAX_LIGHTS=6;


  /* Core Init, single context only at the moment */
  GLCore.init = function(gl_in, vs_in, fs_in) {
    var gl;
    
    if (gl_in.getContext!==undef&&gl_in.width!==undef&&gl_in.height!==undef)
    {
      try {
            gl = gl_in.getContext("experimental-webgl");
            gl.viewport(0, 0, gl_in.width, gl_in.height);
            
            // set these default, can always be easily over-ridden
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);            
      } catch (e) {}
      
      if (!gl) {
//         alert("Could not initialise WebGL, sorry :-(");
         return null;
      }
    }
    else
    {
      gl = gl_in;      
    }


    GLCore.gl = gl;
    GLCore.CoreShader_vs = util.getScriptContents(vs_in);
    GLCore.CoreShader_fs = util.getScriptContents(fs_in);
    GLCore.depth_alpha = false;
    GLCore.default_filter = enums.texture.filter.LINEAR_MIP;
    GLCore.mainloop = null;
    GLCore.shadow_near = 0.1;
    GLCore.shadow_far = 100;
    GLCore.soft_shadow = false;

    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);


    for (var i = enums.light.type.NULL; i < enums.light.type.MAX; i++) {
      ShaderPool[i] = [];
    }

    var dummyTex = new CubicVR.Texture();
    var lightTest = new CubicVR.Material();

    for (var i = 0; i < enums.texture.map.MAX; i++) {
      if (i===enums.texture.map.BUMP) continue; // fix for crashy fglrx driver, todo: check it against newer revisions.
      lightTest.setTexture(dummyTex,i);
    }
    lightTest.opacity = 0.5;

    var lc = 1;
    
    try {
      while (1) {
        lightTest.use(enums.light.type.POINT,lc);
        if (lc === 8) {
          MAX_LIGHTS=lc;      
          break;
        }
        lc++;
      }
    } catch (e) {
      MAX_LIGHTS=lc;      
      // console.log(e);
    }

    log("Calibrated maximum lights per pass to: "+lc);
    

    for (var i = enums.light.type.NULL; i < enums.light.type.MAX; i++) {
      ShaderPool[i] = [];
    }
    
    
    return gl;
  };

  GLCore.setDepthAlpha = function(da, near, far) {
    GLCore.depth_alpha = da;
    GLCore.depth_alpha_near = near;
    GLCore.depth_alpha_far = far;
  };

  GLCore.setDefaultFilter = function(filterType) {
    GLCore.default_filter = filterType;
  };


  

  var cubicvr_compileShader = function(gl, str, type) {
    var shader;

    if (type === "x-shader/x-fragment") {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (type === "x-shader/x-vertex") {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      log(gl.getShaderInfoLog(shader));
      return null;
    }

    return shader;
  };

  var cubicvr_getShader = function(gl, id) {
    var shaderScript = document.getElementById(id);

    if (!shaderScript) {
      return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
      if (k.nodeType === 3) {
        str += k.textContent;
      }
      k = k.nextSibling;
    }

    var shader;

    if (shaderScript.type === "x-shader/x-fragment") {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type === "x-shader/x-vertex") {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
      return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      log(gl.getShaderInfoLog(shader));
//      return null;
    }

    return shader;
  };

  /*****************************************************************************
   * Workers
   *****************************************************************************/

  function CubicVR_Worker(settings) {
    this.worker = new Worker(SCRIPT_LOCATION + "CubicVR.js");
    this.message = settings.message;
    this.error = settings.error;
    this.type = settings.type;
    var that = this;
    this.worker.onmessage = function(e) {
      if (that.message) {
        that.message(e.data);
      } //if
    };
    this.worker.onerror = function(e) {
      if (that.error) {
        that.error(e);
      } else {
        log("Error: " + e.message + ": " + e.lineno);
      } //if
    }; //onerror
    this.fn = function(fn, options) {
      that.worker.postMessage({
        message: "function",
        data: fn,
        options: options,
      });
    };
    this.start = function(options) {
      that.worker.postMessage({
        message: "start",
        data: that.type,
        options: options
      });
    };
    this.init = function(data) {
      that.send({message:'init', data:data});
    };
    this.stop = function() {
      that.worker.postMessage({
        message: "stop",
        data: null
      });
    };
    this.send = function(message) {
      that.worker.postMessage({
        message: "data",
        data: message
      });
    };
  }; //CubicVR_Worker::Constructor 

  function CubicVR_TestWorker() {
    var that = this;
    this.onmessage = function(message) {
      if (message.test) {
        setTimeout(function(){postMessage(message.test);}, 1000);
      }
      else {
        setTimeout(function(){throw new Error(message);}, 1000);
      } //if
    }; //onmessage
  }; //CubicVR_TestWorker

  function CubicVR_ColladaLoadWorker() {
    var that = this;
    this.onmessage = function(message) {
    }; //onmessage
  }; //CubicVR_ColladaLoadWorker

  function CubicVR_WorkerConnection() {
    this.listener = null;
  } //CubicVR_WorkerConnection
  var WorkerConnection = new CubicVR_WorkerConnection();

  if (1) {
    self.addEventListener('message', function(e) {
      var message = e.data.message;
      var type = e.data.data;
      if (message === "start") {
        if (type === "test") {
          WorkerConnection.listener = new CubicVR_TestWorker();
        }
        else if (type === "load_collada") {
          WorkerConnection.listener = new CubicVR_ColladaLoadWorker();
        }
        else if (type === "octree") {
          WorkerConnection.listener = new CubicVR_OctreeWorker();
        } //if
      }
      else if (message === "function") {
        var data = e.data.data;
        var options = e.data.options;
        var parts = data.split('(');
        if (parts.length > 1 && parts[1].indexOf(')') > -1) {
          var prefix = parts[0];
          var suffix = parts[1].substr(0,parts[1].length-1);
          var args = options || suffix.split(',');
          var chain = prefix.split('.');
          var fn = CubicVR;
          for (var i=0; i<chain.length; ++i) {
            fn = fn[chain[i]];
          } //for
          if (fn && typeof fn === 'function') {
            var ret = fn.apply(fn, args);
            postMessage(ret);
          } //if
        }
        else {
          throw new Error('Worker command not formatted properly.');
        } //if
      }
      else if (message === "data") {
        if (WorkerConnection.listener !== null) {
          var data = e.data ? e.data.data : null;
          WorkerConnection.listener.onmessage(e.data.data);
        } //if
      }
      else if (message === "stop") {
        if (WorkerConnection.listener !== null && WorkerConnection.listener.stop) {
          WorkerConnection.listener.stop();
        } //if
      } //if
    }, false);
  } //if

  /* Timer */

  function Timer() {
      this.time_elapsed = 0;
      this.system_milliseconds = 0;
      this.start_time = 0;
      this.end_time = 0;
      this.last_update = 0;
      this.paused_time = 0;
      this.offset = 0;
      this.paused_state = 0;
  }


  Timer.prototype.start = function () {
      this.update();
      this.num_updates = 0;
      this.start_time = this.system_milliseconds;
      this.last_update = this.start_time;
      this.paused_state = false;
      this.lock_state = false;
      this.lock_rate = 0;
      this.paused_time = 0;
      this.offset = 0;
  }


  Timer.prototype.stop = function () {
      this.end_time = this.system_milliseconds;
  }


  Timer.prototype.reset = function () {
      this.start();
  }


  Timer.prototype.lockFramerate = function (f_rate) {
      this.lock_rate = 1.0 / this.f_rate;
      this.lock_state = true;
  }


  Timer.prototype.unlock = function () {
      var msec_tmp = this.system_milliseconds;
      this.lock_state = false;
      this.update();
      this.last_update = this.system_milliseconds - this.lock_rate;
      this.offset += msec_tmp - this.system_milliseconds;
      this.lock_rate = 0;
  }

  Timer.prototype.locked = function () {
      return this.lock_state;
  }

  Timer.prototype.update = function () {
      this.num_updates++;
      this.last_update = this.system_milliseconds;

      if (this.lock_state) {
          this.system_milliseconds += parseInt(lock_rate * 1000);
      } else {
          this.system_milliseconds = (new Date()).getTime();
      }


      if (this.paused_state) this.paused_time += this.system_milliseconds - this.last_update;

      this.time_elapsed = this.system_milliseconds - this.start_time - this.paused_time + this.offset;
  }


  Timer.prototype.getMilliseconds = function () {
      return this.time_elapsed;
  }



  Timer.prototype.getSeconds = function () {
      return this.getMilliseconds() / 1000.0;
  }


  Timer.prototype.setMilliseconds = function (milliseconds_in) {
      this.offset -= (this.system_milliseconds - this.start_time - this.paused_time + this.offset) - milliseconds_in;
  }



  Timer.prototype.setSeconds = function (seconds_in) {
      this.setMilliseconds(parseInt(seconds_in * 1000.0));
  }


  Timer.prototype.getLastUpdateSeconds = function () {
      return this.getLastUpdateMilliseconds() / 1000.0;
  }


  Timer.prototype.getLastUpdateMilliseconds = function () {
      return this.system_milliseconds - this.last_update;
  }

  Timer.prototype.getTotalMilliseconds = function () {
      return this.system_milliseconds - this.start_time;
  }


  Timer.prototype.getTotalSeconds = function () {
      return this.getTotalMilliseconds() / 1000.0;
  }


  Timer.prototype.getNumUpdates = function () {
      return this.num_updates;
  }


  Timer.prototype.setPaused = function (pause_in) {
      this.paused_state = pause_in;
  }

  Timer.prototype.getPaused = function () {
      return this.paused_state;
  }
  
  
  /* Run-Loop Controller */
   
  function MainLoopRequest()
  {
    var gl = GLCore.gl;

    if (CubicVR.GLCore.mainloop === null) return;
    
    CubicVR.GLCore.mainloop.interval();

    if (window.requestAnimationFrame) {
          window.requestAnimationFrame(MainLoopRequest);
    }
  }

  function setMainLoop(ml)
  {
    CubicVR.GLCore.mainloop=ml;
  }
  
  function MainLoop(mlfunc,doclear)
  {
    if (window.requestAnimationFrame === undef) {      
      window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || null;
    }
    
    if (CubicVR.GLCore.mainloop !== null)
    {
      // kill old mainloop
      
      if (!(window.requestAnimationFrame) && CubicVR.GLCore.mainloop)
      {
        clearInterval(CubicVR.GLCore.mainloop.interval);
      }
      
      CubicVR.GLCore.mainloop = null;
    }
    
    if (mlfunc === null)
    {
      CubicVR.GLCore.mainloop = null;
      return;
    }
    
    var timer = new Timer();
    timer.start();

    this.timer = timer;
    this.func = mlfunc;
    this.doclear = (doclear!==undef)?doclear:true;
    CubicVR.GLCore.mainloop = this;
    
    var loopFunc = function() { return function() { 
      var gl = CubicVR.GLCore.gl;
      timer.update(); 
      if (CubicVR.GLCore.mainloop.doclear) gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      mlfunc(timer,CubicVR.GLCore.gl); 
    }; }();
  
    if (window.requestAnimationFrame) {
          loopFunc();
          this.interval = loopFunc;
          window.requestAnimationFrame(MainLoopRequest);
      } else { 
        this.interval = setInterval(loopFunc, 20);
      }    
  }

  MainLoop.prototype.setPaused = function(state) {
    this.timer.setPaused(state);
  };

  MainLoop.prototype.getPaused = function() {
    return this.timer.getPaused();
  };

  MainLoop.prototype.setTimerSeconds = function(time_in) {
    this.timer.setSeconds(time_in);
  };


  MainLoop.prototype.getTimerSeconds = function() {
    return this.timer.getSeconds();
  };
  

  MainLoop.prototype.resetTimer = function() {
    this.timer.reset();
  };
  
  
  /* Simple Orbital View Controller */
  function MouseViewController(canvas,cam_in)
  {    
    this.canvas = canvas;
    this.camera = cam_in;    
    this.mpos = [0,0]
    this.mdown = false;
        
    var ctx = this;    
                
    this.onMouseDown = function () { return function (ev)
    {
      ctx.mdown = true;
      ctx.mpos = [ev.pageX-ev.target.offsetLeft,ev.pageY-ev.target.offsetTop];
    } }();

    this.onMouseUp = function () { return function (ev)
    {
      ctx.mdown = false;
      ctx.mpos = [ev.pageX-ev.target.offsetLeft,ev.pageY-ev.target.offsetTop];
    }  }();

    this.onMouseMove = function () { return function (ev)
    {
      var mdelta = [];

      var npos = [ev.pageX-ev.target.offsetLeft,ev.pageY-ev.target.offsetTop];

      mdelta[0] = ctx.mpos[0]-npos[0];
      mdelta[1] = ctx.mpos[1]-npos[1];

      ctx.mpos = npos;
//      ctx.mpos = [ev.clientX,ev.clientY];
      if (!ctx.mdown) return;

      var dv = vec3.subtract(ctx.camera.target,ctx.camera.position);
      var dist = vec3.length(dv);

      ctx.camera.position = vec3.moveViewRelative(ctx.camera.position,ctx.camera.target,dist*mdelta[0]/300.0,0);
      ctx.camera.position[1] -= dist*mdelta[1]/300.0;
      
      ctx.camera.position = vec3.add(ctx.camera.target,vec3.multiply(vec3.normalize(vec3.subtract(ctx.camera.position,ctx.camera.target)),dist));
    } }();

    this.onMouseWheel = function() { return function (ev)
    {
      var delta = ev.wheelDelta?ev.wheelDelta:(-ev.detail*10.0);

      var dv = vec3.subtract(ctx.camera.target,ctx.camera.position);
      var dist = vec3.length(dv);

      dist -= delta/1000.0;
      
      if (dist < 0.1) dist = 0.1;
      if (dist > 1000) dist = 1000;
      // if (camDist > 20.0) camDist = 20.0;

      ctx.camera.position = vec3.add(ctx.camera.target,vec3.multiply(vec3.normalize(vec3.subtract(ctx.camera.position,ctx.camera.target)),dist));
    } }();
    
    this.bind();
  }  
  
  MouseViewController.prototype.bind = function() {
    this.canvas.addEventListener('mousemove', this.onMouseMove, false);
    this.canvas.addEventListener('mousedown', this.onMouseDown, false);
    this.canvas.addEventListener('mouseup', this.onMouseUp, false);
    this.canvas.addEventListener('mousewheel', this.onMouseWheel, false);
    this.canvas.addEventListener('DOMMouseScroll', this.onMouseWheel, false);    
  };

  MouseViewController.prototype.unbind = function() {
    this.canvas.removeEventListener('mousemove', this.onMouseMove, false);
    this.canvas.removeEventListener('mousedown', this.onMouseDown, false);
    this.canvas.removeEventListener('mouseup', this.onMouseUp, false);
    this.canvas.removeEventListener('mousewheel', this.onMouseWheel, false);
    this.canvas.removeEventListener('DOMMouseScroll', this.onMouseWheel, false);    
  };

  MouseViewController.prototype.setCamera = function(cam_in) {
    this.camera = cam_in;
  }

  MouseViewController.prototype.getMousePosition = function() {
    return this.mpos;
  }


  /* Transform Controller */

  function Transform(init_mat) {
    return this.clearStack(init_mat);
  }

  Transform.prototype.setIdentity = function() {
    this.m_stack[this.c_stack] = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];
    if (this.valid === this.c_stack && this.c_stack) {
      this.valid--;
    }
    return this;
  };


  Transform.prototype.getIdentity = function() {
    return [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];
  };

  Transform.prototype.invalidate = function() {
    this.valid = 0;
    this.result = null;
    return this;
  };

  
  Transform.prototype.getResult = function() {
    if (!this.c_stack) {
      return this.m_stack[0];
    }
    
    var m = cubicvr_identity;
    
    if (this.valid > this.c_stack-1) this.valid = this.c_stack-1;
                
    for (var i = this.valid; i < this.c_stack+1; i++) {
      m = mat4.multiply(this.m_stack[i],m);
      this.m_cache[i] = m;
    }
      
    this.valid = this.c_stack-1;
      
    this.result = this.m_cache[this.c_stack];
    
    return this.result;
  };
  
  Transform.prototype.pushMatrix = function(m) {
    this.c_stack++;
    this.m_stack[this.c_stack] = (m ? m : cubicvr_identity);
    return this;
  };

  Transform.prototype.popMatrix = function() {
    if (this.c_stack === 0) {
      return;
    }
    this.c_stack--;
    return this;
  };

  Transform.prototype.clearStack = function(init_mat) {
    this.m_stack = [];
    this.m_cache = [];
    this.c_stack = 0;
    this.valid = 0;
    this.result = null;

    if (init_mat !== undef) {
      this.m_stack[0] = init_mat;
    } else {
      this.setIdentity();
    }

    return this;
  };

  Transform.prototype.translate = function(x, y, z) {
    if (typeof(x) === 'object') {
      return this.translate(x[0], x[1], x[2]);
    }

    var m = this.getIdentity();

    m[12] = x;
    m[13] = y;
    m[14] = z;

    this.m_stack[this.c_stack] = mat4.multiply(m,this.m_stack[this.c_stack]);
    if (this.valid === this.c_stack && this.c_stack) {
      this.valid--;
    }

    return this;
  };


  Transform.prototype.scale = function(x, y, z) {
    if (typeof(x) === 'object') {
      return this.scale(x[0], x[1], x[2]);
    }


    var m = this.getIdentity();

    m[0] = x;
    m[5] = y;
    m[10] = z;

    this.m_stack[this.c_stack] = mat4.multiply(m,this.m_stack[this.c_stack]);
    if (this.valid === this.c_stack && this.c_stack) {
      this.valid--;
    }

    return this;
  };


  Transform.prototype.rotate = function(ang, x, y, z) {
    if (typeof(ang) === 'object') {
      this.rotate(ang[0], 1, 0, 0);
      this.rotate(ang[1], 0, 1, 0);
      this.rotate(ang[2], 0, 0, 1);
      return this;
    }

    var sAng, cAng;

    if (x || y || z) {
      sAng = Math.sin(-ang * (M_PI / 180.0));
      cAng = Math.cos(-ang * (M_PI / 180.0));
    }

    if (z) {
      var Z_ROT = this.getIdentity();

      Z_ROT[0] = cAng * z;
      Z_ROT[4] = sAng * z;
      Z_ROT[1] = -sAng * z;
      Z_ROT[5] = cAng * z;

      this.m_stack[this.c_stack] = mat4.multiply(this.m_stack[this.c_stack],Z_ROT);
    }

    if (y) {
      var Y_ROT = this.getIdentity();

      Y_ROT[0] = cAng * y;
      Y_ROT[8] = -sAng * y;
      Y_ROT[2] = sAng * y;
      Y_ROT[10] = cAng * y;

      this.m_stack[this.c_stack] = mat4.multiply(this.m_stack[this.c_stack],Y_ROT);
    }


    if (x) {
      var X_ROT = this.getIdentity();

      X_ROT[5] = cAng * x;
      X_ROT[9] = sAng * x;
      X_ROT[6] = -sAng * x;
      X_ROT[10] = cAng * x;

      this.m_stack[this.c_stack] = mat4.multiply(this.m_stack[this.c_stack],X_ROT);
    }

    if (this.valid === this.c_stack && this.c_stack) {
      this.valid--;
    }

    return this;
  };

  /* Quaternions */

  function Quaternion() {
    if (arguments.length === 1) {
      this.x = arguments[0][0];
      this.y = arguments[0][1];
      this.z = arguments[0][2];
      this.w = arguments[0][3];
    }
    if (arguments.length === 4) {
      this.x = arguments[0];
      this.y = arguments[1];
      this.z = arguments[2];
      this.w = arguments[3];
    }
  }

  Quaternion.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  };

  Quaternion.prototype.normalize = function() {
    var n = Math.sqrt(this.length());
    this.x /= n;
    this.y /= n;
    this.z /= n;
    this.w /= n;
  };

  Quaternion.prototype.fromEuler = function(bank, heading, pitch) // x,y,z
  {
    var c1 = Math.cos((M_PI / 180.0) * heading / 2.0);
    var s1 = Math.sin((M_PI / 180.0) * heading / 2.0);
    var c2 = Math.cos((M_PI / 180.0) * pitch / 2.0);
    var s2 = Math.sin((M_PI / 180.0) * pitch / 2.0);
    var c3 = Math.cos((M_PI / 180.0) * bank / 2.0);
    var s3 = Math.sin((M_PI / 180.0) * bank / 2.0);
    var c1c2 = c1 * c2;
    var s1s2 = s1 * s2;

    this.w = c1c2 * c3 - s1s2 * s3;
    this.x = c1c2 * s3 + s1s2 * c3;
    this.y = s1 * c2 * c3 + c1 * s2 * s3;
    this.z = c1 * s2 * c3 - s1 * c2 * s3;
  };


  Quaternion.prototype.toEuler = function() {
    var sqw = this.w * this.w;
    var sqx = this.x * this.x;
    var sqy = this.y * this.y;
    var sqz = this.z * this.z;

    var x = (180 / M_PI) * ((Math.atan2(2.0 * (this.y * this.z + this.x * this.w), (-sqx - sqy + sqz + sqw))));
    var y = (180 / M_PI) * ((Math.asin(-2.0 * (this.x * this.z - this.y * this.w))));
    var z = (180 / M_PI) * ((Math.atan2(2.0 * (this.x * this.y + this.z * this.w), (sqx - sqy - sqz + sqw))));

    return [x, y, z];
  };

  Quaternion.prototype.multiply = function(q1, q2) {
    var selfSet = false;

    if (q2 === undef) {
      q2 = q1;
      q1 = this;
    }

    var x = q1.x * q2.w + q1.w * q2.x + q1.y * q2.z - q1.z * q2.y;
    var y = q1.y * q2.w + q1.w * q2.y + q1.z * q2.x - q1.x * q2.z;
    var z = q1.z * q2.w + q1.w * q2.z + q1.x * q2.y - q1.y * q2.x;
    var w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;

    if (selfSet) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    } else {
      return new Quaternion(x, y, z, w);
    }
  };


  /* Faces */

  function Face() {
    this.points = [];
    this.point_normals = [];
    this.uvs = [];
    this.normal = [0, 0, 0];
    this.material = 0;
    this.segment = 0;
  }

  Face.prototype.setUV = function(uvs, point_num) {
    if (this.uvs === undef) {
      this.uvs = [];
    }

    if (point_num !== undef) {
      this.uvs[point_num] = uvs;
    } else {
      if (uvs.length !== 2) {
        this.uvs = uvs;
      } else {
        this.uvs.push(uvs);
      }
    }
  };

  Face.prototype.flip = function() {
    for (var i = 0, iMax = this.point_normals.length; i < iMax; i++) {
      this.point_normals[i] = [this.point_normals[i][0], this.point_normals[i][1], this.point_normals[i][2]];
    }

    this.points.reverse();
    this.point_normals.reverse();
    this.uvs.reverse();
    this.normal = [-this.normal[0], -this.normal[1], -this.normal[2]];
  };

  function Mesh(objName) {
    this.points = []; // point list
    this.faces = []; // faces with point references
    this.currentFace = -1; // start with no faces
    this.currentMaterial = 0; // null material
    this.currentSegment = 0; // default segment
    this.compiled = null; // VBO data
    this.bb = null;
    this.name = objName ? objName : null;
    this.hasUV = false;
    this.hasNorm = false;
  }

  Mesh.prototype.showAllSegments = function() {
    for (var i in this.segment_state) {
      if (this.segment_state.hasOwnProperty(i)) {
        this.segment_state[i] = true;
      }
    }
  };

  Mesh.prototype.hideAllSegments = function() {
    for (var i in this.segment_state) {
      if (this.segment_state.hasOwnProperty(i)) {
        this.segment_state[i] = false;
      }
    }
  };

  Mesh.prototype.setSegment = function(i, val) {
    if (val !== undef) {
      this.segment_state[i] = val;
    } else {
      this.currentSegment = i;
    }
  };

  Mesh.prototype.addPoint = function(p) {
    if (p.length !== 3 || typeof(p[0]) === 'object') {
      for (var i = 0, iMax = p.length; i < iMax; i++) {
        this.points.push(p[i]);
      }
    } else {
      this.points.push(p);
    }

    return this.points.length - 1;
  };

  Mesh.prototype.setFaceMaterial = function(mat,facenum) {
    var mat_id = (typeof(mat) === 'object') ? mat.material_id : mat;
    
    if (facenum !== undef) {
      if (this.faces[facenum] !== undef) {
        this.faces[facenum].material = mat_id;
      }
    } else {
      this.currentMaterial = mat_id;
    }
  };

  Mesh.prototype.addFace = function(p_list, face_num, face_mat, face_seg) {
    if (typeof(p_list[0]) !== 'number') {
      for (var i = 0, iMax = p_list.length; i < iMax; i++) {
        if (!p_list.hasOwnProperty(i)) {
          continue;
        }

        this.addFace(p_list[i]);
      }

      return;
    }

    if (face_num === undef) {
      this.currentFace = this.faces.length;
      this.faces.push(new Face());
    } else {
      if (this.faces[face_num] === undef) {
        this.faces[face_num] = new Face();
      }

      this.currentFace = face_num;
    }

    if (typeof(p_list) === 'object') {
      this.faces[this.currentFace].points = p_list;
    }

    if (face_mat !== undef) {
      this.faces[this.currentFace].material = (typeof(face_mat) === 'object') ? face_mat.material_id : face_mat;
    } else {
      this.faces[this.currentFace].material = this.currentMaterial;
    }

    if (face_seg !== undef) {
      this.faces[this.currentFace].segment = face_seg;
    } else {
      this.faces[this.currentFace].segment = this.currentSegment;
    }


    return this.currentFace;
  };


  Mesh.prototype.triangulateQuads = function() {
    for (var i = 0, iMax = this.faces.length; i < iMax; i++) {
      if (this.faces[i].points.length === 4) {
        var p = this.faces.length;

        this.addFace([this.faces[i].points[2], this.faces[i].points[3], this.faces[i].points[0]], this.faces.length, this.faces[i].material, this.faces[i].segment);
        this.faces[i].points.pop();
        this.faces[p].normal = this.faces[i].normal;

        if (this.faces[i].uvs !== undef) {
          if (this.faces[i].uvs.length === 4) {
            this.faces[p].setUV(this.faces[i].uvs[2], 0);
            this.faces[p].setUV(this.faces[i].uvs[3], 1);
            this.faces[p].setUV(this.faces[i].uvs[0], 2);

            this.faces[i].uvs.pop();
          }
        }

        if (this.faces[i].point_normals.length === 4) {
          this.faces[p].point_normals[0] = this.faces[i].point_normals[2];
          this.faces[p].point_normals[1] = this.faces[i].point_normals[3];
          this.faces[p].point_normals[2] = this.faces[i].point_normals[0];

          this.faces[i].point_normals.pop();
        }

      }
    }
    
    return this;
  };


  Mesh.prototype.booleanAdd = function(objAdd, transform) {
    var pofs = this.points.length;
    var fofs = this.faces.length;

    var i, j, iMax, jMax;

    if (transform !== undef) {
      var m = transform.getResult();
      for (i = 0, iMax = objAdd.points.length; i < iMax; i++) {
        this.addPoint(mat4.vec3_multiply(objAdd.points[i], m));
      }
    } else {
      for (i = 0, iMax = objAdd.points.length; i < iMax; i++) {
        this.addPoint([objAdd.points[i][0], objAdd.points[i][1], objAdd.points[i][2]]);
      }
    }

    for (i = 0, iMax = objAdd.faces.length; i < iMax; i++) {
      var newFace = [];

      for (j = 0, jMax = objAdd.faces[i].points.length; j < jMax; j++) {
        newFace.push(objAdd.faces[i].points[j] + pofs);
      }

      var nFaceNum = this.addFace(newFace);
      var nFace = this.faces[nFaceNum];

     nFace.segment = objAdd.faces[i].segment;
     nFace.material = objAdd.faces[i].material;

      for (j = 0, jMax = objAdd.faces[i].uvs.length; j < jMax; j++) {
        nFace.uvs[j] = [objAdd.faces[i].uvs[j][0], objAdd.faces[i].uvs[j][1]];
      }

      for (j = 0, jMax = objAdd.faces[i].point_normals.length; j < jMax; j++) {
        nFace.point_normals[j] = [objAdd.faces[i].point_normals[j][0], objAdd.faces[i].point_normals[j][1], objAdd.faces[i].point_normals[j][2]];
      }
    }
    
    return this;
  };

  Mesh.prototype.calcFaceNormals = function() {
    for (var i = 0, iMax = this.faces.length; i < iMax; i++) {
      if (this.faces[i].points.length < 3) {
        this.faces[i].normal = [0, 0, 0];
        continue;
      }

      this.faces[i].normal = vec3.normalize(triangle.normal(this.points[this.faces[i].points[0]], this.points[this.faces[i].points[1]], this.points[this.faces[i].points[2]]));
    }
    
    return this;
  };


  Mesh.prototype.getMaterial = function(m_name) {
    
    if (this.compiled !== null)
    {
      for (var i in this.compiled.elements) {
        if (this.compiled.elements.hasOwnProperty(i)) {
          if (Materials[i].name === m_name) { 
            return Materials[i];
          }
        }
      }
    }
    else
    {
      var matVisit = [];
      
      for (var j = 0, jMax = this.faces.length;  j < jMax; j++)
      {
        var matId = this.faces[j].material;
        
        if (matVisit.indexOf(matId)===-1)
        {
          if (Materials[matId].name === m_name)
          {
            return Materials[matId];
          }
          matVisit.push(matId);
        }
      }
    }
    

    return null;
  };


  Mesh.prototype.calcNormals = function() {
    this.calcFaceNormals();

    var i, j, k, iMax;

    var point_smoothRef = new Array(this.points.length);
    for (i = 0, iMax = point_smoothRef.length; i < iMax; i++) {
      point_smoothRef[i] = [];
    }

    var numFaces = this.faces.length;

    // build a quick list of point/face sharing
    for (i = 0; i < numFaces; i++) {
      var numFacePoints = this.faces[i].points.length;

      for (j = 0; j < numFacePoints; j++) {
        var idx = this.faces[i].points[j];

        //      if (point_smoothRef[idx] === undef) point_smoothRef[idx] = [];
        point_smoothRef[idx].push([i, j]);
      }
    }


    // step through smoothing references and compute normals
    for (i = 0, iMax = this.points.length; i < iMax; i++) {
      //    if(!point_smoothRef.hasOwnProperty(i)) { continue; }
      //    if (typeof(point_smoothRef[i]) === undef) { continue; }
      var numPts = point_smoothRef[i].length;

      for (j = 0; j < numPts; j++) {
        var ptCount = 1;
        var faceNum = point_smoothRef[i][j][0];
        var pointNum = point_smoothRef[i][j][1];
        var max_smooth = Materials[this.faces[faceNum].material].max_smooth;
        var thisFace = this.faces[faceNum];

        // set point to it's face's normal
        var tmpNorm = new Array(3);

        tmpNorm[0] = thisFace.normal[0];
        tmpNorm[1] = thisFace.normal[1];
        tmpNorm[2] = thisFace.normal[2];

        // step through all other faces which share this point
        if (max_smooth !== 0) {
          for (k = 0; k < numPts; k++) {
            if (j === k) {
              continue;
            }
            var faceRefNum = point_smoothRef[i][k][0];
            var thisFaceRef = this.faces[faceRefNum];

            var ang = vec3.angle(thisFaceRef.normal, thisFace.normal);

            if ((ang !== ang) || ((ang * (180.0 / M_PI)) <= max_smooth)) {
              tmpNorm[0] += thisFaceRef.normal[0];
              tmpNorm[1] += thisFaceRef.normal[1];
              tmpNorm[2] += thisFaceRef.normal[2];

              ptCount++;
            }
          }
        }

        tmpNorm[0] /= ptCount;
        tmpNorm[1] /= ptCount;
        tmpNorm[2] /= ptCount;

        this.faces[faceNum].point_normals[pointNum] = vec3.normalize(tmpNorm);
      }
    }
    
    return this;
  };
  
  
  Mesh.prototype.clean = function() {
    var i,iMax;
    
    
    for (i = 0, iMax=this.points.length; i < iMax; i++)
    {
      delete(this.points[i]);
      this.points[i]=null;
    }
    this.points = [];
    
    for (i = 0, iMax=this.faces.length; i < iMax; i++)
    {
      delete(this.faces[i].points);
      delete(this.faces[i].point_normals);
      delete(this.faces[i].uvs);
      delete(this.faces[i].normal);
      delete(this.faces[i]);      
      this.faces[i]=null;
    }
    this.faces = [];

    
    return this;
  }

  Mesh.prototype.compile = function() {
    this.compiled = {};

    this.bb = [];

    var compileRef = [];

    var i, j, k, x, y, iMax, kMax, yMax;

    for (i = 0, iMax = this.faces.length; i < iMax; i++) {
      if (this.faces[i].points.length === 3) {
        var matId = this.faces[i].material;
        var segId = this.faces[i].segment;

        if (compileRef[matId] === undef) {
          compileRef[matId] = [];
        }
        if (compileRef[matId][segId] === undef) {
          compileRef[matId][segId] = [];
        }

        compileRef[matId][segId].push(i);
      }
    }

    var vtxRef = [];

    this.compiled.vbo_normals = [];
    this.compiled.vbo_points = [];
    this.compiled.vbo_uvs = [];

    var idxCount = 0;
    var hasUV = false;
    var hasNorm = false;
    var faceNum;

    for (i in compileRef) {
      if (compileRef.hasOwnProperty(i)) {
        for (j in compileRef[i]) {
          if (compileRef[i].hasOwnProperty(j)) {
            for (k = 0; k < compileRef[i][j].length; k++) {
              faceNum = compileRef[i][j][k];
              hasUV = hasUV || (this.faces[faceNum].uvs.length !== 0);
              hasNorm = hasNorm || (this.faces[faceNum].point_normals.length !== 0);
            }
          }
        }
      }
    }

    if (hasUV) {
      for (i = 0; i < this.faces.length; i++) {
        if (!this.faces[i].uvs.length) {
          for (j = 0; j < this.faces[i].points.length; j++) {
            this.faces[i].uvs.push([0, 0]);
          }
        }
      }
    }

    if (hasNorm) {
      for (i = 0; i < this.faces.length; i++) {
        if (!this.faces[i].point_normals.length) {
          for (j = 0; j < this.faces[i].points.length; j++) {
            this.faces[i].point_normals.push([0, 0, 0]);
          }
        }
      }
    }

    this.hasUV = hasUV;
    this.hasNorm = hasNorm;

    var pVisitor = [];

    for (i in compileRef) {
      if (compileRef.hasOwnProperty(i)) {
        for (j in compileRef[i]) {
          if (compileRef[i].hasOwnProperty(j)) {
            for (k = 0, kMax = compileRef[i][j].length; k < kMax; k++) {
              faceNum = compileRef[i][j][k];
              var found = false;

              for (x = 0; x < 3; x++) {
                var ptNum = this.faces[faceNum].points[x];

                var foundPt = -1;

                if (vtxRef[ptNum] !== undef) {
                  for (y = 0, yMax = vtxRef[ptNum].length; y < yMax; y++) {
                    // face / point
                    var oFace = vtxRef[ptNum][y][0]; // faceNum
                    var oPoint = vtxRef[ptNum][y][1]; // pointNum
                    var oIndex = vtxRef[ptNum][y][2]; // index
                    foundPt = oIndex;

                    if (hasNorm) {
                      foundPt = (vec3.equal(
                      this.faces[oFace].point_normals[oPoint], this.faces[faceNum].point_normals[x])) ? foundPt : -1;
                    }

                    if (hasUV) {
                      foundPt = (vec2.equal(
                      this.faces[oFace].uvs[oPoint], this.faces[faceNum].uvs[x])) ? foundPt : -1;
                    }
                  }
                }

                if (foundPt !== -1) {
                  if (this.compiled.elements === undef) {
                    this.compiled.elements = [];
                  }
                  if (this.compiled.elements[i] === undef) {
                    this.compiled.elements[i] = [];
                  }
                  if (this.compiled.elements[i][j] === undef) {
                    this.compiled.elements[i][j] = [];
                  }
                  this.compiled.elements[i][j].push(foundPt);
                } else {
                  this.compiled.vbo_points.push(this.points[ptNum][0]);
                  this.compiled.vbo_points.push(this.points[ptNum][1]);
                  this.compiled.vbo_points.push(this.points[ptNum][2]);

                  if (this.bb.length === 0) {
                    this.bb[0] = [this.points[ptNum][0],
                                                          this.points[ptNum][1],
                                                          this.points[ptNum][2]];

                    this.bb[1] = [this.points[ptNum][0],
                                                          this.points[ptNum][1],
                                                          this.points[ptNum][2]];
                  } else {
                    if (this.points[ptNum][0] < this.bb[0][0]) {
                      this.bb[0][0] = this.points[ptNum][0];
                    }
                    if (this.points[ptNum][1] < this.bb[0][1]) {
                      this.bb[0][1] = this.points[ptNum][1];
                    }
                    if (this.points[ptNum][2] < this.bb[0][2]) {
                      this.bb[0][2] = this.points[ptNum][2];
                    }

                    if (this.points[ptNum][0] > this.bb[1][0]) {
                      this.bb[1][0] = this.points[ptNum][0];
                    }
                    if (this.points[ptNum][1] > this.bb[1][1]) {
                      this.bb[1][1] = this.points[ptNum][1];
                    }
                    if (this.points[ptNum][2] > this.bb[1][2]) {
                      this.bb[1][2] = this.points[ptNum][2];
                    }
                  }

                  if (hasNorm) {
                    this.compiled.vbo_normals.push(this.faces[faceNum].point_normals[x][0]);
                    this.compiled.vbo_normals.push(this.faces[faceNum].point_normals[x][1]);
                    this.compiled.vbo_normals.push(this.faces[faceNum].point_normals[x][2]);
                  }

                  if (hasUV) {
                    this.compiled.vbo_uvs.push(this.faces[faceNum].uvs[x][0]);
                    this.compiled.vbo_uvs.push(this.faces[faceNum].uvs[x][1]);
                  }

                  if (this.compiled.elements === undef) {
                    this.compiled.elements = [];
                  }
                  if (this.compiled.elements[i] === undef) {
                    this.compiled.elements[i] = [];
                  }
                  if (this.compiled.elements[i][j] === undef) {
                    this.compiled.elements[i][j] = [];
                  }

                  this.compiled.elements[i][j].push(idxCount);

                  if (vtxRef[ptNum] === undef) {
                    vtxRef[ptNum] = [];
                  }

                  vtxRef[ptNum].push([faceNum, x, idxCount]);
                  idxCount++;
                }
              }
            }
          }
        }
      }
    }

    this.compiled.gl_points = GLCore.gl.createBuffer();
    GLCore.gl.bindBuffer(GLCore.gl.ARRAY_BUFFER, this.compiled.gl_points);
    GLCore.gl.bufferData(GLCore.gl.ARRAY_BUFFER, new Float32Array(this.compiled.vbo_points), GLCore.gl.STATIC_DRAW);

    if (hasNorm) {
      this.compiled.gl_normals = GLCore.gl.createBuffer();
      GLCore.gl.bindBuffer(GLCore.gl.ARRAY_BUFFER, this.compiled.gl_normals);
      GLCore.gl.bufferData(GLCore.gl.ARRAY_BUFFER, new Float32Array(this.compiled.vbo_normals), GLCore.gl.STATIC_DRAW);
    }
    else
    {
      this.compiled.gl_normals = null;
    }

    if (hasUV) {
      this.compiled.gl_uvs = GLCore.gl.createBuffer();
      GLCore.gl.bindBuffer(GLCore.gl.ARRAY_BUFFER, this.compiled.gl_uvs);
      GLCore.gl.bufferData(GLCore.gl.ARRAY_BUFFER, new Float32Array(this.compiled.vbo_uvs), GLCore.gl.STATIC_DRAW);
    }
    else
    {
      this.compiled.gl_uvs = null;
    }

    var gl_elements = [];

    this.segment_state = [];
    this.compiled.elements_ref = [];

    var ictr = 0;

    for (i in this.compiled.elements) {
      if (this.compiled.elements.hasOwnProperty(i)) {
        this.compiled.elements_ref[ictr] = [];

        var jctr = 0;

        for (j in this.compiled.elements[i]) {
          if (this.compiled.elements[i].hasOwnProperty(j)) {
            for (k in this.compiled.elements[i][j]) {
              if (this.compiled.elements[i][j].hasOwnProperty(k)) {
                gl_elements.push(this.compiled.elements[i][j][k]);
              }
            }

            this.segment_state[j] = true;

            this.compiled.elements_ref[ictr][jctr] = [parseInt(i), parseInt(j), parseInt(this.compiled.elements[i][j].length)];

            jctr++;
          }
        }
        ictr++;
      }
    }

    this.compiled.gl_elements = GLCore.gl.createBuffer();
    GLCore.gl.bindBuffer(GLCore.gl.ELEMENT_ARRAY_BUFFER, this.compiled.gl_elements);
    GLCore.gl.bufferData(GLCore.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(gl_elements), GLCore.gl.STATIC_DRAW);

    // dump temporary buffers
    this.compiled.vbo_normals = null;
    this.compiled.vbo_points = null;
    this.compiled.vbo_uvs = null;
    this.compiled.elements = null;

    GLCore.gl.bindBuffer(GLCore.gl.ELEMENT_ARRAY_BUFFER, null);
    
    return this;
  };



  function UVMapper(obj_in) {
    if (obj_in!==undef) {
      this.rotation = (obj_in.rotation===undef)?[0, 0, 0]:obj_in.rotation;
      this.scale = (obj_in.scale===undef)?[1, 1, 1]:obj_in.scale;
      this.center = (obj_in.center===undef)?[0, 0, 0]:obj_in.center;
      this.projection_mode = (obj_in.projectionMode===undef)?enums.uv.projection.PLANAR:obj_in.projectionMode;
      this.projection_axis = (obj_in.projectionAxis===undef)?enums.uv.axis.X:obj_in.projectionAxis;
      this.wrap_w_count = (obj_in.wrapW===undef)?1:obj_in.wrapW;
      this.wrap_h_count = (obj_in.wrapH===undef)?1:obj_in.wrapH;
    } else {
      this.rotation = [0, 0, 0];
      this.scale = [1, 1, 1];
      this.center = [0, 0, 0];
      this.projection_mode = enums.uv.projection.PLANAR;
      this.projection_axis = enums.uv.axis.X;
      this.wrap_w_count = 1;
      this.wrap_h_count = 1;
    }
  }
  
  
  UVMapper.prototype.setRotation = function(rotation) {
    this.rotation = rotation;
  }
  
  UVMapper.prototype.setScale = function(scale) {
    this.scale = scale;
  }
  
  UVMapper.prototype.setCenter = function(center) {
    this.center = center;
  }
  
  UVMapper.prototype.setProjectionAxis = function(projection_axis) {
    this.projection_axis = projection_axis;
  }
  
  UVMapper.prototype.setProjectionMode = function(projection_mode) {
    this.projection_mode = projection_mode;
  }
  
  UVMapper.prototype.setWrapW = function(wrap_w) {
    this.wrap_w_count = wrap_w;
  }

  UVMapper.prototype.setWrapH = function(wrap_h) {
    this.wrap_h_count = wrap_h;
  }


  // convert XYZ space to longitude
  var xyz_to_h = function(x, y, z) {
    var h;

    if (x === 0 && z === 0) {
      h = 0;
    } else {
      if (z === 0) {
        h = (x < 0) ? M_HALF_PI : -M_HALF_PI;
      } else if (z < 0) {
        h = -Math.atan(x / z) + M_PI;
      } else {
        h = -Math.atan(x / z);
      }
    }

    return h;
  };


  // convert XYZ space to latitude and longitude
  var xyz_to_hp = function(x, y, z) {
    var h, p;

    if (x === 0 && z === 0) {
      h = 0;

      if (y !== 0) {
        p = (y < 0) ? -M_HALF_PI : M_HALF_PI;
      } else {
        p = 0;
      }
    } else {
      if (z === 0) {
        h = (x < 0) ? M_HALF_PI : -M_HALF_PI;
      } else if (z < 0) {
        h = -Math.atan(x / z) + M_PI;
      } else {
        h = -Math.atan(x / z);
      }

      x = Math.sqrt(x * x + z * z);

      if (x === 0) {
        p = (y < 0) ? -M_HALF_PI : M_HALF_PI;
      } else {
        p = Math.atan(y / x);
      }
    }

    return [h, p];
  };


  UVMapper.prototype.apply = function(obj, mat_num, seg_num) {
    var u, v, s, t, lat, lon;

    var trans = new Transform();
    var transformed = false;
    var t_result = null;

    if (this.center[0] || this.center[1] || this.center[2]) {
      trans.translate(-this.center[0], -this.center[1], -this.center[2]);
      transformed = true;
    }

    if (this.rotation[0] || this.rotation[1] || this.rotation[2]) {
      if (this.rotation[0]) {
        trans.rotate(this.rotation[2], 0, 0, 1);
      }
      if (this.rotation[1]) {
        trans.rotate(this.rotation[1], 0, 1, 0);
      }
      if (this.rotation[2]) {
        trans.rotate(this.rotation[0], 1, 0, 0);
      }
      transformed = true;
    }

    if (transformed) {
      t_result = trans.getResult();
    }

    if (typeof(mat_num) === 'object') {
      mat_num = mat_num.material_id;
    }

    for (var i = 0, iMax = obj.faces.length; i < iMax; i++) {
      if (obj.faces[i].material !== mat_num) {
        continue;
      }
      if (seg_num !== undef) {
        if (obj.faces[i].segment !== seg_num) {
          continue;
        }
      }

      var nx, ny, nz;

      if (this.projection_mode === enums.uv.projection.CUBIC || this.projection_mode === enums.uv.projection.SKY) {
        nx = Math.abs(obj.faces[i].normal[0]);
        ny = Math.abs(obj.faces[i].normal[1]);
        nz = Math.abs(obj.faces[i].normal[2]);
      }

      for (var j = 0, jMax = obj.faces[i].points.length; j < jMax; j++) {
        var uvpoint = obj.points[obj.faces[i].points[j]];

        if (transformed) {
          uvpoint = mat4.vec3_multiply(uvpoint, t_result);
        }

        /* calculate the uv for the points referenced by this face's pointref vector */
        var p_mode = this.projection_mode;
        //switch (this.projection_mode) {
        if (p_mode === enums.uv.projection.SKY) {
        //case enums.uv.projection.SKY:
          var mapping = obj.sky_mapping;
          /* see enums.uv.projection.CUBIC for normalization reasoning */
          if (nx >= ny && nx >= nz) {
            s = uvpoint[2] / (this.scale[2]) + this.scale[2] / 2;
            t = -uvpoint[1] / (this.scale[1]) + this.scale[1] / 2;
            if (obj.faces[i].normal[0] < 0) {
              //left
              s = (mapping[2][2] - mapping[2][0]) * (1-s);
              t = 1-((mapping[2][3] - mapping[2][1]) * (t));
              s += mapping[2][0];
              t += mapping[2][1];
            }
            else {
              //right
              s = (mapping[3][2] - mapping[3][0]) * (s);
              t = 1-((mapping[3][3] - mapping[3][1]) * (t));
              s += mapping[3][0];
              t += mapping[3][1];
            } //if
          } //if
          if (ny >= nx && ny >= nz) {
            s = uvpoint[0] / (this.scale[0]) + this.scale[0] / 2;
            t = -uvpoint[2] / (this.scale[2]) + this.scale[2] / 2;
            if (obj.faces[i].normal[1] < 0) {
              //down
              s = ((mapping[1][2] - mapping[1][0]) * (s));
              t = 1-((mapping[1][3] - mapping[1][1]) * (t));
              s += mapping[1][0];
              t -= mapping[1][1];
            }
            else {
              //up
              s = ((mapping[0][2] - mapping[0][0]) * (s));
              t = 1-((mapping[0][3] - mapping[0][1]) * (t));
              s += mapping[0][0];
              t -= mapping[0][1];
            } //if
          } //if
          if (nz >= nx && nz >= ny) {
            s = uvpoint[0] / (this.scale[0]) + this.scale[0] / 2;
            t = uvpoint[1] / (this.scale[1]) + this.scale[1] / 2;
            if (obj.faces[i].normal[2] < 0) {
              //front
              s = ((mapping[4][2] - mapping[4][0]) * (s));
              t = 1-((mapping[4][3] - mapping[4][1]) * (1-t));
              s += mapping[4][0];
              t -= mapping[4][1];
            }
            else {
              //back
              s = ((mapping[5][2] - mapping[5][0]) * (1-s));
              t = 1-((mapping[5][3] - mapping[5][1]) * (1-t));
              s += mapping[5][0];
              t += mapping[5][1];
            } //if
          } //if
          obj.faces[i].setUV([s, t], j);
          //break;
        }
        else if (p_mode === enums.uv.projection.CUBIC) {
        //case enums.uv.projection.CUBIC:
          /* cubic projection needs to know the surface normal */
          /* x portion of vector is dominant, we're mapping in the Y/Z plane */
          if (nx >= ny && nx >= nz) {
            /* we use a .5 offset because texture coordinates range from 0->1, so to center it we need to offset by .5 */
            s = uvpoint[2] / this.scale[2] + 0.5;
            /* account for scale here */
            t = uvpoint[1] / this.scale[1] + 0.5;
          }

          /* y portion of vector is dominant, we're mapping in the X/Z plane */
          if (ny >= nx && ny >= nz) {

            s = -uvpoint[0] / this.scale[0] + 0.5;
            t = uvpoint[2] / this.scale[2] + 0.5;
          }

          /* z portion of vector is dominant, we're mapping in the X/Y plane */
          if (nz >= nx && nz >= ny) {
            s = -uvpoint[0] / this.scale[0] + 0.5;
            t = uvpoint[1] / this.scale[1] + 0.5;
          }

          if (obj.faces[i].normal[0] > 0) {
            s = -s;
          }
          if (obj.faces[i].normal[1] < 0) {
            s = -s;
          }
          if (obj.faces[i].normal[2] > 0) {
            s = -s;
          }

          obj.faces[i].setUV([s, t], j);
          //break;
        }
        else if (p_mode === enums.uv.projection.PLANAR) {
        //case enums.uv.projection.PLANAR:
          s = ((this.projection_axis === enums.uv.axis.X) ? uvpoint[2] / this.scale[2] + 0.5 : -uvpoint[0] / this.scale[0] + 0.5);
          t = ((this.projection_axis === enums.uv.axis.Y) ? uvpoint[2] / this.scale[2] + 0.5 : uvpoint[1] / this.scale[1] + 0.5);

          obj.faces[i].setUV([s, t], j);
          //break;
        }
        else if (p_mode === enums.uv.projection.CYLINDRICAL) {
        //case enums.uv.projection.CYLINDRICAL:
          // Cylindrical is a little more tricky, we map based on the degree around the center point
          var p_axis = this.projection_axis;
          //switch (this.projection_axis) {
          if (p_axis === enums.uv.axis.X) {
          //case enums.uv.axis.X:
            // xyz_to_h takes the point and returns a value representing the 'unwrapped' height position of this point
            lon = xyz_to_h(uvpoint[2], uvpoint[0], -uvpoint[1]);
            t = -uvpoint[0] / this.scale[0] + 0.5;
            //break;
          }
          else if (p_axis === enums.uv.axis.Y) {
          //case enums.uv.axis.Y:
            lon = xyz_to_h(-uvpoint[0], uvpoint[1], uvpoint[2]);
            t = -uvpoint[1] / this.scale[1] + 0.5;
            //break;
          }
          else if (p_axis === enums.uv.axis.Z) {
          //case enums.uv.axis.Z:
            lon = xyz_to_h(-uvpoint[0], uvpoint[2], -uvpoint[1]);
            t = -uvpoint[2] / this.scale[2] + 0.5;
            //break;
          } //if

          // convert it from radian space to texture space 0 to 1 * wrap, TWO_PI = 360 degrees
          lon = 1.0 - lon / (M_TWO_PI);

          if (this.wrap_w_count !== 1.0) {
            lon = lon * this.wrap_w_count;
          }

          u = lon;
          v = t;

          obj.faces[i].setUV([u, v], j);
          //break;
        }
        else if (p_mode === enums.uv.projection.SPHERICAL) {
        //case enums.uv.projection.SPHERICAL:
          var latlon;

          // spherical is similar to cylindrical except we also unwrap the 'width'
          var p_axis = this.projection_axis;
          //switch (this.projection_axis) {
          if (p_axis === enums.uv.axis.X) {
          //case enums.uv.axis.X:
            // xyz to hp takes the point value and 'unwraps' the latitude and longitude that projects to that point
            latlon = xyz_to_hp(uvpoint[2], uvpoint[0], -uvpoint[1]);
            //break;
          }
          else if (p_axis === enums.uv.axis.Y) {
          //case enums.uv.axis.Y:
            latlon = xyz_to_hp(uvpoint[0], -uvpoint[1], uvpoint[2]);
            //break;
          }
          else if (p_axis === enums.uv.axis.Z) {
          //case enums.uv.axis.Z:
            latlon = xyz_to_hp(-uvpoint[0], uvpoint[2], -uvpoint[1]);
            //break;
          } //if

          // convert longitude and latitude to texture space coordinates, multiply by wrap height and width
          lon = 1.0 - latlon[0] / M_TWO_PI;
          lat = 0.5 - latlon[1] / M_PI;

          if (this.wrap_w_count !== 1.0) {
            lon = lon * this.wrap_w_count;
          }
          if (this.wrap_h_count !== 1.0) {
            lat = lat * this.wrap_h_count;
          }

          u = lon;
          v = lat;

          obj.faces[i].setUV([u, v], j);
          //break;
        }
        else {

          // case enums.uv.projection.UV:
          //   // not handled here..
          // break;
        //default:
          // else mapping cannot be handled here, this shouldn't have happened :P
          u = 0;
          v = 0;
          obj.faces[i].setUV([u, v], j);
          //break;
        } //if
      } //for
    } //for - faces
    
    return this;
  };

  function AABB_size(aabb) {
    var x = aabb[0][0] < aabb[1][0] ? aabb[1][0] - aabb[0][0] : aabb[0][0] - aabb[1][0];
    var y = aabb[0][1] < aabb[1][1] ? aabb[1][1] - aabb[0][1] : aabb[0][1] - aabb[1][1];
    var z = aabb[0][2] < aabb[1][2] ? aabb[1][2] - aabb[0][2] : aabb[0][2] - aabb[1][2];
    return [x,y,z];
  } //AABB_size
  function AABB_reset(aabb, point) {
    if (point === undefined) {
      point = [0,0,0];
    } //if
    aabb[0][0] = point[0];
    aabb[0][1] = point[1];
    aabb[0][2] = point[2];
    aabb[1][0] = point[0];
    aabb[1][1] = point[1];
    aabb[1][2] = point[2];
  } //AABB_reset
  function AABB_engulf(aabb, point) {
    if (aabb[0][0] > point[0]) {
      aabb[0][0] = point[0];
    }
    if (aabb[0][1] > point[1]) {
      aabb[0][1] = point[1];
    }
    if (aabb[0][2] > point[2]) {
      aabb[0][2] = point[2];
    }
    if (aabb[1][0] < point[0]) {
      aabb[1][0] = point[0];
    }
    if (aabb[1][1] < point[1]) {
      aabb[1][1] = point[1];
    }
    if (aabb[1][2] < point[2]) {
      aabb[1][2] = point[2];
    }
  } //AABB::engulf


/* Lights */

function Light(light_type, lighting_method) {
  if (light_type === undef) {
    light_type = enums.light.type.POINT;
  }
  if (lighting_method === undef) {
    lighting_method = enums.light.method.DYNAMIC;
  }

  if (typeof(light_type)=='object') {
    this.light_type = (light_type.type!==undef)?light_type.type:enums.light.type.POINT;
    this.diffuse = (light_type.diffuse!==undef)?light_type.diffuse:[1, 1, 1];
    this.specular = (light_type.specular!==undef)?light_type.specular:[1.0,1.0,1.0];
    this.intensity = (light_type.intensity!==undef)?light_type.intensity:1.0;
    this.position = (light_type.position!==undef)?light_type.position:[0, 0, 0];
    this.direction = (light_type.direction!==undef)?light_type.direction:[0, 0, 0];
    this.distance = (light_type.distance!==undef)?light_type.distance:10;
    this.cutoff = (light_type.cutoff!==undef)?light_type.cutoff:60;
    this.map_res = (light_type.map_res!==undef)?light_type.map_res:512;
    this.method = (light_type.method!==undef)?light_type.method:lighting_method;
  } else {
    this.light_type = light_type;
    this.diffuse = [1, 1, 1];
    this.specular = [1.0,1.0,1.0];
    this.intensity = 1.0;
    this.position = [0, 0, 0];
    this.direction = [0, 0, 0];
    this.distance = 10;
    this.cutoff = 60;
    this.map_res = 512;
    this.method = lighting_method;
  }
  
  this.trans = new Transform();
  this.lposition = [0, 0, 0];
  this.tMatrix = this.trans.getResult();
  this.dirty = true;
  this.octree_leaves = [];
  this.octree_common_root = null;
  this.octree_aabb = [[0, 0, 0], [0, 0, 0]];
  this.ignore_octree = false;
  this.visible = true;
  this.culled = true;
  this.was_culled = true;
  this.aabb = [[0,0,0],[0,0,0]];
  AABB_reset(this.aabb, this.position);
  this.adjust_octree = SceneObject.prototype.adjust_octree;
  this.motion = null;
  
  if (this.light_type === enums.light.type.SPOT_SHADOW) {
    this.setShadow(this.map_res);
  }
}

Light.prototype.setType = function(light_type) {
  this.light_type = type;
}

Light.prototype.setMethod = function(method) {
  this.method = method;
}

Light.prototype.setDiffuse = function(diffuse) {
  this.diffuse = diffuse;
}
Light.prototype.setSpecular = function(specular) {
  this.specular = specular;
}
Light.prototype.setIntensity = function(intensity) {
  this.intensity = intensity;
}
Light.prototype.setPosition = function(position) {
  this.position = position;
}
Light.prototype.setDistance = function(distance) {
  this.distance = distance;
}
Light.prototype.setCutoff = function(cutoff_angle) {
  this.cutoff = cutoff_angle;
}


Light.prototype.control = function(controllerId, motionId, value) {
  if (controllerId === enums.motion.POS) {
    this.position[motionId] = value;
    } else if (controllerId === enums.motion.INTENSITY) {
      this.intensity = value;
     }
  
   // else if (controllerId === enums.motion.ROT) {
   //    this.rotation[motionId] = value;
   //  }
}

Light.prototype.doTransform = function(mat) {
  if (!vec3.equal(this.lposition, this.position) || (mat !== undef)) {
    this.trans.clearStack();
    this.trans.translate(this.position);
    if ((mat !== undef)) {
      this.trans.pushMatrix(mat);
    }
    this.tMatrix = this.trans.getResult();
    this.lposition[0] = this.position[0];
    this.lposition[1] = this.position[1];
    this.lposition[2] = this.position[2];
    this.dirty = true;
    this.adjust_octree();
  } //if
} //Light::doTransform

Light.prototype.getAABB = function() {
  var aabb = [[0, 0, 0], [0, 0, 0]];
  AABB_engulf(aabb, [this.distance, this.distance, this.distance]);
  AABB_engulf(aabb, [-this.distance, -this.distance, -this.distance]);
  aabb[0] = vec3.add(aabb[0], this.position);
  aabb[1] = vec3.add(aabb[1], this.position);
  this.aabb = aabb;
  return this.aabb;
};

Light.prototype.setDirection = function(x, y, z) {
  if (typeof(x) === 'object') {
    this.setDirection(x[0], x[1], x[2]);
    return;
  }


  this.direction = vec3.normalize([x, y, z]);
    
    return this;
};

Light.prototype.lookat = function(x, y, z) {
  if (typeof(x) === 'object') {
    this.lookat(x[0], x[1], x[2]);
    return;
  }

  this.direction = vec3.normalize(vec3.subtract([x, y, z],this.position));
    
  return this;
};



Light.prototype.setRotation = function(x, y, z) {
  if (typeof(x) === 'object') {
    this.setRotation(x[0], x[1], x[2]);
    return;
  }

  var t = new Transform();
  t.rotate([-x, -y, -z]);
  t.pushMatrix();

  this.direction = vec3.normalize(mat4.vec3_multiply([1, 0, 0], t.getResult()));
    
    return this;
};


Light.prototype.setupShader = function(lShader,lNum) {
    var gl = GLCore.gl;
    
    var lUniforms = lShader.lights[lNum];
    
    gl.uniform3fv(lUniforms.lDiff, this.diffuse);
    gl.uniform3fv(lUniforms.lSpec, this.specular);
    gl.uniform3fv(lUniforms.lPos, this.position);
    gl.uniform3fv(lUniforms.lDir, this.direction);

    gl.uniform1f(lUniforms.lInt, this.intensity);
    gl.uniform1f(lUniforms.lDist, this.distance);
    
    if ((this.light_type === enums.light.type.SPOT_SHADOW)||(this.light_type === enums.light.type.SPOT)) {
      gl.uniform1f(lUniforms.lCut, this.cutoff);
    }
    if (this.light_type === enums.light.type.SPOT_SHADOW) {
      this.shadowMapTex.texture.use(GLCore.gl.TEXTURE0+lNum);  // reserved in material for shadow map
      gl.uniform1i(lShader.lDepthTex[lNum], lNum);
      gl.uniform3fv(lShader.lDepth[lNum], [this.dummyCam.nearclip,this.dummyCam.farclip,1.0/this.map_res]);
      gl.uniformMatrix4fv(lShader.spMatrix[lNum], false, this.spMatrix);
    }
};

Light.prototype.setShadow = function(map_res_in)  // cone_tex
{
  this.map_res = map_res_in;
  this.shadowMapTex = new RenderBuffer(this.map_res, this.map_res, false);
  this.shadowMapTex.texture.setFilter(enums.texture.filter.NEAREST);
  
  this.dummyCam = new Camera(this.map_res,this.map_res,0.1,this.distance);
  this.dummyCam.calc_nmatrix = false; // don't need a normal matrix, save some cycles and determinant issues
  this.dummyCam.setTargeted(true);
  // if(!(strncmp(cone_tex.c_str(),"null",4) == 0 || strncmp(cone_tex.c_str(),"Null",4) == 0 || strncmp(cone_tex.c_str(),"NULL",4) == 0))
  // {
  //  coneTex = Texture::create(cone_tex);
  //  has_projector = true;
  // }

  this.has_shadow = true;
};


Light.prototype.hasShadow = function()
{
  return has_shadow;
};


Light.prototype.shadowBegin = function()
{
  var gl = GLCore.gl;  

  this.shadowMapTex.use();

  gl.viewport(0, 0, this.map_res, this.map_res);
    
  gl.clear(gl.DEPTH_BUFFER_BIT|gl.COLOR_BUFFER_BIT);

  this.dummyCam.setClip(0.1,this.distance);
  this.dummyCam.setFOV(this.cutoff);

  this.dummyCam.lookat(this.position[0], this.position[1], this.position[2], this.position[0]+this.direction[0]*10.0, this.position[1]+this.direction[1]*10.0, this.position[2]+this.direction[2]*10.0, 0, 1, 0);
  
  gl.cullFace(gl.FRONT);  
};


Light.prototype.shadowEnd = function()
{
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  
  gl.cullFace(gl.BACK);
  
  this.setupTexGen();
};


Light.prototype.setupTexGen = function()
{
  var biasMatrix = [0.5, 0.0, 0.0, 0.0,
                    0.0, 0.5, 0.0, 0.0,
                    0.0, 0.0, 0.5, 0.0,
                    0.5, 0.5, 0.5, 1.0];

  this.spMatrix = mat4.multiply(biasMatrix,cubicvr_identity);
  this.spMatrix = mat4.multiply(this.dummyCam.pMatrix,this.spMatrix);
  this.spMatrix = mat4.multiply(this.dummyCam.mvMatrix,this.spMatrix);
};



var emptyLight = new Light(enums.light.type.POINT);
emptyLight.diffuse = [0, 0, 0];
emptyLight.specular = [0, 0, 0];
emptyLight.distance = 0;
emptyLight.intensity = 0;
emptyLight.cutoff = 0;

/* Shaders */

function Shader(vs_id, fs_id) {
  var vertexShader;
  var fragmentShader;
  var loadedShader;

  this.uniforms = [];
  this.uniform_type = [];
  this.uniform_typelist = [];

  if (vs_id.indexOf("\n") !== -1) {
    vertexShader = cubicvr_compileShader(GLCore.gl, vs_id, "x-shader/x-vertex");
  } else {
    vertexShader = cubicvr_getShader(GLCore.gl, vs_id);

    if (vertexShader === null) {
      loadedShader = util.getURL(vs_id);

      vertexShader = cubicvr_compileShader(GLCore.gl, loadedShader, "x-shader/x-vertex");
    }
  }

  if (fs_id.indexOf("\n") !== -1) {
    fragmentShader = cubicvr_compileShader(GLCore.gl, fs_id, "x-shader/x-fragment");
  } else {
    fragmentShader = cubicvr_getShader(GLCore.gl, fs_id);

    if (fragmentShader === null) {
      loadedShader = util.getURL(fs_id);

      fragmentShader = cubicvr_compileShader(GLCore.gl, loadedShader, "x-shader/x-fragment");
    }

  }


  this.shader = GLCore.gl.createProgram();
  GLCore.gl.attachShader(this.shader, vertexShader);
  GLCore.gl.attachShader(this.shader, fragmentShader);
  GLCore.gl.linkProgram(this.shader);

  if (!GLCore.gl.getProgramParameter(this.shader, GLCore.gl.LINK_STATUS)) {
//    alert("Could not initialise shader vert(" + vs_id + "), frag(" + fs_id + ")");
      throw new Error("Could not initialise shader vert(" + vs_id + "), frag(" + fs_id + ")");
    return;
  }
}


Shader.prototype.bindSelf = function(uniform_id) {  
  var t,k,p,v;
  
  if (uniform_id.indexOf(".")!==-1) {
    if (uniform_id.indexOf("[")!==-1) {
      t = uniform_id.split("[");
      p = t[0];
      t = t[1].split("]");
      k = t[0];
      t = t[1].split(".");
      v = t[1];
      
      if (this[p] === undef) {
        this[p] = [];
      }
      if (this[p][k] === undef) {
        this[p][k] = {};
      }
      
      this[p][k][v] = this.uniforms[uniform_id];

    } else {  // untested
      t = uniform_id.split(".");
      p = t[0];
      v = t[1];

      if (this[p] === undef) {
        this[p] = {};
      }
      
      this[p][v] = this.uniforms[uniform_id];
      
    }
  } else if ( uniform_id.indexOf("[") !== -1){  // untested
    t = uniform_id.split("[");
    p = t[0];
    t = t[1].split("]");
    k = t[0];
    
    if (this[p] === undef) {
      this[p] = [];
    }
    
    this[p][k] = this.uniforms[uniform_id];
  }
  else {
    this[uniform_id] = this.uniforms[uniform_id];
  }
}

Shader.prototype.addMatrix = function(uniform_id, default_val) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getUniformLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.MATRIX;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  if (default_val !== undef) {
    this.setMatrix(uniform_id, default_val);
  }

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addVector = function(uniform_id, default_val) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getUniformLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.VECTOR;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  if (default_val !== undef) {
    this.setVector(uniform_id, default_val);
  }

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addFloat = function(uniform_id, default_val) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getUniformLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.FLOAT;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  if (default_val !== undef) {
    this.setFloat(uniform_id, default_val);
  }

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};


Shader.prototype.addVertexArray = function(uniform_id) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getAttribLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.ARRAY_VERTEX;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addUVArray = function(uniform_id) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getAttribLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.ARRAY_UV;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addFloatArray = function(uniform_id) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getAttribLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.ARRAY_FLOAT;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.addInt = function(uniform_id, default_val) {
  this.use();
  this.uniforms[uniform_id] = GLCore.gl.getUniformLocation(this.shader, uniform_id);
  this.uniform_type[uniform_id] = enums.shader.uniform.INT;
  this.uniform_typelist.push([this.uniforms[uniform_id], this.uniform_type[uniform_id]]);

  if (default_val !== undef) {
    this.setInt(uniform_id, default_val);
  }

  this.bindSelf(uniform_id);
  return this.uniforms[uniform_id];
};

Shader.prototype.use = function() {
  GLCore.gl.useProgram(this.shader);
};

Shader.prototype.setMatrix = function(uniform_id, mat) {
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  var l = mat.length;
  
  if (l===16) {
    GLCore.gl.uniformMatrix4fv(u, false, mat);  
  } else if (l === 9) {
    GLCore.gl.uniformMatrix3fv(u, false, mat);  
  } else if (l === 4) {
    GLCore.gl.uniformMatrix2fv(u, false, mat);  
  }
};

Shader.prototype.setInt = function(uniform_id, val) {
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  GLCore.gl.uniform1i(u, val);
};

Shader.prototype.setFloat = function(uniform_id, val) {
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  GLCore.gl.uniform1f(u, val);
};

Shader.prototype.setVector = function(uniform_id, val) {
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  var l = val.length;
  
  if (l==3) {
    GLCore.gl.uniform3fv(u, val);    
  } else if (l==2) {
    GLCore.gl.uniform2fv(u, val);    
  } else {
    GLCore.gl.uniform4fv(u, val);
  }
};


Shader.prototype.clearArray = function(uniform_id) {
  var gl = GLCore.gl;  
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
    
  gl.disableVertexAttribArray(u);
};

Shader.prototype.bindArray = function(uniform_id, buf) {
  var gl = GLCore.gl;  
  var u = this.uniforms[uniform_id];
  if (u === null) {
    return;
  }
  
  var t = this.uniform_type[uniform_id];
    
  if (t === enums.shader.uniform.ARRAY_VERTEX) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.vertexAttribPointer(u, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(u);
  } else if (t === enums.shader.uniform.ARRAY_UV) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.vertexAttribPointer(u, 2, gl.FLOAT, false, 0, 0);
  } else if (t === enums.shader.uniform.ARRAY_FLOAT) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.vertexAttribPointer(u, 1, gl.FLOAT, false, 0, 0);
  }
};


/* Materials */

var Material = function(mat_name) {
  this.material_id = -1;

  /*
  if (mat_name !== undef) {
    var old_mat = Material_ref[mat_name];
    if (old_mat) {
      var old_id = old_mat.material_id;
      Materials[old_id] = this;
      old_mat = null;
    } //if
    Material_ref[mat_name] = this;
  }
  */

  //if (this.material_id === -1) {
    this.material_id = Materials.length;
    Materials.push(this);
  //} //if

  this.initialized = false;
  this.textures = [];
  this.shader = [];
  this.customShader = null;

  if (typeof(mat_name)==='object') {
    this.diffuse = (mat_name.diffuse===undef)?[1.0, 1.0, 1.0]:mat_name.diffuse;
    this.specular = (mat_name.specular===undef)?[0.1, 0.1, 0.1]:mat_name.specular;
    this.color = (mat_name.color===undef)?[1, 1, 1]:mat_name.color;
    this.ambient = (mat_name.ambient===undef)?[0, 0, 0]:mat_name.ambient;
    this.opacity = (mat_name.opacity===undef)?1.0:mat_name.opacity;
    this.shininess = (mat_name.shininess===undef)?1.0:mat_name.shininess;
    this.max_smooth = (mat_name.max_smooth===undef)?60.0:mat_name.max_smooth;
    this.env_amount = (mat_name.env_amount===undef)?0.75:mat_name.env_amount;
    this.name = (mat_name.name===undef)?undef:mat_name.name;

    if (typeof(mat_name.textures)==='object') {
      if (mat_name.textures.color!==undef) this.setTexture(mat_name.textures.color,enums.texture.map.COLOR);
      if (mat_name.textures.envsphere!==undef) this.setTexture(mat_name.textures.envsphere,enums.texture.map.ENVSPHERE);
      if (mat_name.textures.normal!==undef) this.setTexture(mat_name.textures.normal,enums.texture.map.NORMAL);
      if (mat_name.textures.bump!==undef) this.setTexture(mat_name.textures.bump,enums.texture.map.BUMP);
      if (mat_name.textures.reflect!==undef) this.setTexture(mat_name.textures.reflect,enums.texture.map.REFLECT);
      if (mat_name.textures.specular!==undef) this.setTexture(mat_name.textures.specular,enums.texture.map.SPECULAR);
      if (mat_name.textures.ambient!==undef) this.setTexture(mat_name.textures.ambient,enums.texture.map.AMBIENT);
      if (mat_name.textures.alpha!==undef) this.setTexture(mat_name.textures.alpha,enums.texture.map.ALPHA);
    }
  } else {
    this.diffuse = [1.0, 1.0, 1.0];
    this.specular = [0.1, 0.1, 0.1];
    this.color = [1, 1, 1];
    this.ambient = [0, 0, 0];
    this.opacity = 1.0;
    this.shininess = 1.0;
    this.max_smooth = 60.0;
    this.name = mat_name;
  }

};

Material.prototype.setTexture = function(tex, tex_type) {
  if (tex_type === undef) {
    tex_type = 0;
  }
  this.textures[tex_type] = tex;
};



Material.prototype.calcShaderMask = function() {
  var shader_mask = 0;

  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.COLOR]) === 'object') ? enums.shader.map.COLOR : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.SPECULAR]) === 'object') ? enums.shader.map.SPECULAR : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.NORMAL]) === 'object') ? enums.shader.map.NORMAL : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.BUMP]) === 'object') ? enums.shader.map.BUMP : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.REFLECT]) === 'object') ? enums.shader.map.REFLECT : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.ENVSPHERE]) === 'object') ? enums.shader.map.ENVSPHERE : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.AMBIENT]) === 'object') ? enums.shader.map.AMBIENT : 0);
  shader_mask = shader_mask + ((typeof(this.textures[enums.texture.map.ALPHA]) === 'object') ? enums.shader.map.ALPHA : 0);
  shader_mask = shader_mask + ((this.opacity !== 1.0) ? enums.shader.map.ALPHA : 0);

  return shader_mask;
};


Material.prototype.getShaderHeader = function(light_type,light_count) {
  return ((light_count !== undef) ? ("#define loopCount "+light_count+"\n"):"") +
  "#define hasColorMap " + ((typeof(this.textures[enums.texture.map.COLOR]) === 'object') ? 1 : 0) + 
  "\n#define hasSpecularMap " + ((typeof(this.textures[enums.texture.map.SPECULAR]) === 'object') ? 1 : 0) + 
  "\n#define hasNormalMap " + ((typeof(this.textures[enums.texture.map.NORMAL]) === 'object') ? 1 : 0) + 
  "\n#define hasBumpMap " + ((typeof(this.textures[enums.texture.map.BUMP]) === 'object') ? 1 : 0) + 
  "\n#define hasReflectMap " + ((typeof(this.textures[enums.texture.map.REFLECT]) === 'object') ? 1 : 0) + 
  "\n#define hasEnvSphereMap " + ((typeof(this.textures[enums.texture.map.ENVSPHERE]) === 'object') ? 1 : 0) + 
  "\n#define hasAmbientMap " + ((typeof(this.textures[enums.texture.map.AMBIENT]) === 'object') ? 1 : 0) + 
  "\n#define hasAlphaMap " + ((typeof(this.textures[enums.texture.map.ALPHA]) === 'object') ? 1 : 0) + 
  "\n#define hasAlpha " + ((this.opacity !== 1.0) ? 1 : 0) + 
  "\n#define lightPoint " + ((light_type === enums.light.type.POINT) ? 1 : 0) + 
  "\n#define lightDirectional " + ((light_type === enums.light.type.DIRECTIONAL) ? 1 : 0) + 
  "\n#define lightSpot " + (((light_type === enums.light.type.SPOT)||(light_type === enums.light.type.SPOT_SHADOW)) ? 1 : 0) + 
  "\n#define hasShadow " + (((light_type === enums.light.type.SPOT_SHADOW)) ? 1 : 0) + 
  "\n#define softShadow " + (GLCore.soft_shadow?1:0) +
  "\n#define lightArea " + ((light_type === enums.light.type.AREA) ? 1 : 0) + 
  "\n#define depthPack " + ((light_type === enums.light.type.DEPTH_PACK) ? 1 : 0) + 
  "\n#define alphaDepth " + (GLCore.depth_alpha ? 1 : 0) + 
  "\n\n";
};


Material.prototype.bindObject = function(obj_in, light_shader) {
  var gl = GLCore.gl;
  
  var u = light_shader;
  var up = u.aVertexPosition;
  var uv = u.aTextureCoord; 
  var un = u.aNormal; 

  gl.bindBuffer(gl.ARRAY_BUFFER, obj_in.compiled.gl_points);
  gl.vertexAttribPointer(up, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(up);

  if (obj_in.compiled.gl_uvs!==null && uv !==-1) {
    gl.bindBuffer(gl.ARRAY_BUFFER, obj_in.compiled.gl_uvs);
    gl.vertexAttribPointer(uv, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(uv);
  } 

  if (obj_in.compiled.gl_normals!==null && un !==-1) {
    gl.bindBuffer(gl.ARRAY_BUFFER, obj_in.compiled.gl_normals);
    gl.vertexAttribPointer(un, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(un);
  }

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj_in.compiled.gl_elements);
};

Material.prototype.clearObject = function(obj_in,light_shader) {
  var gl = GLCore.gl;

  var u = light_shader;
  var uv = u.aTextureCoord; 
  var un = u.aNormal; 
  
  if (obj_in.compiled.gl_uvs!==null && uv !==-1) {
      gl.disableVertexAttribArray(uv);
  }

  if (obj_in.compiled.gl_normals!==null && un !==-1) {
      gl.disableVertexAttribArray(un);    
  }

}


Material.prototype.use = function(light_type,num_lights) {
  if (num_lights === undef) {
    num_lights = 0;
  }
  
  if (this.customShader !== null) {
    this.customShader.use();
    return;
  }

  if (light_type === undef) {
    light_type = 0;
  }

  var m;
  var thistex = this.textures;
  
  if (this.shader[light_type] === undef) {
     this.shader[light_type] = [];
  }

  if (this.shader[light_type][num_lights] === undef) {
    
    var smask = this.calcShaderMask(light_type);
    
    if (ShaderPool[light_type][smask] === undef) {
      ShaderPool[light_type][smask] = [];
    }
    
    if (ShaderPool[light_type][smask][num_lights] === undef) {
      var hdr = this.getShaderHeader(light_type,num_lights);
      var vs = hdr + GLCore.CoreShader_vs;
      var fs = hdr + GLCore.CoreShader_fs;

      var l = new Shader(vs, fs);
      
      ShaderPool[light_type][smask][num_lights] = l;
      
      m = 0;

      if (light_type !== enums.light.type.DEPTH_PACK) {
        if (light_type === enums.light.type.SPOT_SHADOW) {
          m+=num_lights;  // leave room for shadow map..
        }
        
        if (typeof(thistex[enums.texture.map.COLOR]) === 'object') {
          l.addInt("colorMap", m++);
        }
        if (typeof(thistex[enums.texture.map.ENVSPHERE]) === 'object') {
          l.addInt("envSphereMap", m++);
        }
        if (typeof(thistex[enums.texture.map.NORMAL]) === 'object') {
          l.addInt("normalMap", m++);
        }
        if (typeof(thistex[enums.texture.map.BUMP]) === 'object') {
          l.addInt("bumpMap", m++);
        }
        if (typeof(thistex[enums.texture.map.REFLECT]) === 'object') {
          l.addInt("reflectMap", m++);
        }
        if (typeof(thistex[enums.texture.map.SPECULAR]) === 'object') {
          l.addInt("specularMap", m++);
        }
        if (typeof(thistex[enums.texture.map.AMBIENT]) === 'object') {
          l.addInt("ambientMap", m++);
        }
      }

      if (typeof(thistex[enums.texture.map.ALPHA]) === 'object') {
        l.addInt("alphaMap", m++);
      }

      l.addMatrix("uMVMatrix");
      l.addMatrix("uPMatrix");
      l.addMatrix("uOMatrix");
      l.addMatrix("uNMatrix");

      l.addVertexArray("aVertexPosition");
      l.addVertexArray("aNormal");

      for (var mLight = 0; mLight < num_lights; mLight++) {
        l.addVector("lights["+mLight+"].lDiff");
        l.addVector("lights["+mLight+"].lSpec");
        l.addFloat("lights["+mLight+"].lInt");
        l.addFloat("lights["+mLight+"].lDist");
        l.addVector("lights["+mLight+"].lPos");
        l.addVector("lights["+mLight+"].lDir");
        if ((light_type === enums.light.type.SPOT_SHADOW)||(light_type === enums.light.type.SPOT)) {
          l.addFloat("lights["+mLight+"].lCut");
        }
        if (light_type === enums.light.type.SPOT_SHADOW) {
          l.addInt("lDepthTex["+mLight+"]");
          l.addVector("lDepth["+mLight+"]");
          l.addMatrix("spMatrix["+mLight+"]");
        }
      }

      if (light_type !== enums.light.type.DEPTH_PACK) {  // not needed for depth packing stage

        l.addVector("lAmb");
        l.addVector("mDiff");
        l.addVector("mColor");
        l.addVector("mAmb");
        l.addVector("mSpec");
        l.addFloat("mShine");
        l.addFloat("envAmount");
        
      } // !DEPTH_PACK

      l.addFloat("mAlpha");      
      
      if (GLCore.depth_alpha || (light_type === enums.light.type.DEPTH_PACK) || (light_type === enums.light.type.SPOT_SHADOW)) {
        l.addVector("depthInfo");
      }

      l.addUVArray("aTextureCoord");
    }
    
    this.shader[light_type][num_lights] = ShaderPool[light_type][smask][num_lights];
  }

  var sh = this.shader[light_type][num_lights];
  var gl = GLCore.gl

  sh.use();

  m = 0;
  var t;
  
  if (light_type !== enums.light.type.DEPTH_PACK) {
  
    if (light_type === enums.light.type.SPOT_SHADOW) {
      m+=num_lights;  // leave room for shadow map..
    }

    if (t = thistex[enums.texture.map.COLOR]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.ENVSPHERE]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
      // sh.setFloat("envAmount", this.env_amount);
      gl.uniform1f(sh.envAmount,this.env_amount);
    }
    if (t = thistex[enums.texture.map.NORMAL]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.BUMP]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.REFLECT]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.SPECULAR]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
    if (t = thistex[enums.texture.map.AMBIENT]) {
      t.use(GLCore.gl.TEXTURE0+m); m++;
    }
  }

  if (t = thistex[enums.texture.map.ALPHA]) {
    t.use(GLCore.gl.TEXTURE0+m); m++;
  }

  // sh.setVector("mColor", this.color);
  // sh.setVector("mDiff", this.diffuse);
  // sh.setVector("mAmb", this.ambient);
  // sh.setVector("mSpec", this.specular);
  // sh.setFloat("mShine", this.shininess);
  // sh.setVector("lAmb", CubicVR.globalAmbient);

  if (light_type !== enums.light.type.DEPTH_PACK) {  
    gl.uniform3fv(sh.mColor,this.color);
    gl.uniform3fv(sh.mDiff,this.diffuse);
    gl.uniform3fv(sh.mAmb,this.ambient);
    gl.uniform3fv(sh.mSpec,this.specular);
    gl.uniform1f(sh.mShine,this.shininess*128.0);
    gl.uniform3fv(sh.lAmb, CubicVR.globalAmbient);
  

    if (GLCore.depth_alpha || (light_type === enums.light.type.SPOT_SHADOW)) {
      //sh.setVector("depthInfo", [GLCore.depth_alpha_near, GLCore.depth_alpha_far, 0.0]);
      gl.uniform3fv(sh.depthInfo, [GLCore.depth_alpha_near, GLCore.depth_alpha_far, 0.0]);
    }
  }
  else {
    gl.uniform3fv(sh.depthInfo, [GLCore.shadow_near, GLCore.shadow_far, 0.0]);
  }
  
  if (this.opacity !== 1.0) {
    gl.uniform1f(sh.mAlpha, this.opacity);
  }
};

/* Textures */
var DeferredLoadTexture = function(img_path, filter_type) {
  this.img_path = img_path;
  this.filter_type = filter_type;
} //DefferedLoadTexture

DeferredLoadTexture.prototype.getTexture = function(deferred_bin, binId) {
  return new Texture(this.img_path, this.filter_type, deferred_bin, binId);
} //getTexture

var Texture = function(img_path,filter_type,deferred_bin,binId,ready_func) {
  var gl = GLCore.gl;

  this.tex_id = Textures.length;
  this.filterType = -1;
  this.onready = ready_func;
  this.loaded = false;
  Textures[this.tex_id] = gl.createTexture();
  Textures_obj[this.tex_id] = this;

  if (img_path) {
    Images[this.tex_id] = new Image();
    Texture_ref[img_path] = this.tex_id;
  }

  gl.bindTexture(gl.TEXTURE_2D, Textures[this.tex_id]);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  if (img_path) {
    var texId = this.tex_id;
    var filterType = (filter_type!==undef)?filter_type:GLCore.default_filter;
    
    var that = this;

    Images[this.tex_id].onload = function() {
      gl.bindTexture(gl.TEXTURE_2D, Textures[texId]);

      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);

      var img = Images[texId];

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

      var tw = img.width, th = img.height;
      
      var isPOT = true;
      
      if (tw===1||th===1) {
        isPOT = false;
      } else {
        if (tw!==1) { while ((tw % 2) === 0) { tw /= 2; } }
        if (th!==1) { while ((th % 2) === 0) { th /= 2; } }
        if (tw>1) { isPOT = false; }
        if (th>1) { isPOT = false; }        
      }

      if (!isPOT) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      }

      if (Textures_obj[texId].filterType===-1) {
        if (!isPOT) {
          if (filterType === enums.texture.filter.LINEAR_MIP) {
            filterType = enums.texture.filter.LINEAR;
          }
        }

        if (Textures_obj[texId].filterType===-1) {
          Textures_obj[texId].setFilter(filterType);      
        }
      }  
      else
      {
        Textures_obj[texId].setFilter(Textures_obj[texId].filterType);
      }        

      gl.bindTexture(gl.TEXTURE_2D, null);

      if (that.onready) {
        that.onready();
      } //if
      that.loaded = true;
    };

    if (!deferred_bin)
    {
    Images[this.tex_id].src = img_path;
  }
    else
    {
      Images[this.tex_id].deferredSrc = img_path;
      //console.log('adding image to binId=' + binId + ' img_path=' + img_path);
      deferred_bin.addImage(binId,img_path,Images[this.tex_id]);
    }
  }

  this.active_unit = -1;
};


Texture.prototype.setFilter = function(filterType) {
  var gl = CubicVR.GLCore.gl;

  gl.bindTexture(gl.TEXTURE_2D, Textures[this.tex_id]);
  /*
  switch (filterType)
  {
    case enums.texture.filter.LINEAR:
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    break;
    case enums.texture.filter.LINEAR_MIP:
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);      
    break;
    case enums.texture.filter.NEAREST:    
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);  
    break;
  }
  */

  if (filterType === enums.texture.filter.LINEAR) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  } else if (filterType === enums.texture.filter.LINEAR_MIP) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);      
  } else if (filterType === enums.texture.filter.NEAREST) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);  
  } else if (filterType === enums.texture.filter.NEAREST_MIP) {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
      gl.generateMipmap(gl.TEXTURE_2D);      
  }

  this.filterType = filterType;
};

Texture.prototype.use = function(tex_unit) {
  GLCore.gl.activeTexture(tex_unit);
  GLCore.gl.bindTexture(GLCore.gl.TEXTURE_2D, Textures[this.tex_id]);
  this.active_unit = tex_unit;
};

Texture.prototype.clear = function() {
  if (this.active_unit !== -1) {
    GLCore.gl.activeTexture(this.active_unit);
    GLCore.gl.bindTexture(GLCore.gl.TEXTURE_2D, null);
    this.active_unit = -1;
  }
};

function CanvasTexture(options) {
  var gl = CubicVR.GLCore.gl;

  if ( options.nodeName === 'CANVAS' || options.nodeName === 'IMG' ) {
    this.canvasSource = options;
  }
  else {
    this.canvasSource = document.createElement('CANVAS');
    if (options.width === undefined || options.height === undefined) {
      throw new Error('Width and height must be specified for generating a new CanvasTexture.');
    } //if
    this.canvasSource.width = options.width;
    this.canvasSource.height = options.height;
    this.canvasContext = this.canvasSource.getContext('2d');
  } //if

  var c = this.canvasSource, tw = c.width, th = c.height;
  
  var isPOT = true;
  
  if (tw===1||th===1) {
    isPOT = false;
  } else {
    if (tw !== 1) { while ((tw % 2) === 0) { tw /= 2; } }
    if (th !== 1) { while ((th % 2) === 0) { th /= 2; } }
    if (tw > 1) { isPOT = false; }
    if (th > 1) { isPOT = false; }       
  }

  this.updateFunction = options.update;

  this.texture = new CubicVR.Texture();

  this.setFilter=this.texture.setFilter;
  this.clear=this.texture.clear;
  this.use=this.texture.use;
  this.tex_id=this.texture.tex_id;
  this.filterType=this.texture.filterType;

  if (!isPOT) {
    this.setFilter(enums.texture.filter.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);    
  } else {
    this.setFilter(enums.texture.filter.LINEAR_MIP);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);    
  }

  if ( options.nodeName === 'IMG' ) {
    this.update();
  } //if

}; //CanvasTexture

CanvasTexture.prototype.update = function() {
  if (this.updateFunction) {
    this.updateFunction(this.canvasSource, this.canvasContext);
  } //if

  var gl = CubicVR.GLCore.gl;
  gl.bindTexture(gl.TEXTURE_2D, CubicVR.Textures[this.texture.tex_id]);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvasSource);
  if (this.filterType === enums.texture.filter.LINEAR_MIP) {
    gl.generateMipmap(gl.TEXTURE_2D);          
  }
  gl.bindTexture(gl.TEXTURE_2D, null);
}; //CanvasTexture.update

function TextTexture(text, options) {
  var color = (options && options.color) || '#fff';
  var bgcolor = (options && options.bgcolor);
  var font = (options && options.font) || '18pt Arial';
  var align = (options && options.align) || 'start';
  var y = (options && options.y) || 0;
  var width = (options && options.width) || undef;
  var height = (options && options.height) || undef;
  
  var canvas = document.createElement('CANVAS');
  var ctx = canvas.getContext('2d');

  var lines = 0;
  if (typeof(text) === 'string') {
    lines = 1;
  }
  else {
    lines = text.length;
  } //if

  ctx.font = font;

  // This approximation is awful. There has to be a better way to find the height of a text block
  var lineHeight = (options && options.lineHeight) || ctx.measureText('OO').width;
  var widest;
  if (lines === 1) {
    widest = ctx.measureText(text).width;
  }
  else {
    widest = 0;
    for (var i=0; i<lines; ++i) {
      var w = ctx.measureText(text[i]).width;
      if (w > widest) {
        widest = w;
      } //if
    } //for
  } //if

  canvas.width = width || widest;
  canvas.height = height || lineHeight * lines;

  if (bgcolor) {
    ctx.fillStyle = bgcolor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } //if
  ctx.fillStyle = color;
  ctx.font = font;
  ctx.textAlign = align;
  ctx.textBaseline = 'top';
  if (lines === 1) {
    var x = (options && options.x) || align === 'center' ? canvas.width/2 : align === 'right' ? canvas.width : 0;
    ctx.fillText(text, x, y);
  }
  else {
    for (var i=0; i<lines; ++i) {
      var x = (options && options.x) || align === 'center' ? canvas.width/2 : align === 'right' ? canvas.width : 0;
      ctx.fillText(text[i], x, y+i*lineHeight);
    } //for
  } //if
  ctx.fill();

  this.use = CanvasTexture.prototype.use;
  this.clear = CanvasTexture.prototype.clear;
  this.update = CanvasTexture.prototype.update;
  CanvasTexture.apply(this, [canvas]);

  this.update();
  this.canvasSource = canvas = ctx = null;
}; //TextTexture

function PJSTexture(pjsURL, width, height) {
  var gl = CubicVR.GLCore.gl;
  this.texture = new CubicVR.Texture();
  this.canvas = document.createElement("CANVAS");
  this.canvas.width = width;
  this.canvas.height = height;
  
  // this assumes processing is already included..
  this.pjs = new Processing(this.canvas,CubicVR.util.getURL(pjsURL));
  this.pjs.noLoop();
  this.pjs.redraw();
  
  var tw = this.canvas.width, th = this.canvas.height;
  
  var isPOT = true;
  
  if (tw===1||th===1) {
    isPOT = false;
  } else {
    if (tw !== 1) { while ((tw % 2) === 0) { tw /= 2; } }
    if (th !== 1) { while ((th % 2) === 0) { th /= 2; } }
    if (tw > 1) { isPOT = false; }
    if (th > 1) { isPOT = false; }       
  }
  
  // bind functions to "subclass" a texture
  this.setFilter=this.texture.setFilter;
  this.clear=this.texture.clear;
  this.use=this.texture.use;
  this.tex_id=this.texture.tex_id;
  this.filterType=this.texture.filterType;


  if (!isPOT) {
    this.setFilter(enums.texture.filter.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);    
  } else {
    this.setFilter(enums.texture.filter.LINEAR_MIP);
  }
}

PJSTexture.prototype.update = function() {
  var gl = CubicVR.GLCore.gl;

  this.pjs.redraw();
 
  gl.bindTexture(gl.TEXTURE_2D, CubicVR.Textures[this.texture.tex_id]);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);
  
  if (this.filterType === enums.texture.filter.LINEAR_MIP) {
    gl.generateMipmap(gl.TEXTURE_2D);          
  }
  
  gl.bindTexture(gl.TEXTURE_2D, null); 
};


/* Render functions */


function cubicvr_renderObject(obj_in,camera,o_matrix,lighting) {

  if (obj_in.compiled===null) {
    return;
  }
  
  var ofs = 0;
  var gl = CubicVR.GLCore.gl;
  var numLights = (lighting === undef) ? 0: lighting.length;
  var mshader, last_ltype, l;
  var lcount = 0;
  var j;
  var mat = null;
//  var nullAmbient = [0,0,0];
//  var tmpAmbient = CubicVR.globalAmbient;
  
  var bound = false;
  
  gl.depthFunc(gl.LEQUAL);
  
  if (o_matrix === undef) { o_matrix = cubicvr_identity; }
  
  for (var ic = 0, icLen = obj_in.compiled.elements_ref.length; ic < icLen; ic++) {
    var i = obj_in.compiled.elements_ref[ic][0][0];

    mat = Materials[i];
        
    var len = 0;
    var drawn = false;
    
    if (mat.opacity !== 1.0) {
      gl.enable(gl.BLEND);
      gl.depthMask(0);
      gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
    } else {
      gl.depthMask(1);
      gl.disable(gl.BLEND);
      gl.blendFunc(gl.ONE,gl.ONE);
    }
    
    for (var jc = 0, jcLen = obj_in.compiled.elements_ref[ic].length; jc < jcLen; jc++) {
      j = obj_in.compiled.elements_ref[ic][jc][1];
      
      drawn = false;
      
      var this_len = obj_in.compiled.elements_ref[ic][jc][2];
      
      len += this_len;
      
      if (obj_in.segment_state[j]) {
        // ...
      } else if (len > this_len) {
        ofs += this_len*2;
        len -= this_len;
  
        // start lighting loop
         // start inner
        if (!numLights) {
         mat.use(0,0);

         gl.uniformMatrix4fv(mat.shader[0][0].uMVMatrix,false,camera.mvMatrix);
         gl.uniformMatrix4fv(mat.shader[0][0].uPMatrix,false,camera.pMatrix);
         gl.uniformMatrix4fv(mat.shader[0][0].uOMatrix,false,o_matrix);
         gl.uniformMatrix3fv(mat.shader[0][0].uNMatrix,false,camera.nMatrix);

         if (!bound) { mat.bindObject(obj_in,mat.shader[0][0]); bound = true; }

          gl.drawElements(gl.TRIANGLES, len, gl.UNSIGNED_SHORT, ofs);

        } else { 
          var subcount = 0;
          var blended = false;

          for (subcount = 0; subcount < numLights; )
          {
            nLights = numLights-subcount;
            if (nLights>MAX_LIGHTS) { 
              nLights=MAX_LIGHTS;
            }

            if (subcount>0 && !blended) {
              gl.enable(gl.BLEND);
              gl.blendFunc(gl.ONE,gl.ONE);
              gl.depthFunc(gl.EQUAL);
              blended = true;
            }

            mshader = undef;
            l = lighting[subcount];
            var lt = l.light_type

            for (lcount = 0; lcount < nLights; lcount++) {
              if (lighting[lcount+subcount].light_type!=lt) {
                nLights = lcount;
               break;
              }
            }

            mat.use(l.light_type,nLights);

            mshader = mat.shader[l.light_type][nLights];

            gl.uniformMatrix4fv(mshader.uMVMatrix,false,camera.mvMatrix);
            gl.uniformMatrix4fv(mshader.uPMatrix,false,camera.pMatrix);
            gl.uniformMatrix4fv(mshader.uOMatrix,false,o_matrix);
            gl.uniformMatrix3fv(mshader.uNMatrix,false,camera.nMatrix);

            if (!bound) { mat.bindObject(obj_in,mshader); bound = true; }

            for (lcount = 0; lcount < nLights; lcount++) {
              lighting[lcount+subcount].setupShader(mshader,lcount);
            }

            gl.drawElements(gl.TRIANGLES, len, gl.UNSIGNED_SHORT, ofs);
            // var err = gl.getError();
            // if (err) {
            //   var uv = mshader.uniforms["aTextureCoord"]; 
            //   var un = mshader.uniforms["aNormal"];
            //   console.log(obj_in.compiled.gl_uvs!==null,obj_in.compiled.gl_normals!==null, un, uv, len, ofs, subcount);
            //   
            //   throw new Error('webgl error on mesh: ' + obj_in.name);
            // }

            subcount += nLights;
          }

          if (blended)
          {
            gl.disable(gl.BLEND);
            gl.depthFunc(gl.LEQUAL);
          }
        }

        /// end inner
        
        
        ofs += len*2;  // Note: unsigned short = 2 bytes
        len = 0;      
        drawn = true;
      } else {
        ofs += len*2;
        len = 0;
      }
    }

    if (!drawn && obj_in.segment_state[j]) {
      // this is an exact copy/paste of above
      // start lighting loop
       // start inner
      if (!numLights) {
       mat.use(0,0);

       gl.uniformMatrix4fv(mat.shader[0][0].uMVMatrix,false,camera.mvMatrix);
       gl.uniformMatrix4fv(mat.shader[0][0].uPMatrix,false,camera.pMatrix);
       gl.uniformMatrix4fv(mat.shader[0][0].uOMatrix,false,o_matrix);
       gl.uniformMatrix3fv(mat.shader[0][0].uNMatrix,false,camera.nMatrix);

       if (!bound) { mat.bindObject(obj_in,mat.shader[0][0]); bound = true; }

        gl.drawElements(gl.TRIANGLES, len, gl.UNSIGNED_SHORT, ofs);

      } else { 
        var subcount = 0;
        var blended = false;

        for (subcount = 0; subcount < numLights; )
        {
          nLights = numLights-subcount;
          if (nLights>MAX_LIGHTS) { 
            nLights=MAX_LIGHTS;
          }

          if (subcount>0 && !blended) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE,gl.ONE);
            gl.depthFunc(gl.EQUAL);
            blended = true;
          }

          mshader = undef;
          l = lighting[subcount];
          var lt = l.light_type

          for (lcount = 0; lcount < nLights; lcount++) {
            if (lighting[lcount+subcount].light_type!=lt) {
              nLights = lcount;
             break;
            }
          }

          mat.use(l.light_type,nLights);

          mshader = mat.shader[l.light_type][nLights];

          gl.uniformMatrix4fv(mshader.uMVMatrix,false,camera.mvMatrix);
          gl.uniformMatrix4fv(mshader.uPMatrix,false,camera.pMatrix);
          gl.uniformMatrix4fv(mshader.uOMatrix,false,o_matrix);
          gl.uniformMatrix3fv(mshader.uNMatrix,false,camera.nMatrix);

          if (!bound) { mat.bindObject(obj_in,mshader); bound = true; }

          for (lcount = 0; lcount < nLights; lcount++) {
            lighting[lcount+subcount].setupShader(mshader,lcount);
          }

          gl.drawElements(gl.TRIANGLES, len, gl.UNSIGNED_SHORT, ofs);
          // var err = gl.getError();
          // if (err) {
          //   var uv = mshader.uniforms["aTextureCoord"]; 
          //   var un = mshader.uniforms["aNormal"];
          //   console.log(obj_in.compiled.gl_uvs!==null,obj_in.compiled.gl_normals!==null, un, uv, len, ofs, subcount);
          //   
          //   throw new Error('webgl error on mesh: ' + obj_in.name);
          // }

          subcount += nLights;
        }

        if (blended)
        {
          gl.disable(gl.BLEND);
          gl.depthFunc(gl.LEQUAL);
        }
      }

      /// end inner
      
      ofs += len*2;
    }
  }
  
  if (mat && mshader) {
    mat.clearObject(obj_in,mshader);
  }
  
  // gl.disableVertexAttribArray(0);
  // gl.disableVertexAttribArray(2);
  // gl.disableVertexAttribArray(3);
  
  gl.depthMask(1);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
}


/* Procedural Objects */

function cubicvr_latheObject(obj_in, pointList, lathe_divisions, material, transform, uvmapper) {
  var slices = [];
  var sliceNum;

  var up = [0, 1, 0];
  var right = [1, 0, 0];
  var pos = [0, 0, 0];
  var pofs = obj_in.points.length;

  var i, j, jMax, k, kMax;

  sliceNum = 0;

  for (i = 0; i < M_TWO_PI; i += (M_TWO_PI / lathe_divisions)) {
    if (sliceNum === lathe_divisions) {
      break;
    }

    right = [Math.cos(i), 0, Math.sin(i)];

    for (j = 0, jMax = pointList.length; j < jMax; j++) {
      pos = vec3.add(vec3.multiply(right, pointList[j][0]), vec3.multiply(up, pointList[j][1]));

      if (slices[sliceNum] === undef) {
        slices[sliceNum] = [];
      }

      slices[sliceNum].push(pos);
    }

    sliceNum++;
  }

  var m = null;
  
  if (transform!==undef) m = (transform.getResult!==undef)?transform.getResult():transform;

  for (j = 0; j < lathe_divisions; j++) {
    for (k = 0, kMax = pointList.length; k < kMax; k++) {
      if (m) {
        obj_in.addPoint(mat4.vec3_multiply(slices[j][k], m));
      } else {
        obj_in.addPoint(slices[j][k]);
      }
    }
  }
  
  obj_in.setFaceMaterial(material);

  for (k = 0; k < lathe_divisions; k++) {
    for (j = 0, jMax = pointList.length - 1; j < jMax; j++) {
      var pt = j + (pointList.length * k);
      var pt_r = j + (pointList.length * ((k + 1) % (lathe_divisions)));

      if (vec3.equal(obj_in.points[pofs + pt], obj_in.points[pofs + pt_r])) {
        obj_in.addFace([pofs + pt + 1, pofs + pt_r + 1, pofs + pt_r]);
      } else if (vec3.equal(obj_in.points[pofs + pt + 1], obj_in.points[pofs + pt_r + 1])) {
        obj_in.addFace([pofs + pt, pofs + pt + 1, pofs + pt_r]);
      } else {
        obj_in.addFace([pofs + pt, pofs + pt + 1, pofs + pt_r + 1, pofs + pt_r]);
      }
    }
  }

  
  if (uvmapper !== undef)
  {
    var uvm = null;

    if (uvmapper.apply !== undef)
    {
      uvm = uvmapper;
    }
    else if (uvmapper)
    {
      uvm = new UVMapper(uvmapper);
    }

    if (uvm !== null)
    {
      // Calculate face normals (used for UV mapping and lighting), todo: face range+offset
      obj_in.calcNormals();

      uvm.apply(obj_in, material);  
    }
  }  

}

function cubicvr_planeObject(mesh, size, mat, transform, uvmapper) {
  var half_size = size*0.5;
  var pofs = mesh.points.length;

  mesh.setFaceMaterial(mat);

  if (transform !== undef) {
    var m = (transform.getResult!==undef)?transform.getResult():transform;
    mesh.addPoint([
      mat4.vec3_multiply([half_size, -half_size, 0],m),
      mat4.vec3_multiply([half_size, half_size, 0],m),
      mat4.vec3_multiply([-half_size, half_size, 0],m),
      mat4.vec3_multiply([-half_size, -half_size, 0],m)
    ]);
  }
  else {
    mesh.addPoint([
      [half_size, -half_size, 0],
      [half_size, half_size, 0],
      [-half_size, half_size, 0],
      [-half_size, -half_size, 0]
    ]);
  }
  mesh.addFace([
    [pofs+0, pofs+1, pofs+2, pofs+3], //back
    [pofs+3, pofs+2, pofs+1, pofs+0]  //front
  ]);

  if (uvmapper !== undef)
  {
    var uvm = null;

    if (uvmapper.apply !== undef)
    {
      uvm = uvmapper;
    }
    else if (uvmapper)
    {
      uvm = new UVMapper(uvmapper);
    }

    if (uvm !== null)
    {
      // Calculate face normals (used for UV mapping and lighting), todo: face range+offset
      mesh.calcNormals();

      uvm.apply(mesh, mat);  
    }
  }  

} //cubicvr_planeObject

function cubicvr_boxObject(boxObj, box_size, box_mat, transform, uvmapper) {
  var half_box = box_size / 2.0;
  var pofs = boxObj.points.length;
  
  boxObj.setFaceMaterial(box_mat);

  if (transform !== undef) {
    var m = (transform.getResult!==undef)?transform.getResult():transform;
    boxObj.addPoint([
      mat4.vec3_multiply([half_box, -half_box, half_box], m),
      mat4.vec3_multiply([half_box, half_box, half_box], m),
      mat4.vec3_multiply([-half_box, half_box, half_box], m),
      mat4.vec3_multiply([-half_box, -half_box, half_box], m),
      mat4.vec3_multiply([half_box, -half_box, -half_box], m),
      mat4.vec3_multiply([half_box, half_box, -half_box], m),
      mat4.vec3_multiply([-half_box, half_box, -half_box], m),
      mat4.vec3_multiply([-half_box, -half_box, -half_box], m)
      ]);
  } else {
    boxObj.addPoint([
      [half_box, -half_box, half_box],
      [half_box, half_box, half_box],
      [-half_box, half_box, half_box],
      [-half_box, -half_box, half_box],
      [half_box, -half_box, -half_box],
      [half_box, half_box, -half_box],
      [-half_box, half_box, -half_box],
      [-half_box, -half_box, -half_box]
      ]);

}

boxObj.addFace([
  [pofs + 0, pofs + 1, pofs + 2, pofs + 3],
  [pofs + 7, pofs + 6, pofs + 5, pofs + 4],
  [pofs + 4, pofs + 5, pofs + 1, pofs + 0],
  [pofs + 5, pofs + 6, pofs + 2, pofs + 1],
  [pofs + 6, pofs + 7, pofs + 3, pofs + 2],
  [pofs + 7, pofs + 4, pofs + 0, pofs + 3]
  ]);
  
  if (uvmapper !== undef)
  {
    var uvm = null;

    if (uvmapper.apply !== undef)
    {
      uvm = uvmapper;
    }
    else if (uvmapper)
    {
      uvm = new UVMapper(uvmapper);
    }

    if (uvm !== null)
    {
      // Calculate face normals (used for UV mapping and lighting), todo: face range+offset
      boxObj.calcNormals();

      uvm.apply(boxObj, box_mat);  
    }
  }  
}

function cubicvr_torusObject(mesh, inner_radius, outer_radius, lon, lat, material, transform, uvmapper) {
    var pointList = new Array();

    var thick = outer_radius-inner_radius;
    var radius = inner_radius+(thick)/2.0;

    // generate a circle on the right side (radius) of the X/Y axis, circle radius of (thick)
    var step = (M_TWO_PI / lat);
    var theta = 0;
    for (var i = 0; i <= lat; i ++) {
        pointList.push([radius + Math.cos(theta) * thick, Math.sin(theta) * thick, 0]);
        theta += step;
    }

    CubicVR.genLatheObject(mesh, pointList, lon, material, transform, uvmapper);
}


function cubicvr_coneObject(mesh, base, height, lon, material, transform, uvmapper) {
    CubicVR.genLatheObject(mesh, [[0,-height/2,0],[base/2.0,-height/2,0],[0,height/2,0]], lon, material, transform, uvmapper);
}


function cubicvr_cylinderObject(mesh, radius, height, lon, material, transform, uvmapper) {
    CubicVR.genLatheObject(mesh, [[0,-height/2,0],[radius,-height/2,0],[radius,height/2,0],[0,height/2,0]], lon, material, transform, uvmapper);
}

function cubicvr_sphereObject(mesh, radius, lon, lat, material, transform, uvmapper) {
    var pointList = new Array();

    lat = parseInt(lat /= 2);
    lon = parseInt(lon);

    // generate a half-circle on the right side of the x/y axis
    var step = (M_PI / lat);
    var theta = -M_HALF_PI;
    for (var i = 0; i <= lat; i ++) {
        pointList.push([Math.cos(theta) * radius, Math.sin(theta) * radius, 0]);
        theta += step;
    }

    CubicVR.genLatheObject(mesh, pointList, lon, material, transform, uvmapper);
}

var primitives = {
  
  lathe: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var pointList, lathe_divisions;
    
    if (obj_init.points==undef) return null;
    
    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    lathe_divisions = (obj_init.divisions!==undef)?obj_init.divisions:24;
    
    cubicvr_latheObject(obj_in,obj_init.points,lathe_divisions,material,transform,uvmapper);
    
    return obj_in;
  },
  box: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var size;
    
    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;
    
    size = (obj_init.size!==undef)?obj_init.size:1.0;

    cubicvr_boxObject(obj_in, size, material, transform, uvmapper);
    
    return obj_in;
  },
  plane: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var size;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    size = (obj_init.size!==undef)?obj_init.size:1.0;
 
    cubicvr_planeObject(obj_in, size, material, transform, uvmapper);
        
    return obj_in;
  },
  sphere: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var radius, lon, lat;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    radius = (obj_init.radius!==undef)?obj_init.radius:1.0;
    lon = (obj_init.lon!==undef)?obj_init.lon:24;
    lat = (obj_init.lat!==undef)?obj_init.lat:24;
    
    cubicvr_sphereObject(obj_in, radius, lon, lat, material, transform, uvmapper);
      
    return obj_in;    
  },
  torus: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var innerRadius, outerRadius, lon, lat;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    innerRadius = (obj_init.innerRadius!==undef)?obj_init.innerRadius:0.75;
    outerRadius = (obj_init.outerRadius!==undef)?obj_init.outerRadius:1.0;
    lon = (obj_init.lon!==undef)?obj_init.lon:24;
    lat = (obj_init.lat!==undef)?obj_init.lat:24;
    
    cubicvr_torusObject(obj_in, innerRadius, outerRadius, lon, lat, material, transform, uvmapper);
    
    return obj_in;    
  },
  cone: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var base, height, lon;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    base = (obj_init.base!==undef)?obj_init.base:1.0;
    height = (obj_init.height!==undef)?obj_init.height:1.0;
    lon = (obj_init.lon!==undef)?obj_init.lon:24;

    cubicvr_coneObject(obj_in, base, height, lon, material, transform, uvmapper);
    
    return obj_in;    
  },
  cylinder: function(obj_init) {
    var obj_in, material, transform, uvmapper;
    var radius, height;

    obj_in = (obj_init.mesh!==undef)?obj_init.mesh:(new CubicVR.Mesh((obj_init.name!==undef)?obj_init.name:undef));
    material = (obj_init.material!==undef)?obj_init.material:(new CubicVR.Material());
    transform = (obj_init.transform!==undef)?obj_init.transform:undef;
    uvmapper = (obj_init.uvmapper!==undef)?obj_init.uvmapper:undef;

    radius = (obj_init.radius!==undef)?obj_init.radius:1.0;
    height = (obj_init.height!==undef)?obj_init.height:1.0;
    lon = (obj_init.lon!==undef)?obj_init.lon:24;

    cubicvr_cylinderObject(obj_in, radius, height, lon, material, transform, uvmapper);
    
    return obj_in;    
  }
}



function Landscape(size_in, divisions_in_w, divisions_in_h, matRef_in) {
  this.doTransform = function() {};
  this.tMatrix = cubicvr_identity;

  this.parent = null;
  this.position = [0, 0, 0];
  this.scale = [1, 1, 1];
  this.size = size_in;
  this.divisions_w = divisions_in_w;
  this.divisions_h = divisions_in_h;
  this.matRef = matRef_in;
  this.children = null;

  this.obj = new Mesh();

  var i, j;

  if (this.divisions_w > this.divisions_h) {
    this.size_w = size_in;
    this.size_h = (size_in / this.divisions_w) * this.divisions_h;
  } else if (this.divisions_h > this.divisions_w) {
    this.size_w = (size_in / this.divisions_h) * this.divisions_w;
    this.size_h = size_in;
  } else {
    this.size_w = size_in;
    this.size_h = size_in;
  }

  for (j = -(this.size_h / 2.0); j < (this.size_h / 2.0); j += (this.size_h / this.divisions_h)) {
    for (i = -(this.size_w / 2.0); i < (this.size_w / 2.0); i += (this.size_w / this.divisions_w)) {
      this.obj.addPoint([i + ((this.size_w / (this.divisions_w)) / 2.0), 0, j + ((this.size_h / (this.divisions_h)) / 2.0)]);
    }
  }

  var k, l;

  this.obj.setFaceMaterial(this.matRef);

  for (l = 0; l < this.divisions_h - 1; l++) {
    for (k = 0; k < this.divisions_w - 1; k++) {
      this.obj.addFace([(k) + ((l + 1) * this.divisions_w),
                              (k + 1) + ((l) * this.divisions_w),
                                (k) + ((l) * this.divisions_w)]);

      this.obj.addFace([(k) + ((l + 1) * this.divisions_w),
                              (k + 1) + ((l + 1) * this.divisions_w),
                              (k + 1) + ((l) * this.divisions_w)]);
    }
  }
}

Landscape.prototype.getMesh = function() {
  return this.obj;
}

Landscape.prototype.setIndexedHeight = function(ipos, jpos, val) {
  obj.points[(ipos) + (jpos * this.divisions_w)][1] = val;
}

Landscape.prototype.mapGen = function(w_func, ipos, jpos, ilen, jlen) {
  var pt;
  
  if (ipos!==undef && jpos !==undef && ilen !==undef && jlen!==undef) {
    if (ipos>=this.divisions_w) return;
    if (jpos>=this.divisions_h) return;
    if (ipos+ilen>=this.divisions_w) ilen = this.divisions_w-1-ipos; 
    if (jpos+jlen>=this.divisions_h) jlen = this.divisions_h-1-jpos; 
    if (ilen<=0 || jlen<=0) return;

    for (var i = ipos, imax = ipos+ilen; i < imax; i++) {
      for (var j = jpos, jmax = jpos+jlen; j < jmax; j++) {
        pt = this.obj.points[(i) + (j * this.divisions_w)];
        
        pt[1] = w_func(pt[0],pt[2]);
      }
    }
  } else {
    for (var x = 0, xmax = this.obj.points.length; x < xmax; x++) {
      pt = this.obj.points[x];
      
      pt[1] = w_func(pt[0],pt[2]);
    }
  }
}


Landscape.prototype.getFaceAt = function(x, z) {
  if (typeof(x) === 'object') {
     return this.getFaceAt(x[0], x[2]);
  }
 
  var ofs_w = (this.size_w / 2.0) - ((this.size_w / (this.divisions_w)) / 2.0);
  var ofs_h = (this.size_h / 2.0) - ((this.size_h / (this.divisions_h)) / 2.0);

  var i = parseInt(Math.floor(((x + ofs_w) / this.size_w) * (this.divisions_w)), 10);
  var j = parseInt(Math.floor(((z + ofs_h) / this.size_h) * (this.divisions_h)), 10);

  if (i < 0) {
    return -1;
  }
  if (i >= this.divisions_w - 1) {
    return -1;
  }
  if (j < 0) {
    return -1;
  }
  if (j >= this.divisions_h - 1) {
    return -1;
  }

  var faceNum1 = parseInt(i + (j * (this.divisions_w - 1)), 10) * 2;
  var faceNum2 = parseInt(faceNum1 + 1, 10);

  var testPt = this.obj.points[this.obj.faces[faceNum1].points[0]];

  var slope = Math.abs(z - testPt[2]) / Math.abs(x - testPt[0]);

  if (slope >= 1.0) {
    return (faceNum1);
  } else {
    return (faceNum2);
  }
};


/*
  cvrFloat Landscape::getHeightValue(XYZ &pt)
  {
    Face *tmpFace;
    XYZ *tmpPoint;

    int faceNum = getFaceAt(pt);

    if (faceNum === -1) return 0;

    tmpFace = obj->faces[faceNum];
    tmpPoint = obj->points[obj->faces[faceNum]->pointref[0]];

    tmpFace->calcFaceNormal();

    cvrFloat na = tmpFace->face_normal.x;
    cvrFloat nb = tmpFace->face_normal.y;
    cvrFloat nc = tmpFace->face_normal.z;

    cvrFloat d = -na * tmpPoint->x - nb * tmpPoint->y - nc * tmpPoint->z;

    return ((na * pt.x + nc * pt.z+d)/-nb)+getPosition().y;
  };
  */

Landscape.prototype.getHeightValue = function(x, z) {

  if (typeof(x) === 'object') {
    return this.getHeightValue(x[0], x[2]);
  }

  var tmpFace;
  var tmpPoint;

  var faceNum = this.getFaceAt(x, z);

  if (faceNum === -1) {
    return 0;
  }

  tmpFace = this.obj.faces[faceNum];
  tmpPoint = this.obj.points[this.obj.faces[faceNum].points[0]];

  var tmpNorm = triangle.normal(this.obj.points[this.obj.faces[faceNum].points[0]], this.obj.points[this.obj.faces[faceNum].points[1]], this.obj.points[this.obj.faces[faceNum].points[2]]);

  var na = tmpNorm[0];
  var nb = tmpNorm[1];
  var nc = tmpNorm[2];

  var d = -(na * tmpPoint[0]) - (nb * tmpPoint[1]) - (nc * tmpPoint[2]);

  return (((na * x) + (nc * z) + d) / (-nb)); // add height ofs here
};


Landscape.prototype.orient = function(x, z, width, length, heading, center) {
  if (center === undef) {
    center = 0;
  }

  var xpos, zpos;
  var xrot, zrot;
  var heightsample = [];
  var xyzTmp;

  var halfw = width / 2.0;
  var halfl = length / 2.0;

  var mag = Math.sqrt(halfl * halfl + halfw * halfw);
  var ang = Math.atan2(halfl, halfw);

  heading *= (M_PI / 180.0);

  xpos = x + (Math.sin(heading) * center);
  zpos = z + (Math.cos(heading) * center);

  heightsample[0] = this.getHeightValue([xpos + mag * Math.cos(-ang - M_HALF_PI + heading), 0, zpos + mag * -Math.sin(-ang - M_HALF_PI + heading)]);
  heightsample[1] = this.getHeightValue([xpos + mag * Math.cos(ang - M_HALF_PI + heading), 0, zpos + mag * (-Math.sin(ang - M_HALF_PI + heading))]);
  heightsample[2] = this.getHeightValue([xpos + mag * Math.cos(-ang + M_HALF_PI + heading), 0, zpos + mag * (-Math.sin(-ang + M_HALF_PI + heading))]);
  heightsample[3] = this.getHeightValue([xpos + mag * Math.cos(ang + M_HALF_PI + heading), 0, zpos + mag * (-Math.sin(ang + M_HALF_PI + heading))]);

  xrot = -Math.atan2((heightsample[1] - heightsample[2]), width);
  zrot = -Math.atan2((heightsample[0] - heightsample[1]), length);

  xrot += -Math.atan2((heightsample[0] - heightsample[3]), width);
  zrot += -Math.atan2((heightsample[3] - heightsample[2]), length);

  xrot /= 2.0; // average angles
  zrot /= 2.0;


  return [[x, ((heightsample[2] + heightsample[3] + heightsample[1] + heightsample[0])) / 4.0, z], //
  [xrot * (180.0 / M_PI), heading, zrot * (180.0 / M_PI)]];
};

var scene_object_uuid = 0;

function SceneObject(obj, name) {
  var obj_init = null;
  
  if (obj!==undef && obj!==null)
  {
    if (obj.compile)
    {
      obj_init = null;
    } else {
      obj_init = obj;
    }    
  }

  if (obj_init) {
    this.position = (obj_init.position===undef)?[0, 0, 0]:obj_init.position;
    this.rotation = (obj_init.rotation===undef)?[0, 0, 0]:obj_init.rotation;
    this.scale = (obj_init.scale===undef)?[1, 1, 1]:obj_init.scale;

    this.motion = (obj_init.motion===undef)?null:obj_init.motion;
    this.obj = (obj_init.mesh===undef)?((obj !== undef && obj_init.faces !== undef) ? obj : null):obj_init.mesh;
    this.name = (obj_init.name===undef)?((name !== undef) ? name : null):obj_init.name;
  } else {
    this.position = [0, 0, 0];
    this.rotation = [0, 0, 0];
    this.scale = [1, 1, 1];

    this.motion = null;
    this.obj = obj;
    this.name = name;    
  }
  
  this.children = null;
  this.parent = null;

  this.drawn_this_frame = false;

  this.lposition = [0, 0, 0];
  this.lrotation = [0, 0, 0];
  this.lscale = [0, 0, 0];

  this.trans = new Transform();

  this.tMatrix = this.trans.getResult();

  this.dirty = true;

  this.aabb = [];

  this.id = -1;

  this.octree_leaves = [];
  this.octree_common_root = null;
  this.octree_aabb = [[0,0,0],[0,0,0]];
  AABB_reset(this.octree_aabb, [0,0,0]);
  this.ignore_octree = false;
  this.visible = true;
  this.culled = true;
  this.was_culled = true;

  this.dynamic_lights = [];
  this.static_lights = [];
}

SceneObject.prototype.doTransform = function(mat) {
  if (!vec3.equal(this.lposition, this.position) || !vec3.equal(this.lrotation, this.rotation) || !vec3.equal(this.lscale, this.scale) || (mat !== undef)) {

    this.trans.clearStack();

    if ((mat !== undef)) {
      this.trans.pushMatrix(mat);
    }

    this.trans.translate(this.position);

    if (! (this.rotation[0] === 0 && this.rotation[1] === 0 && this.rotation[2] === 0)) {
      this.trans.pushMatrix();
      this.trans.rotate(this.rotation);
    }

    if (! (this.scale[0] === 1 && this.scale[1] === 1 && this.scale[2] === 1)) {
      this.trans.pushMatrix();
      this.trans.scale(this.scale);
    }




    this.tMatrix = this.trans.getResult();

    this.lposition[0] = this.position[0];
    this.lposition[1] = this.position[1];
    this.lposition[2] = this.position[2];
    this.lrotation[0] = this.rotation[0];
    this.lrotation[1] = this.rotation[1];
    this.lrotation[2] = this.rotation[2];
    this.lscale[0] = this.scale[0];
    this.lscale[1] = this.scale[1];
    this.lscale[2] = this.scale[2];
    this.dirty = true;
  }
};

SceneObject.prototype.adjust_octree = function() {
  var aabb = this.getAABB();
  var taabb = this.octree_aabb;
  var px0 = aabb[0][0];
  var py0 = aabb[0][1];
  var pz0 = aabb[0][2];
  var px1 = aabb[1][0];
  var py1 = aabb[1][1];
  var pz1 = aabb[1][2];
  var tx0 = taabb[0][0];
  var ty0 = taabb[0][1];
  var tz0 = taabb[0][2];
  var tx1 = taabb[1][0];
  var ty1 = taabb[1][1];
  var tz1 = taabb[1][2];
  if (this.octree_leaves.length > 0 && (px0 < tx0 || py0 < ty0 || pz0 < tz0 || px1 > tx1 || py1 > ty1 || pz1 > tz1)) {
    for (var i = 0; i < this.octree_leaves.length; ++i) {
      this.octree_leaves[i].remove(this);
    } //for
    this.octree_leaves = [];
    this.static_lights = [];
    var common_root = this.octree_common_root;
    this.octree_common_root = null;
    if (common_root !== null) {

      while (true) {
        if (!common_root.contains_point(aabb[0]) || !common_root.contains_point(aabb[1])) {
          if (common_root._root !== undef && common_root._root !== null) {
            common_root = common_root._root;
          } else {
            break;
          } //if
        } else {
          break;
        } //if
      } //while
      AABB_reset(this.octree_aabb, this.position);
      common_root.insert(this);
    } //if
  } //if
}; //SceneObject::adjust_octree
SceneObject.prototype.bindChild = function(childSceneObj, pickable) {
  if (this.children === null) {
    this.children = [];
  }

  childSceneObj.parent = this;
  this.children.push(childSceneObj);
};


SceneObject.prototype.control = function(controllerId, motionId, value) {
  if (controllerId === enums.motion.POS) {
    this.position[motionId] = value;
  } else if (controllerId === enums.motion.SCL) {
    this.scale[motionId] = value;
  } else if (controllerId === enums.motion.ROT) {
    this.rotation[motionId] = value;
  }

  /*
  switch (controllerId) {
  case enums.motion.POS:
    this.position[motionId] = value;
    break;
  case enums.motion.SCL:
    this.scale[motionId] = value;
    break;
  case enums.motion.ROT:
    this.rotation[motionId] = value;
    break;
  }
  */
};

SceneObject.prototype.getAABB = function() {
  if (this.dirty) {
    var p = new Array(8);

    this.doTransform();

    var aabbMin;
    var aabbMax;



    if (this.obj !== null)
    {
      if (this.obj.bb === null)
      {
        this.aabb = [vec3.add([-1,-1,-1],this.position),vec3.add([1,1,1],this.position)];
        return this.aabb;
      }

      aabbMin = this.obj.bb[0];
      aabbMax = this.obj.bb[1];
    }
    
    if (this.obj === null || aabbMin === undef || aabbMax === undef)
    {
      // aabbMin=[-1,-1,-1];
      // aabbMax=[1,1,1];      
      // 
      // if (this.obj.bb.length===0)
      // {
        this.aabb = [vec3.add([-1,-1,-1],this.position),vec3.add([1,1,1],this.position)];
        return this.aabb;
      // }
    }

    /*
    if (this.scale[0] !== 1 || this.scale[1] !== 1 || this.scale[2] !== 1) {
      aabbMin[0] *= this.scale[0];
      aabbMin[1] *= this.scale[1];
      aabbMin[2] *= this.scale[2];
      aabbMax[0] *= this.scale[0];
      aabbMax[1] *= this.scale[1];
      aabbMax[2] *= this.scale[2];
    }
    */

    var obj_aabb = aabbMin;
    var obj_bounds = vec3.subtract(aabbMax, aabbMin);

    p[0] = [obj_aabb[0], obj_aabb[1], obj_aabb[2]];
    p[1] = [obj_aabb[0], obj_aabb[1], obj_aabb[2] + obj_bounds[2]];
    p[2] = [obj_aabb[0] + obj_bounds[0], obj_aabb[1], obj_aabb[2]];
    p[3] = [obj_aabb[0] + obj_bounds[0], obj_aabb[1], obj_aabb[2] + obj_bounds[2]];
    p[4] = [obj_aabb[0], obj_aabb[1] + obj_bounds[1], obj_aabb[2]];
    p[5] = [obj_aabb[0], obj_aabb[1] + obj_bounds[1], obj_aabb[2] + obj_bounds[2]];
    p[6] = [obj_aabb[0] + obj_bounds[0], obj_aabb[1] + obj_bounds[1], obj_aabb[2]];
    p[7] = [obj_aabb[0] + obj_bounds[0], obj_aabb[1] + obj_bounds[1], obj_aabb[2] + obj_bounds[2]];

    var aabbTest;

    aabbTest = mat4.vec3_multiply(p[0], this.tMatrix);

    aabbMin = [aabbTest[0], aabbTest[1], aabbTest[2]];
    aabbMax = [aabbTest[0], aabbTest[1], aabbTest[2]];

    for (var i = 1; i < 8; ++i) {
      aabbTest = mat4.vec3_multiply(p[i], this.tMatrix);

      if (aabbMin[0] > aabbTest[0]) {
        aabbMin[0] = aabbTest[0];
      }
      if (aabbMin[1] > aabbTest[1]) {
        aabbMin[1] = aabbTest[1];
      }
      if (aabbMin[2] > aabbTest[2]) {
        aabbMin[2] = aabbTest[2];
      }

      if (aabbMax[0] < aabbTest[0]) {
        aabbMax[0] = aabbTest[0];
      }
      if (aabbMax[1] < aabbTest[1]) {
        aabbMax[1] = aabbTest[1];
      }
      if (aabbMax[2] < aabbTest[2]) {
        aabbMax[2] = aabbTest[2];
      }
    }

    this.aabb[0] = aabbMin;
    this.aabb[1] = aabbMax;

    this.dirty = false;
  }

  return this.aabb;
};

var cubicvr_env_range = function(v, lo, hi) {
  var v2, i = 0,
    r;

  r = hi - lo;

  if (r === 0.0) {
    return [lo, 0];
  }

  v2 = v - r * Math.floor((v - lo) / r);

  i = -parseInt((v2 - v) / r + (v2 > v ? 0.5 : -0.5), 10);

  return [v2, i];
};

var cubicvr_env_hermite = function(t) {
  var h1, h2, h3, h4;
  var t2, t3;

  t2 = t * t;
  t3 = t * t2;

  h2 = 3.0 * t2 - t3 - t3;
  h1 = 1.0 - h2;
  h4 = t3 - t2;
  h3 = h4 - t2 + t;

  return [h1, h2, h3, h4];
};

var cubicvr_env_bezier = function(x0, x1, x2, x3, t) {
  var a, b, c, t2, t3;

  t2 = t * t;
  t3 = t2 * t;

  c = 3.0 * (x1 - x0);
  b = 3.0 * (x2 - x1) - c;
  a = x3 - x0 - c - b;

  return a * t3 + b * t2 + c * t + x0;
};



var cubicvr_env_bez2_time = function(x0, x1, x2, x3, time, t0, t1) {

  var v, t;

  t = t0 + (t1 - t0) * 0.5;
  v = cubicvr_env_bezier(x0, x1, x2, x3, t);
  if (Math.abs(time - v) > 0.0001) {
    if (v > time) {
      t1 = t;
    } else {
      t0 = t;
    }
    return cubicvr_env_bez2_time(x0, x1, x2, x3, time, t0, t1);
  } else {
    return t;
  }
};



var cubicvr_env_bez2 = function(key0, key1, time)
{
   var x, y, t, t0 = 0.0, t1 = 1.0;

   if ( key0.shape === enums.envelope.shape.BEZ2 ) {
     
      x = key0.time + key0.param[ 2 ];
  } else {
      x = key0.time + ( key1.time - key0.time ) / 3.0;
    }
    
   t = cubicvr_env_bez2_time( key0.time, x, key1.time + key1.param[ 0 ], key1.time, time, t0, t1 );

   if ( key0.shape === enums.envelope.shape.BEZ2 ){
      y = key0.value + key0.param[ 3 ];
    }
   else {
      y = key0.value + key0.param[ 1 ] / 3.0;
    }

   return cubicvr_env_bezier( key0.value, y, key1.param[ 1 ] + key1.value, key1.value, t );
}


var cubicvr_env_outgoing = function(key0, key1) {
  var a, b, d, t, out;

  if (key0.shape === enums.envelope.shape.TCB) {
    a = (1.0 - key0.tension) * (1.0 + key0.continuity) * (1.0 + key0.bias);
    b = (1.0 - key0.tension) * (1.0 - key0.continuity) * (1.0 - key0.bias);
    d = key1.value - key0.value;

    if (key0.prev) {
      t = (key1.time - key0.time) / (key1.time - (key0.prev).time);
      out = t * (a * (key0.value - (key0.prev).value) + b * d);
    } else {
      out = b * d;
    }
  } else if (key0.shape === enums.envelope.shape.LINE) {
    d = key1.value - key0.value;
    if (key0.prev) {
      t = (key1.time - key0.time) / (key1.time - (key0.prev).time);
      out = t * (key0.value - (key0.prev).value + d);
    } else {
      out = d;
    }
  } else if ((key0.shape === enums.envelope.shape.BEZI)||(key0.shape === enums.envelope.shape.HERM)) {
    out = key0.param[1];
    if (key0.prev) {
      out *= (key1.time - key0.time) / (key1.time - (key0.prev).time);
    }
  } else if (key0.shape === enums.envelope.shape.BEZ2) {
    out = key0.param[3] * (key1.time - key0.time);
    if (Math.abs(key0.param[2]) > 1e-5) {
      out /= key0.param[2];
    } else {
      out *= 1e5;
    }
  } else if (key0.shape === enums.envelope.shape.STEP) {
    out = 0.0;    
  } else {
    out = 0.0;
  }

  return out;
};



var cubicvr_env_incoming = function(key0, key1) {
  var a, b, d, t, inval;

  if (key1.shape === enums.envelope.shape.LINE) {
    d = key1.value - key0.value;
    if (key1.next) {
      t = (key1.time - key0.time) / ((key1.next).time - key0.time);
      inval = t * ((key1.next).value - key1.value + d);
    } else {
      inval = d;
    }
  } else if (key1.shape === enums.envelope.shape.TCB) {
    a = (1.0 - key1.tension) * (1.0 - key1.continuity) * (1.0 + key1.bias);
    b = (1.0 - key1.tension) * (1.0 + key1.continuity) * (1.0 - key1.bias);
    d = key1.value - key0.value;

    if (key1.next) {
      t = (key1.time - key0.time) / ((key1.next).time - key0.time);
      inval = t * (b * ((key1.next).value - key1.value) + a * d);
    } else {
      inval = a * d;
    }
  } else if ((key1.shape === enums.envelope.shape.HERM) || (key1.shape === enums.envelope.shape.BEZI)) {
    inval = key1.param[0];
    if (key1.next) {
      inval *= (key1.time - key0.time) / ((key1.next).time - key0.time);
    }
  } else if (key1.shape === enums.envelope.shape.BEZ2) {    
    inval = key1.param[1] * (key1.time - key0.time);
    if (Math.abs(key1.param[0]) > 1e-5) {
      inval /= key1.param[0];
    } else {
      inval *= 1e5;
    }
  } else if (key1.shape === enums.envelope.shape.STEP) {
    inval = 0.0;    
  } else {
    inval = 0.0;
  }

  return inval;
};


function EnvelopeKey() {
  this.value = 0;
  this.time = 0;
  this.shape = enums.envelope.shape.TCB;
  this.tension = 0;
  this.continuity = 0;
  this.bias = 0;
  this.prev = null;
  this.next = null;

  this.param = [0,0,0,0];
}


function Envelope(obj_init) {
  this.nKeys = 0;
  this.keys = null;
  this.firstKey = null;
  this.lastKey = null;
  
  if (obj_init)
  {
    this.in_behavior = obj_init.in_behavior?obj_init.in_behavior:enums.envelope.behavior.CONSTANT;
    this.out_behavior = obj_init.out_behavior?obj_init.out_behavior:enums.envelope.behavior.CONSTANT;
  }
  else
  {
    this.in_behavior = enums.envelope.behavior.CONSTANT;
    this.out_behavior = enums.envelope.behavior.CONSTANT;
  }
}

Envelope.prototype.setBehavior = function(in_b, out_b) {
  this.in_behavior = in_b;
  this.out_behavior = out_b;
};


Envelope.prototype.empty = function() {
  return (this.nKeys === 0);
};


Envelope.prototype.addKey = function(time, value, key_init) {
  var tempKey;

  var obj = (typeof(time)=='object')?time:key_init;

  if (!value) value = 0;
  if (!time) time = 0;
  
  if (obj) {
    obj = time;
    time = obj.time;

    tempKey = this.insertKey(time);
    
    tempKey.value = obj.value?obj.value:value;
    tempKey.time = obj.time?obj.time:time;;
    tempKey.shape = obj.shape?obj.shape:enums.envelope.shape.TCB;
    tempKey.tension = obj.tension?obj.tension:0;
    tempKey.continuity = obj.continuity?obj.continuity:0;
    tempKey.bias = obj.bias?obj.bias:0;
    tempKey.param = obj.param?obj.param:[0,0,0,0];
    
  } else {
    tempKey = this.insertKey(time);    
    tempKey.value = value;
  }


  return tempKey;
};


Envelope.prototype.insertKey = function(time) {
  var tempKey = new EnvelopeKey();

  tempKey.time = time;
  if (!this.nKeys) {
    this.keys = tempKey;
    this.firstKey = tempKey;
    this.lastKey = tempKey;
    this.nKeys++;

    return tempKey;
  }

  var k1 = this.keys;

  while (k1) {
    // update first/last key
    if (this.firstKey.time > time) {
      this.firstKey = tempKey;
    } else if (this.lastKey.time < time) {
      this.lastKey = tempKey;
    }

    if (k1.time > tempKey.time) {
      tempKey.prev = k1.prev;
      if (tempKey.prev) {
        tempKey.prev.next = tempKey;
      }

      tempKey.next = k1;
      tempKey.next.prev = tempKey;

      this.nKeys++;
      
      return tempKey;
    } else if (!k1.next) {
      tempKey.prev = k1;
      k1.next = tempKey;

      this.nKeys++;

      return tempKey;
    }

    k1 = k1.next;
  }

  return null; // you should not be here, time and space has imploded
};

Envelope.prototype.evaluate = function(time) {
  var key0, key1, skey, ekey;
  var t, h1, h2, h3, h4, inval, out, offset = 0.0;
  var noff;

  /* if there's no key, the value is 0 */
  if (this.nKeys === 0) {
    return 0.0;
  }

  /* if there's only one key, the value is constant */
  if (this.nKeys === 1) {
    return (this.keys).value;
  }

  /* find the first and last keys */
  skey = this.firstKey;
  ekey = this.lastKey;

  var tmp, behavior;

  /* use pre-behavior if time is before first key time */
  if (time < skey.time) {
    behavior = this.in_behavior;

    if (behavior        === enums.envelope.behavior.RESET) {
      return 0.0;
    } else if (behavior === enums.envelope.behavior.CONSTANT) {
      return skey.value;
    } else if (behavior === enums.envelope.behavior.REPEAT) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
    } else if (behavior === enums.envelope.behavior.OCILLATE) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];

      if (noff % 2) {
        time = ekey.time - skey.time - time;
      }
    } else if (behavior === enums.envelope.behavior.OFFSET) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];
      offset = noff * (ekey.value - skey.value);
    } else if (behavior === enums.envelope.behavior.LINEAR) {
      out = cubicvr_env_outgoing(skey, skey.next) / (skey.next.time - skey.time);
      return out * (time - skey.time) + skey.value;
    } 

    /*
    switch (this.in_behavior) {
    case enums.envelope.behavior.RESET:
      return 0.0;

    case enums.envelope.behavior.CONSTANT:
      return skey.value;

    case enums.envelope.behavior.REPEAT:
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      break;

    case enums.envelope.behavior.OSCILLATE:
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];

      if (noff % 2) {
        time = ekey.time - skey.time - time;
      }
      break;

    case enums.envelope.behavior.OFFSET:
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];
      offset = noff * (ekey.value - skey.value);
      break;

    case enums.envelope.behavior.LINEAR:
      out = cubicvr_env_outgoing(skey, skey.next) / (skey.next.time - skey.time);
      return out * (time - skey.time) + skey.value;
    }
    */
  }

  /* use post-behavior if time is after last key time */
  else if (time > ekey.time) {
    behavior = this.out_behavior;

    if (behavior        === enums.envelope.behavior.RESET) {
      return 0.0;
    } else if (behavior === enums.envelope.behavior.CONSTANT) {
      return ekey.value;
    } else if (behavior === enums.envelope.behavior.REPEAT) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
    } else if (behavior === enums.envelope.behavior.OCILLATE) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];

      if (noff % 2) {
        time = ekey.time - skey.time - time;
      }
    } else if (behavior === enums.envelope.behavior.OFFSET) {
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];
      offset = noff * (ekey.value - skey.value);
    } else if (behavior === enums.envelope.behavior.LINEAR) {
      inval = cubicvr_env_incoming(ekey.prev, ekey) / (ekey.time - ekey.prev.time);
      return inval * (time - ekey.time) + ekey.value;
    } 
    /*
    switch (this.out_behavior) {
    case enums.envelope.behavior.RESET:
      return 0.0;

    case enums.envelope.behavior.CONSTANT:
      return ekey.value;

    case enums.envelope.behavior.REPEAT:
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      break;

    case enums.envelope.behavior.OSCILLATE:
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];

      if (noff % 2) {
        time = ekey.time - skey.time - time;
      }
      break;

    case enums.envelope.behavior.OFFSET:
      tmp = cubicvr_env_range(time, skey.time, ekey.time);
      time = tmp[0];
      noff = tmp[1];
      offset = noff * (ekey.value - skey.value);
      break;

    case enums.envelope.behavior.LINEAR:
      inval = cubicvr_env_incoming(ekey.prev, ekey) / (ekey.time - ekey.prev.time);
      return inval * (time - ekey.time) + ekey.value;
    }
    */
  }

  // get the endpoints of the interval being evaluated
  key0 = this.keys;
  while (time > key0.next.time) {
    key0 = key0.next;
  }
  key1 = key0.next;

  // check for singularities first
  if (time === key0.time) {
    return key0.value + offset;
  } else if (time === key1.time) {
    return key1.value + offset;
  }

  // get interval length, time in [0, 1]
  t = (time - key0.time) / (key1.time - key0.time);

  // interpolate
  /*
  switch (key1.shape) {
  case enums.envelope.shape.TCB:
  case enums.envelope.shape.BEZI:
  case enums.envelope.shape.HERM:
    out = cubicvr_env_outgoing(key0, key1);
    inval = cubicvr_env_incoming(key0, key1);
    var h = cubicvr_env_hermite(t);
    return h[0] * key0.value + h[1] * key1.value + h[2] * out + h[3] * inval + offset;

  case enums.envelope.shape.BEZ2:
    return cubicvr_env_bez2_time(key0, key1, time) + offset;

  case enums.envelope.shape.LINE:
    return key0.value + t * (key1.value - key0.value) + offset;

  case enums.envelope.shape.STEP:
    return key0.value + offset;

  default:
    return offset;
  }
  */

  var keyShape = key1.shape;

  if (keyShape === enums.envelope.shape.TCB || keyShape === enums.envelope.shape.BEZI || keyShape === enums.envelope.shape.HERM) {
    out = cubicvr_env_outgoing(key0, key1);
    inval = cubicvr_env_incoming(key0, key1);
    var h = cubicvr_env_hermite(t);
    return h[0] * key0.value + h[1] * key1.value + h[2] * out + h[3] * inval + offset;
  } else if (keyShape === enums.envelope.shape.BEZ2) {
    return cubicvr_env_bez2(key0, key1, time) + offset;
  } else if (keyShape === enums.envelope.shape.LINE) {
    return key0.value + t * (key1.value - key0.value) + offset;
  } else if (keyShape === enums.envelope.shape.STEP) {
    return key0.value + offset;
  } else {
    return offset;
  }
};

function Motion(env_init, key_init) {
  this.env_init = env_init;
  this.key_init = key_init;
  this.controllers = [];
  this.yzflip = false;
//  this.rscale = 1;
}

Motion.prototype.envelope = function(controllerId, motionId) {
  if (this.controllers[controllerId] === undef) {
    this.controllers[controllerId] = [];
  }
  if (this.controllers[controllerId][motionId] === undef) {
    this.controllers[controllerId][motionId] = new Envelope(this.env_init);
  }

  return this.controllers[controllerId][motionId];
};

Motion.prototype.evaluate = function(index) {
  var retArr = [];

  for (var i in this.controllers) {
    if (this.controllers.hasOwnProperty(i)) {
      retArr[i] = [];

      for (var j in this.controllers[i]) {
        if (this.controllers[i].hasOwnProperty(j)) {
          retArr[i][j] = this.controllers[i][j].evaluate(index);
        }
      }
    }
  }

  return retArr;
};

Motion.prototype.apply = function(index, target) {
  for (var i in this.controllers) {
    if (this.controllers.hasOwnProperty(i)) {
      var ic = parseInt(i, 10);

      /* Special case quaternion fix for ZY->YZ rotation envelopes */
      if (this.yzflip && ic === enums.motion.ROT) // assume channel 0,1,2
      {
        if (!this.q) {
          this.q = new Quaternion();
        }
        var q = this.q;

        var x = this.controllers[i][0].evaluate(index);
        var y = this.controllers[i][1].evaluate(index);
        var z = this.controllers[i][2].evaluate(index);

        //q.fromEuler(x*this.rscale, z*this.rscale, -y*this.rscale);
        q.fromEuler(x, z, -y);


        var qr = q.toEuler();

        target.control(ic, 0, qr[0]);
        target.control(ic, 1, qr[1]);
        target.control(ic, 2, qr[2]);
      }
      else {
        for (var j in this.controllers[i]) {
          if (this.controllers[i].hasOwnProperty(j)) {
            target.control(ic, parseInt(j, 10), this.controllers[i][j].evaluate(index));
          }
        }
      }
    }
  }
};


Motion.prototype.setKey = function(controllerId, motionId, index, value, key_init) {
  var ev = this.envelope(controllerId, motionId);
  return ev.addKey(index, value, key_init?key_init:this.key_init);
};

Motion.prototype.setArray = function(controllerId, index, value, key_init) {
  var tmpKeys = [];

  for (var i in value) {
    if (value.hasOwnProperty(i)) {
      var ev = this.envelope(controllerId, i);
      tmpKeys[i] = ev.addKey(index, value[i], key_init?key_init:this.key_init);
    }
  }

  return tmpKeys;
};


Motion.prototype.setBehavior = function(controllerId, motionId, behavior_in, behavior_out) {
  var ev = this.envelope(controllerId, motionId);
  ev.setBehavior(behavior_in, behavior_out);
};


Motion.prototype.setBehaviorArray = function(controllerId, behavior_in, behavior_out) {
  for (var motionId in this.controllers[controllerId]) {
    if (this.controllers[controllerId].hasOwnProperty(motionId)) {
      var ev = this.envelope(controllerId, motionId);
      ev.setBehavior(behavior_in, behavior_out);
    }
  }
};



function cubicvr_nodeToMotion(node, controllerId, motion) {
  var c = [];
  c[0] = node.getElementsByTagName("x");
  c[1] = node.getElementsByTagName("y");
  c[2] = node.getElementsByTagName("z");
  c[3] = node.getElementsByTagName("fov");

  var etime, evalue, ein, eout, etcb;

  for (var k in c) {
    if (c.hasOwnProperty(k)) {
      if (c[k] !== undef) {
        if (c[k].length) {
          etime = c[k][0].getElementsByTagName("time");
          evalue = c[k][0].getElementsByTagName("value");
          ein = c[k][0].getElementsByTagName("in");
          eout = c[k][0].getElementsByTagName("out");
          etcb = c[k][0].getElementsByTagName("tcb");

          var time = null,
            value = null,
            tcb = null;

          var intype = null,
            outtype = null;

          if (ein.length) {
            intype = util.collectTextNode(ein[0]);
          }

          if (eout.length) {
            outtype = util.collectTextNode(eout[0]);
          }

          if (etime.length) {
            time = util.floatDelimArray(util.collectTextNode(etime[0]), " ");
          }

          if (evalue.length) {
            value = util.floatDelimArray(util.collectTextNode(evalue[0]), " ");
          }

          if (etcb.length) {
            tcb = util.floatDelimArray(util.collectTextNode(etcb[0]), " ");
          }


          if (time !== null && value !== null) {
            for (var i = 0, iMax = time.length; i < iMax; i++) {
              var mkey = motion.setKey(controllerId, k, time[i], value[i]);

              if (tcb) {
                mkey.tension = tcb[i * 3];
                mkey.continuity = tcb[i * 3 + 1];
                mkey.bias = tcb[i * 3 + 2];
              }
            }
          }

          var in_beh = enums.envelope.behavior.CONSTANT;
          var out_beh = enums.envelope.behavior.CONSTANT;

          if (intype) {
            switch (intype) {
            case "reset":
              in_beh = enums.envelope.behavior.RESET;
              break;
            case "constant":
              in_beh = enums.envelope.behavior.CONSTANT;
              break;
            case "repeat":
              in_beh = enums.envelope.behavior.REPEAT;
              break;
            case "oscillate":
              in_beh = enums.envelope.behavior.OSCILLATE;
              break;
            case "offset":
              in_beh = enums.envelope.behavior.OFFSET;
              break;
            case "linear":
              in_beh = enums.envelope.behavior.LINEAR;
              break;
            }
          }

          if (outtype) {
            switch (outtype) {
            case "reset":
              out_beh = enums.envelope.behavior.RESET;
              break;
            case "constant":
              out_beh = enums.envelope.behavior.CONSTANT;
              break;
            case "repeat":
              out_beh = enums.envelope.behavior.REPEAT;
              break;
            case "oscillate":
              out_beh = enums.envelope.behavior.OSCILLATE;
              break;
            case "offset":
              out_beh = enums.envelope.behavior.OFFSET;
              break;
            case "linear":
              out_beh = enums.envelope.behavior.LINEAR;
              break;
            }
          }

          motion.setBehavior(controllerId, k, in_beh, out_beh);
        }
      }
    }
  }
}


function cubicvr_isMotion(node) {
  if (node === null) {
    return false;
  }

  return (node.getElementsByTagName("x").length || node.getElementsByTagName("y").length || node.getElementsByTagName("z").length || node.getElementsByTagName("fov").length);
}

/***********************************************
 * Plane
 ***********************************************/

function Plane() {
  this.a = 0;
  this.b = 0;
  this.c = 0;
  this.d = 0;
} //Plane::Constructor
Plane.prototype.classify_point = function(pt) {
  var dist = (this.a * pt[0]) + (this.b * pt[1]) + (this.c * pt[2]) + (this.d);
  if (dist < 0) {
    return -1;
  }
  if (dist > 0) {
    return 1;
  }
  return 0;
}; //Plane::classify_point
Plane.prototype.normalize = function() {
  var mag = Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
  this.a = this.a / mag;
  this.b = this.b / mag;
  this.c = this.c / mag;
  this.d = this.d / mag;
}; //Plane::normalize
Plane.prototype.toString = function() {
  return "[Plane " + this.a + ", " + this.b + ", " + this.c + ", " + this.d + "]";
}; //Plane::toString
/***********************************************
 * Sphere
 ***********************************************/

function Sphere(position, radius) {
  this.position = position;
  if (this.position === undef) {
    this.position = [0, 0, 0];
  }
  this.radius = radius;
} //Sphere::Constructor
Sphere.prototype.intersects = function(other_sphere) {
  var diff = vec3.subtract(this.position, other_sphere.position);
  var mag = Math.sqrt(diff[0] * diff[0] + diff[1] * diff[1] + diff[2] * diff[2]);
  var sum_radii = this.radius + other_sphere.radius;
  if (mag * mag < sum_radii * sum_radii) {
    return true;
  }
  return false;
}; //Sphere::intersects

function OctreeWorkerProxy(size, depth) {
  var that = this;
  this.size = size;
  this.depth = depth;
  this.worker = new CubicVR_Worker({
      message: function(e) {
        console.log('Octree Worker Message:', e);
      },
      error: function(e) {
        console.log('Octree Worker Error:', e);
      },
      type: 'octree'});
  this.worker.start();

  this.init = function(scene) {
    that.scene = scene;
    that.worker.init({
      size: that.size,
      max_depth: that.depth,
      camera: scene.camera
    });
  }; //init
  this.insert = function(node) {
    that.worker.send({message:'insert', node:node});
  }; //insert
  this.draw_on_map = function() {
    return;
  }; //draw_on_map
  this.reset_node_visibility = function() {
    return;
  }; //reset_node_visibility
  this.get_frustum_hits = function() {
  }; //get_frustum_hits
} //OctreeWorkerProxy

function Octree(size, max_depth, root, position, child_index) {
  this._children = [];
  this._dirty = false;
  this._children[0] = null;
  this._children[1] = null;
  this._children[2] = null;
  this._children[3] = null;
  this._children[4] = null;
  this._children[5] = null;
  this._children[6] = null;
  this._children[7] = null;

  if (child_index === undef) {
    this._child_index = -1;
  } else {
    this._child_index = child_index;
  }

  if (size === undef) {
    this._size = 0;
  } else {
    this._size = size;
  }

  if (max_depth === undef) {
    this._max_depth = 0;
  } else {
    this._max_depth = max_depth;
  }

  if (root === undef) {
    this._root = null;
  } else {
    this._root = root;
  }

  if (position === undef) {
    this._position = [0, 0, 0];
  } else {
    this._position = position;
  }

  this._nodes = [];
  //this._static_nodes = [];
  this._lights = [];
  this._static_lights = [];

  this._sphere = new Sphere(this._position, Math.sqrt(3 * (this._size / 2 * this._size / 2)));
  this._bbox = [[0,0,0],[0,0,0]];
  AABB_reset(this._bbox, this._position);

  var s = this._size/2;
  AABB_engulf(this._bbox, [this._position[0] + s, this._position[1] + s, this._position[2] + s]);
  AABB_engulf(this._bbox, [this._position[0] - s, this._position[1] - s, this._position[2] - s]);
  this._debug_visible = false;
} //Octree::Constructor
Array_remove = function(arr, from, to) {
  var rest = arr.slice((to || from) + 1 || arr.length);
  arr.length = from < 0 ? arr.length + from : from;
  return arr.push.apply(arr, rest);
};
Octree.prototype.destroy = function() {
  for (var i=0, li = this._static_lights.length; i<li; ++i) {
    var light = this._static_lights[i];
    light.octree_leaves = null;
    light.octree_common_root = null;
    light.octree_aabb = null;
  } //for
  for (var i=0, li = this._lights.length; i<li; ++i) {
    var light = this._lights[i];
    light.octree_leaves = null;
    light.octree_common_root = null;
    light.octree_aabb = null;
  } //for
  this._static_lights = null;
  this._lights = null;
  for (var i = 0, len = this._children.length; i < len; ++i) {
    if (this._children[i] !== null) {
      this._children[i].destroy();
    } //if
  } //for
  for (var i = 0, max_i = this._nodes.length; i < max_i; ++i) {
    var node = this._nodes[i];
    node.octree_leaves = null;
    node.octree_common_root = null;
    node.octree_aabb = null;
    node.dynamic_lights = [];
    node.static_lights = [];
  } //for
  this._children[0] = null;
  this._children[1] = null;
  this._children[2] = null;
  this._children[3] = null;
  this._children[4] = null;
  this._children[5] = null;
  this._children[6] = null;
  this._children[7] = null;
  this._children = null;
  this._root = null;
  this._position = null;
  this._nodes = null;
  this._lights = null;
  this._static_lights = null;
  this._sphere = null;
  this._bbox = null;
} //Octree::destroy
Octree.prototype.toString = function() {
  var real_size = [this._bbox[1][0] - this._bbox[0][0], this._bbox[1][2] - this._bbox[0][2]];
  return "[Octree: @" + this._position + ", depth: " + this._max_depth + ", size: " + this._size + ", nodes: " + this._nodes.length + ", measured size:" + real_size + "]";
}; //Octree::toString
Octree.prototype.remove = function(node) {
  var dont_check_lights = false;
  var len = this._nodes.length;
  var i;
  for (i = len - 1, len = this._nodes.length; i >= 0; --i) {
    if (node === this._nodes[i]) {
      Array_remove(this._nodes, i);
      this.dirty_lineage();
      dont_check_lights = true;
      break;
    } //if
  } //for
  if (!dont_check_lights) {
    for (i = len - 1, len = this._lights.length; i >= 0; --i) {
      if (node === this._lights[i]) {
        Array_remove(this._lights, i);
        this.dirty_lineage();
        break;
      } //if      
    } //for
  } //if
}; //Octree::remove
Octree.prototype.dirty_lineage = function() {
  this._dirty = true;
  if (this._root !== null) { this._root.dirty_lineage(); }
} //Octree::dirty_lineage
Octree.prototype.cleanup = function() {
  var num_children = this._children.length;
  var num_keep_children = 0;
  for (var i = 0; i < num_children; ++i) {
    var child = this._children[i];
    if (child !== null) {
      var keep = true;
      if (child._dirty === true) {
        keep = child.cleanup();
      } //if
      if (!keep) {
        this._children[i] = null;
      } else {
        ++num_keep_children;
      }
    } //if
  } //for
  if ((this._nodes.length === 0 && this._static_lights.length === 0 && this._lights.length === 0) && (num_keep_children === 0 || num_children === 0)) {
    return false;
  }
  return true;
}; //Octree::cleanup
Octree.prototype.insert_light = function(light) {
  this.insert(light, true);
}; //insert_light
Octree.prototype.propagate_static_light = function(light) {
  var i,l;
  for (i = 0, l = this._nodes.length; i < l; ++i) {
    if (this._nodes[i].static_lights.indexOf(light) === -1) {
      this._nodes[i].static_lights.push(light);
    } //if
  } //for
  for (i = 0; i < 8; ++i) {
    if (this._children[i] !== null) {
      this._children[i].propagate_static_light(light);
    } //if
  } //for
}; //propagate_static_light
Octree.prototype.collect_static_lights = function(node) {
  for (var i=0, li = this._static_lights.length; i<li; ++i) {
    if (node.static_lights.indexOf(this._static_lights[i]) === -1) {
      node.static_lights.push(this._static_lights[i]);
    } //if
  } //for
  for (var i = 0; i < 8; ++i) {
    if (this._children[i] !== null) {
      this._children[i].collect_static_lights(node);
    } //if
  } //for
}; //collect_static_lights
Octree.prototype.insert = function(node, is_light) {
  if (is_light === undef) { is_light = false; }
  function $insert(octree, node, is_light, root) {
    var i, li;
    if (is_light) {
      if (node.method === enums.light.method.STATIC) {
        if (octree._static_lights.indexOf(node) === -1) {
          octree._static_lights.push(node);
        } //if
        for (i=0; i<octree._nodes.length; ++i) {
          if (octree._nodes[i].static_lights.indexOf(node) === -1) {
            octree._nodes[i].static_lights.push(node);
          } //if
        } //for
        var root_tree = octree._root;
        while (root_tree !== null) {
          for (var i=0, l=root_tree._nodes.length; i<l; ++i) {
            var n = root_tree._nodes[i];
            if (n.static_lights.indexOf(node) === -1) {
              n.static_lights.push(node);
            } //if
          } //for
          root_tree = root_tree._root;
        } //while
      }
      else {
        if (octree._lights.indexOf(node) === -1) {
          octree._lights.push(node);
        } //if
      } //if
    } else {
      octree._nodes.push(node);
      for (i=0, li = octree._static_lights.length; i<li; ++i) {
        if (node.static_lights.indexOf(octree._static_lights[i]) === -1) {
          node.static_lights.push(octree._static_lights[i]);
        } //if
      } //for
      var root_tree = octree._root;
      while (root_tree !== null) {
        for (var i=0, l=root_tree._static_lights.length; i<l; ++i) {
          var light = root_tree._static_lights[i];
          if (node.static_lights.indexOf(light) === -1) {
            node.static_lights.push(light);
          } //if
        } //for
        root_tree = root_tree._root;
      } //while
    } //if
    node.octree_leaves.push(octree);
    node.octree_common_root = root;
    AABB_engulf(node.octree_aabb, octree._bbox[0]);
    AABB_engulf(node.octree_aabb, octree._bbox[1]);
  } //$insert
  if (this._root === null) {
    node.octree_leaves = [];
    node.octree_common_root = null;
  } //if
  if (this._max_depth === 0) {
    $insert(this, node, is_light, this._root);
    return;
  } //if
  //Check to see where the node is
  var p = this._position;
  var t_nw, t_ne, t_sw, t_se, b_nw, b_ne, b_sw, b_se;
  var aabb = node.getAABB();
  var min = [aabb[0][0], aabb[0][1], aabb[0][2]];
  var max = [aabb[1][0], aabb[1][1], aabb[1][2]];

  t_nw = min[0] < p[0] && min[1] < p[1] && min[2] < p[2];
  t_ne = max[0] > p[0] && min[1] < p[1] && min[2] < p[2];
  b_nw = min[0] < p[0] && max[1] > p[1] && min[2] < p[2];
  b_ne = max[0] > p[0] && max[1] > p[1] && min[2] < p[2];
  t_sw = min[0] < p[0] && min[1] < p[1] && max[2] > p[2];
  t_se = max[0] > p[0] && min[1] < p[1] && max[2] > p[2];
  b_sw = min[0] < p[0] && max[1] > p[1] && max[2] > p[2];
  b_se = max[0] > p[0] && max[1] > p[1] && max[2] > p[2];

  //Is it in every sector?
  if (t_nw && t_ne && b_nw && b_ne && t_sw && t_se && b_sw && b_se) {
    $insert(this, node, is_light, this);
    if (is_light) {
      if (node.method == enums.light.method.STATIC) {
        this.propagate_static_light(node);
      } //if
    }
    else {
      this.collect_static_lights(node);
    } //if
  } else {

    //Add static lights in this octree
    for (var i=0, ii=this._static_lights.length; i<ii; ++i) {
      if (node.static_lights === undef) node.static_lights = [];
      if (node.static_lights.indexOf(this._static_lights[i]) === -1) {
        node.static_lights.push(this._static_lights[i]);
      } //if
    } //for

    var new_size = this._size / 2;
    var offset = this._size / 4;
    var new_position;

    var num_inserted = 0;
    //Create & check children to see if node fits there too
    var x = this._position[0];
    var y = this._position[1];
    var z = this._position[2];
    if (t_nw) {
      new_position = [x - offset, y - offset, z - offset];
      if (this._children[enums.octree.TOP_NW] === null) {
        this._children[enums.octree.TOP_NW] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.TOP_NW);
      }
      this._children[enums.octree.TOP_NW].insert(node, is_light);
      ++num_inserted;
    } //if
    if (t_ne) {
      new_position = [x + offset, y - offset, z - offset];
      if (this._children[enums.octree.TOP_NE] === null) {
        this._children[enums.octree.TOP_NE] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.TOP_NE);
      }
      this._children[enums.octree.TOP_NE].insert(node, is_light);
      ++num_inserted;
    } //if
    if (b_nw) {
      new_position = [x - offset, y + offset, z - offset];
      if (this._children[enums.octree.BOTTOM_NW] === null) {
        this._children[enums.octree.BOTTOM_NW] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.BOTTOM_NW);
      }
      this._children[enums.octree.BOTTOM_NW].insert(node, is_light);
      ++num_inserted;
    } //if
    if (b_ne) {
      new_position = [x + offset, y + offset, z - offset];
      if (this._children[enums.octree.BOTTOM_NE] === null) {
        this._children[enums.octree.BOTTOM_NE] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.BOTTOM_NE);
      }
      this._children[enums.octree.BOTTOM_NE].insert(node, is_light);
      ++num_inserted;
    } //if
    if (t_sw) {
      new_position = [x - offset, y - offset, z + offset];
      if (this._children[enums.octree.TOP_SW] === null) {
        this._children[enums.octree.TOP_SW] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.TOP_SW);
      }
      this._children[enums.octree.TOP_SW].insert(node, is_light);
      ++num_inserted;
    } //if
    if (t_se) {
      new_position = [x + offset, y - offset, z + offset];
      if (this._children[enums.octree.TOP_SE] === null) {
        this._children[enums.octree.TOP_SE] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.TOP_SE);
      }
      this._children[enums.octree.TOP_SE].insert(node, is_light);
      ++num_inserted;
    } //if
    if (b_sw) {
      new_position = [x - offset, y + offset, z + offset];
      if (this._children[enums.octree.BOTTOM_SW] === null) {
        this._children[enums.octree.BOTTOM_SW] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.BOTTOM_SW);
      }
      this._children[enums.octree.BOTTOM_SW].insert(node, is_light);
      ++num_inserted;
    } //if
    if (b_se) {
      new_position = [x + offset, y + offset, z + offset];
      if (this._children[enums.octree.BOTTOM_SE] === null) {
        this._children[enums.octree.BOTTOM_SE] = new Octree(new_size, this._max_depth - 1, this, new_position, enums.octree.BOTTOM_SE);
      }
      this._children[enums.octree.BOTTOM_SE].insert(node, is_light);
      ++num_inserted;
    } //if
    if (num_inserted > 1 || node.octree_common_root === null) {
      node.octree_common_root = this;
    } //if
  } //if
}; //Octree::insert
Octree.prototype.draw_on_map = function(map_canvas, map_context, target) {
  var mhw = map_canvas.width/2;
  var mhh = map_canvas.height/2;
  var x, y, w, h;
  var i, len;

  if (target === undef || target === "map") {
    map_context.save();
    if (this._debug_visible !== false) {
      map_context.fillStyle = "rgba(0,0,0,0)";
      map_context.strokeStyle = "#FF0000";
    }
    else {
      map_context.fillStyle = "rgba(0,0,0,0)";
      map_context.strokeStyle = "rgba(0,0,0,0)";
    } //if
    map_context.beginPath();
    var offset = this._size / 2;
    x = this._position[0];
    y = this._position[2];
    map_context.moveTo(mhw + x - offset, mhw + y - offset);
    map_context.lineTo(mhw + x - offset, mhw + y + offset);
    map_context.lineTo(mhw + x + offset, mhw + y + offset);
    map_context.lineTo(mhw + x + offset, mhw + y - offset);
    map_context.stroke();
    map_context.fill();
    map_context.restore();
  }

  if (target === undef || target === "objects") {
    map_context.save();
    for (i = 0, len = this._nodes.length; i < len; ++i) {
      var n = this._nodes[i];
      map_context.fillStyle = "#5500FF";
      if (n.visible === true && n.culled === false) {
        map_context.strokeStyle = "#FFFFFF";
      } else {
        map_context.strokeStyle = "#000000";
      } //if
      map_context.beginPath();
      x = n.aabb[0][0];
      y = n.aabb[0][2];
      w = n.aabb[1][0] - x;
      h = n.aabb[1][2] - y;
      map_context.rect(mhw + x, mhh + y, w, h);
      map_context.stroke();
    } //for
    map_context.restore();
  }

  if (target === undef || target === "lights") {
    for (i = 0, len = this._lights.length; i < len; ++i) {
      var l = this._lights[i];
      if (l.culled === false && l.visible === true) {
        map_context.fillStyle = "rgba(255, 255, 255, 0.1)";
      } else {
        map_context.fillStyle = "rgba(255, 255, 255, 0.0)";
      }
      map_context.strokeStyle = "#FFFF00";
      map_context.beginPath();
      var d = l.distance;
      x = l.position[0];
      y = l.position[2];
      map_context.arc(mhw + x, mhh + y, d, 0, Math.PI * 2, true);
      map_context.closePath();
      map_context.stroke();
      map_context.fill();
      map_context.beginPath();
      x = l.aabb[0][0];
      y = l.aabb[0][2];
      w = l.aabb[1][0] - x;
      h = l.aabb[1][2] - y;
      map_context.rect(mhw + x, mhh + y, w, h);
      map_context.closePath();
      map_context.stroke();
    } //for
    for (i = 0, len = this._static_lights.length; i < len; ++i) {
      var l = this._static_lights[i];
      if (l.culled === false && l.visible === true) {
        map_context.fillStyle = "rgba(255, 255, 255, 0.01)";
      } else {
        map_context.fillStyle = "rgba(255, 255, 255, 0.0)";
      }
      map_context.strokeStyle = "#FF66BB";
      map_context.beginPath();
      var d = l.distance;
      x = l.position[0];
      y = l.position[2];
      map_context.arc(mhw + x, mhh + y, d, 0, Math.PI * 2, true);
      map_context.closePath();
      map_context.stroke();
      map_context.fill();
      map_context.beginPath();
      x = l.aabb[0][0];
      y = l.aabb[0][2];
      w = l.aabb[1][0] - x;
      h = l.aabb[1][2] - y;
      map_context.rect(mhw + x, mhh + y, w, h);
      map_context.closePath();
      map_context.stroke();
    } //for
  } //if

  function $draw_box(x1, y1, x2, y2, fill) {
    var x = x1 < x2 ? x1 : x2;
    var y = y1 < y2 ? y1 : y2;
    var w = x1 < x2 ? x2-x1 : x1-x2;
    var h = y1 < y2 ? y2-y1 : y1-y2;
    map_context.save();
    if (fill !== undefined) {
      map_context.fillStyle = fill;
      map_context.fillRect(mhw+x,mhh+y,w,h);
    } //if
    map_context.strokeRect(mhw+x,mhh+y,w,h);
    map_context.restore();
  } //$draw_box

  function $draw_oct(oct, fill) {
    var x1 = oct._bbox[0][0];
    var y1 = oct._bbox[0][2];
    var x2 = oct._bbox[1][0];
    var y2 = oct._bbox[1][2];
    $draw_box(x1, y1, x2, y2, fill);
  } //$draw_oct
  if (target != "lights" && target != "objects" && target != "map") {
    map_context.save();
    var nodes = this._nodes;
    for (var i=0,l=nodes.length;i<l;++i) {
      var n = nodes[i];
      if (n.name == target) {
        map_context.strokeStyle = "#FFFF00";
        map_context.lineWidth = 3;
        map_context.beginPath();
        x = n.aabb[0][0];
        y = n.aabb[0][2];
        w = n.aabb[1][0] - x;
        h = n.aabb[1][2] - y;
        map_context.rect(mhw + x, mhh + y, w, h);
        map_context.closePath();
        map_context.stroke();

        var oab = n.octree_aabb;
        map_context.strokeStyle = "#0000FF";
        $draw_box(oab[0][0], oab[0][2], oab[1][0], oab[1][2]);
        map_context.lineWidth = 1;
        if (n.common_root !== null) {
          map_context.strokeStyle = "#00FF00";
          //$draw_oct(n.octree_common_root);
        } //if
        break;
      } //if
    } //for
    map_context.lineWidth = 1;
    map_context.strokeStyle = "#FFFF00";
    $draw_oct(this, "#444444");
    map_context.fill();
    map_context.restore();

  } //if

  for (i = 0, len = this._children.length; i < len; ++i) {
    if (this._children[i] !== null) {
      this._children[i].draw_on_map(map_canvas, map_context, target);
    }
  } //for
}; //Octree::draw_on_map
Octree.prototype.contains_point = function(position) {
  return position[0] <= this._position[0] + this._size / 2 && position[1] <= this._position[1] + this._size / 2 && position[2] <= this._position[2] + this._size / 2 && position[0] >= this._position[0] - this._size / 2 && position[1] >= this._position[1] - this._size / 2 && position[2] >= this._position[2] - this._size / 2;
}; //Octree::contains_point
Octree.prototype.get_frustum_hits = function(camera, test_children) {
  var hits = {
    objects: [],
    lights: []
  };
  if (test_children === undef || test_children === true) {
    if (! (this.contains_point(camera.position))) {
      if (camera.frustum.sphere.intersects(this._sphere) === false) {
        return hits;
      }
      //if(_sphere.intersects(c.get_frustum().get_cone()) === false) return;
      var contains_sphere = camera.frustum.contains_sphere(this._sphere);
      if (contains_sphere === -1) {
        this._debug_visible = false;
        return hits;
      }
      else if (contains_sphere === 1) {
        this._debug_visible = 2;
        test_children = false;
      }
      else if (contains_sphere === 0) {
        this._debug_visible = true;
        var contains_box = camera.frustum.contains_box(this._bbox);
        if (contains_box === -1) {
          this._debug_visible = false;
          return hits;
        }
        else if (contains_box === 1) {
          this._debug_visible = 3;
          test_children = false;
        } //if
      } //if
    } //if
  } //if
  var i, max_i;
  for (i = 0, max_i = this._nodes.length; i < max_i; ++i) {
    var n = this._nodes[i];
    hits.objects.push(n);
    n.dynamic_lights = [].concat(this._lights);
    n.was_culled = n.culled;
    n.culled = false;
    n.drawn_this_frame = false;
  } //for objects
  this._debug_visible = this._lights.length > 0 ? 4 : this._debug_visible;
  for (i = 0, max_i = this._lights.length; i < max_i; ++i) {
    var l = this._lights[i];
    if (l.visible === true) {
      hits.lights.push(l);
      l.was_culled = l.culled;
      l.culled = false;
    } //if
  } //for dynamic lights
  for (i = 0, max_i = this._static_lights.length; i < max_i; ++i) {
    var l = this._static_lights[i];
    if (l.visible === true) {
      l.culled = false;
    } //if
  } //for static lights
  for (i = 0; i < 8; ++i) {
    if (this._children[i] !== null) {
      var child_hits = this._children[i].get_frustum_hits(camera, test_children);
      var o, max_o;
      for (o = 0, max_o = child_hits.objects.length; o < max_o; ++o) {
        hits.objects.push(child_hits.objects[o]);
        var obj_lights = child_hits.objects[o].dynamic_lights;
        for (var j=0, lj=this._lights.length; j<lj; ++j) {
          if(obj_lights.indexOf(this._lights[j]) < 0) {
            obj_lights.push(this._lights[j]);
          } //if
        } //for j
      } //for o
      //hits.lights = hits.lights.concat(child_hits.lights);
      //collect lights and make sure they're unique <- really slow
      for (o = 0, max_o = child_hits.lights.length; o < max_o; ++o) {
        if (hits.lights.indexOf(child_hits.lights[o]) < 0) {
          hits.lights.push(child_hits.lights[o]);
        } //if
      } //for o
    } //if
  } //for
  return hits;
}; //Octree::get_frustum_hits
Octree.prototype.reset_node_visibility = function() {
  this._debug_visible = false;

  var i, l;
  for (i = 0, l = this._nodes.length; i < l; ++i) {
    this._nodes[i].culled = true;
  } //for
  for (i = 0, l = this._lights.length; i < l; ++i) {
    this._lights[i].culled = true;
  } //for
  for (i = 0, l = this._static_lights.length; i < l; ++i) {
    this._static_lights[i].culled = true;
  } //for
  for (i = 0, l = this._children.length; i < l; ++i) {
    if (this._children[i] !== null) {
      this._children[i].reset_node_visibility();
    } //if
  } //for
}; //Octree::reset_visibility
/***********************************************
 * OctreeNode
 ***********************************************/

function OctreeNode() {
  this.position = [0, 0, 0];
  this.visible = false;
  this._object = null;
} //OctreeNode::Constructor
OctreeNode.prototype.toString = function() {
  return "[OctreeNode " + this.position + "]";
}; //OctreeNode::toString
OctreeNode.prototype.attach = function(obj) {
  this._object = obj;
}; //OctreeNode::attach

function CubicVR_OctreeWorker() {
  this.octree = null;
  this.nodes = [];
  this.camera = null;
} //CubicVR_OctreeWorker::Constructor
CubicVR_OctreeWorker.prototype.onmessage = function(input) {
  var message = input.message;
  if (message === "init") {
    var params = input.data;
    this.octree = new Octree(params.size, params.max_depth);
    this.camera = new Camera();
  }
  else if (type === "set_camera") {
    var data = message.data;
    this.camera.mvMatrix = data.mvMatrix;
    this.camera.pMatrix = data.pMatrix;
    this.camera.position = data.position;
    this.camera.target = data.target;
    this.camera.frustum.extract(this.camera, this.camera.mvMatrix, this.camera.pMatrix);
  }
  else if (type === "insert") {
    var json_node = JSON.parse(message.data);
    var node = new SceneObject();
    var trans = new Transform();

    for (var i in json_node) {
      if (json_node.hasOwnProperty(i)) {
        node[i] = json_node[i];
      } //if
    } //for

    for (var i in json_node.trans) {
      if (json_node.trans.hasOwnProperty(i)) {
        trans[i] = json_node.trans[i];
      } //if
    } //for

    node.trans = trans;
    node.id = json_node.id;

    this.octree.insert(node);
    this.nodes[node.id] = node;
  }
  else if (type === "cleaup") {
    this.octree.cleanup();
  } //if
}; //onmessage

/***********************************************
 * Frustum
 ***********************************************/

function FrustumWorkerProxy(worker, camera) {
  this.camera = camera;
  this.worker = worker;
  this.draw_on_map = function(map_context) {
    return;
  };
} //FrustumWorkerProxy
FrustumWorkerProxy.prototype.extract = function(camera, mvMatrix, pMatrix) {
  this.worker.send({
    type: "set_camera",
    data: {
      mvMatrix: this.camera.mvMatrix,
      pMatrix: this.camera.pMatrix,
      position: this.camera.position,
      target: this.camera.target
    }
  });
}; //FrustumWorkerProxy::extract

function Frustum() {
  this.last_in = [];
  this._planes = [];
  this.sphere = null;
  for (var i = 0; i < 6; ++i) {
    this._planes[i] = new Plane();
  } //for
} //Frustum::Constructor
Frustum.prototype.extract = function(camera, mvMatrix, pMatrix) {
  if (mvMatrix === undef || pMatrix === undef) {
    return;
  }
  var comboMatrix = mat4.multiply(mvMatrix, pMatrix);

  // Left clipping plane
  this._planes[enums.frustum.plane.LEFT].a = comboMatrix[3] + comboMatrix[0];
  this._planes[enums.frustum.plane.LEFT].b = comboMatrix[7] + comboMatrix[4];
  this._planes[enums.frustum.plane.LEFT].c = comboMatrix[11] + comboMatrix[8];
  this._planes[enums.frustum.plane.LEFT].d = comboMatrix[15] + comboMatrix[12];

  // Right clipping plane
  this._planes[enums.frustum.plane.RIGHT].a = comboMatrix[3] - comboMatrix[0];
  this._planes[enums.frustum.plane.RIGHT].b = comboMatrix[7] - comboMatrix[4];
  this._planes[enums.frustum.plane.RIGHT].c = comboMatrix[11] - comboMatrix[8];
  this._planes[enums.frustum.plane.RIGHT].d = comboMatrix[15] - comboMatrix[12];

  // Top clipping plane
  this._planes[enums.frustum.plane.TOP].a = comboMatrix[3] - comboMatrix[1];
  this._planes[enums.frustum.plane.TOP].b = comboMatrix[7] - comboMatrix[5];
  this._planes[enums.frustum.plane.TOP].c = comboMatrix[11] - comboMatrix[9];
  this._planes[enums.frustum.plane.TOP].d = comboMatrix[15] - comboMatrix[13];

  // Bottom clipping plane
  this._planes[enums.frustum.plane.BOTTOM].a = comboMatrix[3] + comboMatrix[1];
  this._planes[enums.frustum.plane.BOTTOM].b = comboMatrix[7] + comboMatrix[5];
  this._planes[enums.frustum.plane.BOTTOM].c = comboMatrix[11] + comboMatrix[9];
  this._planes[enums.frustum.plane.BOTTOM].d = comboMatrix[15] + comboMatrix[13];

  // Near clipping plane
  this._planes[enums.frustum.plane.NEAR].a = comboMatrix[3] + comboMatrix[2];
  this._planes[enums.frustum.plane.NEAR].b = comboMatrix[7] + comboMatrix[6];
  this._planes[enums.frustum.plane.NEAR].c = comboMatrix[11] + comboMatrix[10];
  this._planes[enums.frustum.plane.NEAR].d = comboMatrix[15] + comboMatrix[14];

  // Far clipping plane
  this._planes[enums.frustum.plane.FAR].a = comboMatrix[3] - comboMatrix[2];
  this._planes[enums.frustum.plane.FAR].b = comboMatrix[7] - comboMatrix[6];
  this._planes[enums.frustum.plane.FAR].c = comboMatrix[11] - comboMatrix[10];
  this._planes[enums.frustum.plane.FAR].d = comboMatrix[15] - comboMatrix[14];

  for (var i = 0; i < 6; ++i) {
    this._planes[i].normalize();
  }

  //Sphere
  var fov = 1 / pMatrix[5];
  var near = -this._planes[enums.frustum.plane.NEAR].d;
  var far = this._planes[enums.frustum.plane.FAR].d;
  var view_length = far - near;
  var height = view_length * fov;
  var width = height;

  var P = [0, 0, near + view_length * 0.5];
  var Q = [width, height, near + view_length];
  var diff = vec3.subtract(P, Q);
  var diff_mag = vec3.length(diff);

  var look_v = [comboMatrix[3], comboMatrix[9], comboMatrix[10]];
  var look_mag = vec3.length(look_v);
  look_v = vec3.multiply(look_v, 1 / look_mag);

  this.sphere = new Sphere([camera.position[0], camera.position[1], camera.position[2]], diff_mag);
  this.sphere.position = vec3.add(this.sphere.position, vec3.multiply(look_v, view_length * 0.5));
  this.sphere.position = vec3.add(this.sphere.position, vec3.multiply(look_v, 1));

}; //Frustum::extract
Frustum.prototype.contains_sphere = function(sphere) {
  for (var i = 0; i < 6; ++i) {
    var p = this._planes[i];
    var normal = [p.a, p.b, p.c];
    var distance = vec3.dot(normal, sphere.position) + p.d;
    this.last_in[i] = 1;

    //OUT
    if (distance < -sphere.radius) {
      return -1;
    }

    //INTERSECT
    if (Math.abs(distance) < sphere.radius) {
      return 0;
    }

  } //for
  //IN
  return 1;
}; //Frustum::contains_sphere
Frustum.prototype.draw_on_map = function(map_canvas, map_context) {
  var mhw = map_canvas.width/2;
  var mhh = map_canvas.height/2;
  map_context.save();
  for (var pi = 0, l = this._planes.length; pi < l; ++pi) {
    if (pi === 2 || pi === 3) {continue;}
    map_context.strokeStyle = "#FF00FF";
    if (pi < this.last_in.length) {
      if (this.last_in[pi]) {
        map_context.strokeStyle = "#FFFF00";
      }
    } //if
    var p = this._planes[pi];
    var x1 = -mhw;
    var y1 = (-p.d - p.a * x1) / p.c;
    var x2 = mhw;
    var y2 = (-p.d - p.a * x2) / p.c;
    map_context.moveTo(mhw + x1, mhh + y1);
    map_context.lineTo(mhw + x2, mhh + y2);
    map_context.stroke();
  } //for
  map_context.strokeStyle = "#0000FF";
  map_context.beginPath();
  map_context.arc(mhw + this.sphere.position[0], mhh + this.sphere.position[2], this.sphere.radius, 0, Math.PI * 2, false);
  map_context.closePath();
  map_context.stroke();
  map_context.restore();
}; //Frustum::draw_on_map
Frustum.prototype.contains_box = function(bbox) {
  var total_in = 0;

  var points = [];
  points[0] = bbox[0];
  points[1] = [bbox[0][0], bbox[0][1], bbox[1][2]];
  points[2] = [bbox[0][0], bbox[1][1], bbox[0][2]];
  points[3] = [bbox[0][0], bbox[1][1], bbox[1][2]];
  points[4] = [bbox[1][0], bbox[0][1], bbox[0][2]];
  points[5] = [bbox[1][0], bbox[0][1], bbox[1][2]];
  points[6] = [bbox[1][0], bbox[1][1], bbox[0][2]];
  points[7] = bbox[1];

  for (var i = 0; i < 6; ++i) {
    var in_count = 8;
    var point_in = 1;

    for (var j = 0; j < 8; ++j) {
      if (this._planes[i].classify_point(points[j]) === -1) {
        point_in = 0;
        --in_count;
      } //if
    } //for j
    this.last_in[i] = point_in;

    //OUT
    if (in_count === 0) {
      return -1;
    }

    total_in += point_in;
  } //for i
  //IN
  if (total_in === 6) {
    return 1;
  }

  return 0;
}; //Frustum::contains_box

function Camera(width, height, fov, nearclip, farclip) {
  this.frustum = new Frustum();

  if (typeof(width)=='object') {
    this.position = width.position?width.position:[0, 0, 0];
    this.rotation = width.rotation?width.rotation:[0, 0, 0];
    this.target = width.target?width.target:[0, 0, 0];
    this.fov = width.fov?width.fov:60.0;
    this.nearclip = width.nearclip?width.nearclip:0.1;
    this.farclip = width.farclip?width.farclip:400.0;
    this.targeted = width.targeted?width.targeted:true;
    this.calc_nmatrix =  width.calcNormalMatrix?width.calcNormalMatrix:true;

    height = width.height?width.height:undef;
    width = width.width?width.width:undef;
  } else {
    this.position = [0, 0, 0];
    this.rotation = [0, 0, 0];
    this.target = [0, 0, 0];
    this.fov = (fov !== undef) ? fov : 60.0;
    this.nearclip = (nearclip !== undef) ? nearclip : 0.1;
    this.farclip = (farclip !== undef) ? farclip : 400.0;
    this.targeted = true;
    this.calc_nmatrix = true;
  }

  this.targetSceneObject = null;
  this.motion = null;
  this.transform = new Transform();

  this.manual = false;

  this.setDimensions((width !== undef) ? width : 512, (height !== undef) ? height : 512);

  this.mvMatrix = cubicvr_identity;
  this.pMatrix = null;
  this.calcProjection();
}

Camera.prototype.control = function(controllerId, motionId, value) {
  if (controllerId === enums.motion.ROT) {
    this.rotation[motionId] = value;
  } else if (controllerId === enums.motion.POS) {
    this.position[motionId] = value;
  } else if (controllerId === enums.motion.FOV) {
    this.setFOV(value);
  } else if (controllerId === enums.motion.LENS) {
   this.setLENS(value);
  } else if (controllerId === enums.motion.NEARCLIP) {
   this.setClip(value,this.farclip);
  } else if (controllerId === enums.motion.FARCLIP) {
   this.setClip(this.nearclip,value);
  } 
  /*
  switch (controllerId) {
  case enums.motion.ROT:
    this.rotation[motionId] = value;
    break;
  case enums.motion.POS:
    this.position[motionId] = value;
    break;
  case enums.motion.FOV:
    this.setFOV(value);
    break;
  }
  */
};


Camera.prototype.makeFrustum = function(left, right, bottom, top, zNear, zFar) {
  var A = (right + left) / (right - left);
  var B = (top + bottom) / (top - bottom);
  var C = -(zFar + zNear) / (zFar - zNear);
  var D = -2.0 * zFar * zNear / (zFar - zNear);

  return [2.0 * zNear / (right - left), 0.0, 0.0, 0.0, 0.0, 2.0 * zNear / (top - bottom), 0.0, 0.0, A, B, C, -1.0, 0.0, 0.0, D, 0.0];
};


Camera.prototype.setTargeted = function(targeted) {
  this.targeted = targeted;
};

Camera.prototype.calcProjection = function() {
  this.pMatrix = mat4.perspective(this.fov, this.aspect, this.nearclip, this.farclip);
  if (!this.targeted) {
    this.transform.clearStack();
    //this.transform.translate(vec3.subtract([0,0,0],this.position)).pushMatrix().rotate(vec3.subtract([0,0,0],this.rotation)).getResult();
    this.transform.translate(-this.position[0], -this.position[1], -this.position[2]);
    this.transform.pushMatrix();
    this.transform.rotate(-this.rotation[2], 0, 0, 1);
    this.transform.rotate(-this.rotation[1], 0, 1, 0);
    this.transform.rotate(-this.rotation[0], 1, 0, 0);
    this.transform.pushMatrix();
    this.mvMatrix = this.transform.getResult();
    
    if (this.calc_nmatrix) {
      this.nMatrix = mat4.inverse_mat3(this.mvMatrix);
      mat3.transpose_inline(this.nMatrix);
    } else {
      this.nMatrix = cubicvr_identity;
    }
  }
  this.frustum.extract(this, this.mvMatrix, this.pMatrix);
};


Camera.prototype.setClip = function(nearclip, farclip) {
  this.nearclip = nearclip;
  this.farclip = farclip;
  this.calcProjection();
};


Camera.prototype.setDimensions = function(width, height) {
  this.width = width;
  this.height = height;

  this.aspect = width / height;
  this.calcProjection();
};


Camera.prototype.setFOV = function(fov) {
  this.fov = fov;
  this.calcProjection();
};

Camera.prototype.setLENS = function(lens) {
  this.setFOV(2.0*Math.atan(16.0/lens)*(180.0/M_PI));
};

Camera.prototype.lookat = function(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ) {
  
  if (typeof(eyeX)=='object') {
    this.lookat(this.position[0],this.position[1],this.position[2],eyeX[0],eyeX[1],eyeX[2],0,1,0);
    return;
  }
  
  this.mvMatrix = mat4.lookat(eyeX, eyeY, eyeZ, lookAtX, lookAtY, lookAtZ, upX, upY, upZ);

  if (this.calc_nmatrix) {
    this.nMatrix = mat4.inverse_mat3(this.mvMatrix);
    mat3.transpose_inline(this.nMatrix);
    } else {
      this.nMatrix = cubicvr_identity;
    }
  
  this.frustum.extract(this, this.mvMatrix, this.pMatrix);
};


Camera.prototype.unProject = function (winx, winy, winz) {

    var tmpClip = this.nearclip;
    
    if (tmpClip < 1.0) { this.nearclip = 1.0; this.calcProjection(); }

    var viewport = [0, 0, this.width, this.height];

    if (winz === undef) winz = this.farclip;

    var p = [(((winx - viewport[0]) / (viewport[2])) * 2) - 1, -((((winy - viewport[1]) / (viewport[3])) * 2) - 1), (winz - this.nearclip) / (this.farclip - this.nearclip), 1.0];

    var invp = mat4.vec4_multiply(mat4.vec4_multiply(p, mat4.inverse(this.pMatrix)), mat4.inverse(this.mvMatrix));

    if (tmpClip < 1.0) { this.nearclip = tmpClip; this.calcProjection(); }

    return [invp[0] / invp[3], invp[1] / invp[3], invp[2] / invp[3]];
}


Camera.prototype.project = function (objx, objy, objz) {

  var p = [objx,objy,objz,1.0];
  
  var mp = mat4.vec4_multiply(mat4.vec4_multiply(p,this.mvMatrix),this.pMatrix);
  
  return [((mp[0]/mp[3]+1.0)/2.0)*this.width,((-mp[1]/mp[3]+1.0)/2.0)*this.height,((mp[2]/mp[3]))*(this.farclip-this.nearclip)+this.nearclip];
  
}


/*** Auto-Cam Prototype ***/

function AutoCameraNode(pos) {
  this.position = (pos !== undef) ? pos : [0, 0, 0];
}

AutoCameraNode.prototype.control = function(controllerId, motionId, value) {
  if (controllerId === enums.motion.POS) {
    this.position[motionId] = value;
  }
};

function AutoCamera(start_position, target, bounds) {
  this.camPath = new Motion();
  this.targetPath = new Motion();

  this.start_position = (start_position !== undef) ? start_position : [8, 8, 8];
  this.target = (target !== undef) ? target : [0, 0, 0];

  this.bounds = (bounds !== undef) ? bounds : [[-15, 3, -15], [15, 20, 15]];

this.safe_bb = [];
this.avoid_sphere = [];

this.segment_time = 3.0;
this.buffer_time = 20.0;
this.start_time = 0.0;
this.current_time = 0.0;

this.path_time = 0.0;
this.path_length = 0;

this.min_distance = 2.0;
this.max_distance = 40.0;

this.angle_min = 40;
this.angle_max = 180;
}


AutoCamera.prototype.inBounds = function(pt) {
  if (! (pt[0] > this.bounds[0][0] && pt[1] > this.bounds[0][1] && pt[2] > this.bounds[0][2] && pt[0] < this.bounds[1][0] && pt[1] < this.bounds[1][1] && pt[2] < this.bounds[1][2])) {
    return false;
  }

  for (var i = 0, iMax = this.avoid_sphere.length; i < iMax; i++) {
    var l = vec3.length(pt, this.avoid_sphere[i][0]);
    if (l < this.avoid_sphere[i][1]) {
      return false;
    }
  }

  return true;
};

AutoCamera.prototype.findNextNode = function(aNode, bNode) {
  var d = [this.bounds[1][0] - this.bounds[0][0], this.bounds[1][1] - this.bounds[0][1], this.bounds[1][2] - this.bounds[0][2]];

  var nextNodePos = [0, 0, 0];
  var randVector = [0, 0, 0];
  var l = 0.0;
  var loopkill = 0;
  var valid = false;

  do {
    randVector[0] = Math.random() - 0.5;
    randVector[1] = Math.random() - 0.5;
    randVector[2] = Math.random() - 0.5;

    randVector = vec3.normalize(randVector);

    var r = Math.random();

    l = (r * (this.max_distance - this.min_distance)) + this.min_distance;

    nextNodePos = vec3.add(bNode.position, vec3.multiply(randVector, l));

    valid = this.inBounds(nextNodePos);

    loopkill++;

    if (loopkill > 30) {
      nextNodePos = bNode.position;
      break;
    }
  } while (!valid);

  return nextNodePos;
};

AutoCamera.prototype.run = function(timer) {
  this.current_time = timer;

  if (this.path_time === 0.0) {
    this.path_time = this.current_time;

    this.camPath.setKey(enums.motion.POS, enums.motion.X, this.path_time, this.start_position[0]);
    this.camPath.setKey(enums.motion.POS, enums.motion.Y, this.path_time, this.start_position[1]);
    this.camPath.setKey(enums.motion.POS, enums.motion.Z, this.path_time, this.start_position[2]);
  }

  while (this.path_time < this.current_time + this.buffer_time) {
    this.path_time += this.segment_time;

    var tmpNodeA = new AutoCameraNode();
    var tmpNodeB = new AutoCameraNode();

    if (this.path_length) {
      this.camPath.apply(this.path_time - (this.segment_time * 2.0), tmpNodeA);
    }

    this.camPath.apply(this.path_time - this.segment_time, tmpNodeB);

    var nextPos = this.findNextNode(tmpNodeA, tmpNodeB);

    this.camPath.setKey(enums.motion.POS, enums.motion.X, this.path_time, nextPos[0]);
    this.camPath.setKey(enums.motion.POS, enums.motion.Y, this.path_time, nextPos[1]);
    this.camPath.setKey(enums.motion.POS, enums.motion.Z, this.path_time, nextPos[2]);

    this.path_length++;
  }

  var tmpNodeC = new AutoCameraNode();

  this.camPath.apply(timer, tmpNodeC);

  return tmpNodeC.position;
};


AutoCamera.prototype.addSafeBound = function(min, max) {
  this.safe_bb.push([min, max]);
};

AutoCamera.prototype.addAvoidSphere = function(center, radius) {
  this.avoid_sphere.push([center, radius]);
};

function Scene(width, height, fov, nearclip, farclip, octree) {
  this.frames = 0;

  this.sceneObjects = [];
  this.sceneObjectsByName = [];
  this.sceneObjectsById = [];
  this.lights = [];
  this.global_lights = [];
  this.dynamic_lights = [];
  this.pickables = [];
  this.octree = octree;
  this.skybox = null;
  this.camera = new Camera(width, height, fov, nearclip, farclip);
  this._workers = null;
  this.stats = [];
  this.collect_stats = false;
}

Scene.prototype.attachOctree = function(octree) {
  this.octree = octree;
  if (octree.init) {
    octree.init(this);
  } //if

  // rebind any active lights
  var tmpLights = this.lights;
  this.lights = [];
  
  for (var l = 0, lMax = tmpLights.length; l < lMax; l++) {
    this.bindLight(tmpLights[l]);
  } //for

  var objs = this.sceneObjects;
  if (this.octree !== undef) {
    for (var i=0, l=objs.length; i<l; ++i) {
      var obj = objs[i];
      if (obj.obj === null) { continue; }
      if (obj.id < 0) {
        obj.id = scene_object_uuid;
        ++scene_object_uuid;
      } //if
      this.sceneObjectsById[obj.id] = obj;
      AABB_reset(obj.octree_aabb, obj.position);
      this.octree.insert(obj);
      if (obj.octree_common_root === undefined || obj.octree_common_root === null) {
        log("!!", obj.name, "octree_common_root is null");
      } //if
    } //for
  } //if
  
  
} //Scene::attachOctree

Scene.prototype.setSkyBox = function(skybox) {
  this.skybox = skybox;
  //this.bindSceneObject(skybox.scene_object, null, false);
};

Scene.prototype.getSceneObject = function(name) {
  return this.sceneObjectsByName[name];
};

Scene.prototype.bindSceneObject = function(sceneObj, pickable, use_octree) {
  if (this.sceneObjects.indexOf(sceneObj)!=-1) {
    return;
  }
  
  this.sceneObjects.push(sceneObj);
  if (pickable !== undef) {
    if (pickable) {
      this.pickables.push(sceneObj);
    }
  }

  if (sceneObj.name !== null) {
    this.sceneObjectsByName[sceneObj.name] = sceneObj;
  }

  if (this.octree !== undef && (use_octree === undef || use_octree === "true")) {
    if (sceneObj.id < 0) {
      sceneObj.id = scene_object_uuid;
      ++scene_object_uuid;
    } //if
    this.sceneObjectsById[sceneObj.id] = sceneObj;
    AABB_reset(sceneObj.octree_aabb, sceneObj.position);
    this.octree.insert(sceneObj);
  } //if
  
  if (sceneObj.children) {
    for (var i = 0, iMax = sceneObj.children.length; i < iMax; i++) {
      this.bindSceneObject(sceneObj.children[i], pickable, use_octree);
    }
  }
};

Scene.prototype.removeLight = function(light) {
  var idx;
    
  if ((idx = this.lights.indexOf(light)) >= 0) {
    this.lights.splice(idx,1);
  }

  // TODO: Remove from Octrees as well (global_lights, dynamic_lights).
 
};

Scene.prototype.removeSceneObject = function(sceneObj) {
  var idx;
    
  if ((idx = this.sceneObjects.indexOf(sceneObj)) >= 0) {
    this.sceneObjects.splice(idx,1);
  }
  
  if (idx = this.pickables.indexOf(sceneObj) >= 0) {
    if (pickable) {
      this.pickables.push(sceneObj);
    }
  }

  if (sceneObj.name !== null) {
    if (this.sceneObjectsByName[sceneObj.name] !== undef) {
     delete(this.sceneObjectsByName[sceneObj.name]); 
    }
  }

  if (sceneObj.children) {
    for (var i = 0, iMax = sceneObj.children.length; i < iMax; i++) {
      this.removeSceneObject(sceneObj.children[i]);
    }
  }
  
  //todo: remove from octree!

/*  if (this.octree !== undef && (use_octree === undef || use_octree === "true")) {
    if (sceneObj.id < 0) {
      sceneObj.id = scene_object_uuid;
      ++scene_object_uuid;
    } //if
    this.sceneObjectsById[sceneObj.id] = sceneObj;
    AABB_reset(sceneObj.octree_aabb, sceneObj.position);
    this.octree.insert(sceneObj);
  } //if */
};


Scene.prototype.bindLight = function(lightObj, use_octree) {
  this.lights.push(lightObj);
  if (this.octree !== undef && (use_octree === undef || use_octree === "true")) {
    if (lightObj.method === enums.light.method.GLOBAL) {
      this.global_lights.push(lightObj);
    }
    else {
      if (lightObj.method === enums.light.method.DYNAMIC) {
        this.dynamic_lights.push(lightObj);
      } //if
      this.octree.insert_light(lightObj);
    } //if
  } //if
  
  this.lights=this.lights.sort(cubicvr_lightPackTypes);  
};

Scene.prototype.bindCamera = function(cameraObj) {
  this.camera = cameraObj;
};


Scene.prototype.evaluate = function(index) {
  var i,iMax;

  for (i = 0, iMax = this.sceneObjects.length; i < iMax; i++) {
    if (!(this.sceneObjects[i].motion)) {
      continue;
    }
    this.sceneObjects[i].motion.apply(index, this.sceneObjects[i]);
  }

  if (this.camera.motion !== null) {
    if (this.camera.targetSceneObject !== null) {
      this.camera.target = this.camera.targetSceneObject.position;
    }

    this.camera.motion.apply(index, this.camera);
  }

  for (var i = 0, iMax = this.lights.length; i < iMax; i++) {
    var l = this.lights[i];
     
    if (l.motion !== null) {
      l.motion.apply(index, l);
    }
  }
};

Scene.prototype.renderSceneObjectChildren = function(sceneObj, camera, lights) {
  var gl = GLCore.gl;
  var sflip = false;

  for (var i = 0, iMax = sceneObj.children.length; i < iMax; i++) {

    try {
      sceneObj.children[i].doTransform(sceneObj.tMatrix);
    }catch(e){break;}

      var obj = sceneObj.children[i].obj;

      if (obj) {
        if (sceneObj.children[i].scale[0] < 0) {
          sflip = !sflip;
        }
        if (sceneObj.children[i].scale[1] < 0) {
          sflip = !sflip;
        }
        if (sceneObj.children[i].scale[2] < 0) {
          sflip = !sflip;
        }

        if (sflip) {
          gl.cullFace(gl.FRONT);
        }


        cubicvr_renderObject(obj, camera, sceneObj.children[i].tMatrix, lights);

        if (sflip) {
          gl.cullFace(gl.BACK);
        }
      }

      if (sceneObj.children[i].children !== null) {
        this.renderSceneObjectChildren(sceneObj.children[i], camera, lights);
      }
  }
};

function cubicvr_lightPackTypes(a,b) {
  return a.light_type - b.light_type;
}

Scene.prototype.updateShadows = function() {
  var gl = GLCore.gl;
  var sflip = false;

  this.updateCamera();
  
  // Begin experimental shadowing code..
  var has_shadow = false;
  var dims = gl.getParameter(gl.VIEWPORT);
  for (var l = 0, lMax = this.lights.length; l<lMax; l++) {
    var light = this.lights[l];

    if (light.light_type == enums.light.type.SPOT_SHADOW) {
      has_shadow = true;
      light.shadowBegin();
      var lDepthPack = new CubicVR.Light(enums.light.type.DEPTH_PACK);

      // shadow state depth
      GLCore.shadow_near = light.dummyCam.nearclip;
      GLCore.shadow_far = light.dummyCam.farclip;

      for (var i = 0, iMax = this.sceneObjects.length; i < iMax; i++) {
        var scene_object = this.sceneObjects[i];
        if (scene_object.parent !== null) {
          continue;
        } //if

        if (scene_object.visible === false) {
          continue;
        } //if

        scene_object.doTransform();

        if (scene_object.obj !== null) {
          if (scene_object.scale[0] < 0) {
            sflip = !sflip;
          }
          if (scene_object.scale[1] < 0) {
            sflip = !sflip;
          }
          if (scene_object.scale[2] < 0) {
            sflip = !sflip;
          }

          if (sflip) {
            gl.cullFace(gl.FRONT);
          }

          cubicvr_renderObject(scene_object.obj, light.dummyCam, scene_object.tMatrix, [lDepthPack]);

          if (sflip) {
            gl.cullFace(gl.BACK);
          }

          sflip = false;
        } //if

        if (scene_object.children !== null) {
          this.renderSceneObjectChildren(scene_object, light.dummyCam, [lDepthPack]);
        } //if
      } //for i
      light.shadowEnd();
    } //if shadowed
  } // for l

  if (has_shadow) {
    gl.viewport(dims[0], dims[1], dims[2], dims[3]);  
  }

  // End experimental shadow code..  
}

Scene.prototype.updateCamera = function() {
  if (this.camera.manual===false)
  {    
    if (this.camera.targeted) {
      this.camera.lookat(this.camera.position[0], this.camera.position[1], this.camera.position[2], this.camera.target[0], this.camera.target[1], this.camera.target[2], 0, 1, 0);
    } else {
      this.camera.calcProjection();
    }
  }
  
  GLCore.depth_alpha_near = this.camera.nearclip;
  GLCore.depth_alpha_far = this.camera.farclip;
}

Scene.prototype.render = function() {
  ++this.frames;

  this.updateCamera();

  var gl = GLCore.gl;
  var frustum_hits;

  var use_octree = this.octree !== undef;
  var lights_rendered = 0;
  if (use_octree) {
    for (var i = 0, l = this.dynamic_lights.length; i < l; ++i) {
      var light = this.dynamic_lights[i];
      light.doTransform();
    } //for
    this.octree.reset_node_visibility();
    this.octree.cleanup();
    frustum_hits = this.octree.get_frustum_hits(this.camera);
    lights_rendered = frustum_hits.lights.length;
  } //if
  var sflip = false;
  var objects_rendered = 0;
  var lights_list = [];

  for (var i = 0, iMax = this.sceneObjects.length; i < iMax; i++) {

    var lights = this.lights;
    var scene_object = this.sceneObjects[i];
    if (scene_object.parent !== null) {
      continue;
    } //if

    scene_object.doTransform();

    if (use_octree) 
    {
      lights = [];
      if (scene_object.dirty && scene_object.obj !== null) {
        scene_object.adjust_octree();
      } //if

      if (scene_object.visible === false || (use_octree && (scene_object.ignore_octree || scene_object.drawn_this_frame === true || scene_object.culled === true))) {
        continue;
      } //if

      //lights = frustum_hits.lights;
      lights = scene_object.dynamic_lights;
      //lights = this.lights;
      
      lights = lights.concat(scene_object.static_lights);
      lights = lights.concat(this.global_lights);
      if (this.collect_stats) {
        lights_rendered = Math.max(lights.length, lights_rendered);
        if (lights_rendered === lights.length) {
          lights_list = lights;
        } //if
        ++objects_rendered;
      } //if

      if (lights.length === 0) {
        lights = [emptyLight];
      } else {
        lights = lights.sort(cubicvr_lightPackTypes)
      } //if

      scene_object.drawn_this_frame = true;
    }
    else if (scene_object.visible === false) {
      continue;
    } //if

    if (scene_object.obj !== null) {
      if (scene_object.scale[0] < 0) {
        sflip = !sflip;
      }
      if (scene_object.scale[1] < 0) {
        sflip = !sflip;
      }
      if (scene_object.scale[2] < 0) {
        sflip = !sflip;
      }

      if (sflip) {
        gl.cullFace(gl.FRONT);
      }
      
      cubicvr_renderObject(scene_object.obj, this.camera, scene_object.tMatrix, lights);

      if (sflip) {
        gl.cullFace(gl.BACK);
      }

      sflip = false;
    } //if
  
    if (scene_object.children !== null) {
      this.renderSceneObjectChildren(scene_object, this.camera, lights);
    } //if
  } //for
  
  if (this.collect_stats) {
    this.stats['objects.num_rendered'] = objects_rendered;
    this.stats['lights.num_rendered'] = lights_rendered;
    this.stats['lights.rendered'] = lights_list;
    this.stats['lights.num_global'] = this.global_lights.length;
    this.stats['lights.num_dynamic'] = this.dynamic_lights.length;
  } //if

  if (this.skybox !== null && this.skybox.ready === true) {
    gl.cullFace(gl.FRONT);
    var size = (this.camera.farclip * 2) / Math.sqrt(3.0);
    this.skybox.scene_object.position = [this.camera.position[0], this.camera.position[1], this.camera.position[2]];
    this.skybox.scene_object.scale = [size, size, size];
    this.skybox.scene_object.doTransform();
    cubicvr_renderObject(this.skybox.scene_object.obj, this.camera, this.skybox.scene_object.tMatrix, []);
    gl.cullFace(gl.BACK);
  } //if
};

Scene.prototype.bbRayTest = function(pos, ray, axisMatch) {
  var pt1, pt2;
  var selList = [];

  if (ray.length === 2) {
    ray = this.camera.unProject(ray[0], ray[1]);
  } else {
    ray = vec3.add(pos, ray);
  }

  pt1 = pos;
  pt2 = ray;

  for (var obj_i in this.pickables) {
    if (this.pickables.hasOwnProperty(obj_i)) {
      var obj = this.pickables[obj_i];
      if (obj.visible !== true) continue;

      var bb1, bb2;
      var aabb = obj.getAABB();
      bb1 = aabb[0];
      bb2 = aabb[1];
      
      var mindepth = 0.2;
      
      if (bb2[0]-bb1[0] < mindepth) {bb1[0] -= mindepth/2; bb2[0] += mindepth/2;}
      if (bb2[1]-bb1[1] < mindepth) {bb1[1] -= mindepth/2; bb2[1] += mindepth/2;}
      if (bb2[2]-bb1[2] < mindepth) {bb1[2] -= mindepth/2; bb2[2] += mindepth/2;}

      var center = vec3.multiply(vec3.add(bb1, bb2), 0.5);
      var testPt = vec3.get_closest_to(pt1, pt2, center);
      var testDist = vec3.length(vec3.subtract(testPt, center));

      var matches = 
      ((testPt[0] >= bb1[0] && testPt[0] <= bb2[0]) ? 1 : 0) + 
      ((testPt[1] >= bb1[1] && testPt[1] <= bb2[1]) ? 1 : 0) + 
      ((testPt[2] >= bb1[2] && testPt[2] <= bb2[2]) ? 1 : 0);

      if (matches >= axisMatch) {
        selList.push({dist:testDist, obj:obj});
      }
    }
  }

  if (selList.length) {
    selList.sort(function(a,b) { if (a.dist==b.dist) return 0; return (a.dist<b.dist) ?-1:1; });
  }

  return selList;
};

function cubicvr_loadMesh(meshUrl, prefix) {
  if (MeshPool[meshUrl] !== undef) {
    return MeshPool[meshUrl];
  }

  var i, j, p, iMax, jMax, pMax;

  var obj = new Mesh();
  var mesh = util.getXML(meshUrl);
  var pts_elem = mesh.getElementsByTagName("points");

  var pts_str = util.collectTextNode(pts_elem[0]);
  var pts = pts_str.split(" ");

  var texName, tex;

  for (i = 0, iMax = pts.length; i < iMax; i++) {
    pts[i] = pts[i].split(",");
    for (j = 0, jMax = pts[i].length; j < jMax; j++) {
      pts[i][j] = parseFloat(pts[i][j]);
    }
  }

  obj.addPoint(pts);

  var material_elem = mesh.getElementsByTagName("material");
  var mappers = [];


  for (i = 0, iMax = material_elem.length; i < iMax; i++) {
    var melem = material_elem[i];

    var matName = (melem.getElementsByTagName("name").length) ? (melem.getElementsByTagName("name")[0].firstChild.nodeValue) : null;
    var mat = new Material(matName);

    if (melem.getElementsByTagName("alpha").length) {
      mat.opacity = parseFloat(melem.getElementsByTagName("alpha")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("shininess").length) {
      mat.shininess = (parseFloat(melem.getElementsByTagName("shininess")[0].firstChild.nodeValue) / 100.0);
    }
    if (melem.getElementsByTagName("max_smooth").length) {
      mat.max_smooth = parseFloat(melem.getElementsByTagName("max_smooth")[0].firstChild.nodeValue);
    }

    if (melem.getElementsByTagName("color").length) {
      mat.color = util.floatDelimArray(melem.getElementsByTagName("color")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("ambient").length) {
      mat.ambient = util.floatDelimArray(melem.getElementsByTagName("ambient")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("diffuse").length) {
      mat.diffuse = util.floatDelimArray(melem.getElementsByTagName("diffuse")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("specular").length) {
      mat.specular = util.floatDelimArray(melem.getElementsByTagName("specular")[0].firstChild.nodeValue);
    }
    if (melem.getElementsByTagName("texture").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.COLOR);
    }

    if (melem.getElementsByTagName("texture_luminosity").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_luminosity")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.AMBIENT);
    }

    if (melem.getElementsByTagName("texture_normal").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_normal")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.NORMAL);
    }

    if (melem.getElementsByTagName("texture_specular").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_specular")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.SPECULAR);
    }

    if (melem.getElementsByTagName("texture_bump").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_bump")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.BUMP);
    }

    if (melem.getElementsByTagName("texture_envsphere").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_envsphere")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.ENVSPHERE);
    }

    if (melem.getElementsByTagName("texture_alpha").length) {
      texName = (prefix ? prefix : "") + melem.getElementsByTagName("texture_alpha")[0].firstChild.nodeValue;
      tex = (Texture_ref[texName] !== undef) ? Textures_obj[Texture_ref[texName]] : (new Texture(texName));
      mat.setTexture(tex, enums.texture.map.ALPHA);
    }

    var uvSet = null;

    if (melem.getElementsByTagName("uvmapper").length) {
      var uvm = new UVMapper();
      var uvelem = melem.getElementsByTagName("uvmapper")[0];
      var uvmType = "";

      if (uvelem.getElementsByTagName("type").length) {
        uvmType = melem.getElementsByTagName("type")[0].firstChild.nodeValue;

        switch (uvmType) {
        case "uv":
          break;
        case "planar":
          uvm.projection_mode = enums.uv.projection.PLANAR;
          break;
        case "cylindrical":
          uvm.projection_mode = enums.uv.projection.CYLINDRICAL;
          break;
        case "spherical":
          uvm.projection_mode = enums.uv.projection.SPHERICAL;
          break;
        case "cubic":
          uvm.projection_mode = enums.uv.projection.CUBIC;
          break;
        }
      }

      if (uvmType === "uv") {
        if (uvelem.getElementsByTagName("uv").length) {
          var uvText = util.collectTextNode(melem.getElementsByTagName("uv")[0]);

          uvSet = uvText.split(" ");

          for (j = 0, jMax = uvSet.length; j < jMax; j++) {
            uvSet[j] = util.floatDelimArray(uvSet[j]);
          }
        }
      }

      if (uvelem.getElementsByTagName("axis").length) {
        var uvmAxis = melem.getElementsByTagName("axis")[0].firstChild.nodeValue;

        switch (uvmAxis) {
        case "x":
          uvm.projection_axis = enums.uv.axis.X;
          break;
        case "y":
          uvm.projection_axis = enums.uv.axis.Y;
          break;
        case "z":
          uvm.projection_axis = enums.uv.axis.Z;
          break;
        }

      }

      if (melem.getElementsByTagName("center").length) {
        uvm.center = util.floatDelimArray(melem.getElementsByTagName("center")[0].firstChild.nodeValue);
      }
      if (melem.getElementsByTagName("rotation").length) {
        uvm.rotation = util.floatDelimArray(melem.getElementsByTagName("rotation")[0].firstChild.nodeValue);
      }
      if (melem.getElementsByTagName("scale").length) {
        uvm.scale = util.floatDelimArray(melem.getElementsByTagName("scale")[0].firstChild.nodeValue);
      }

      if (uvmType !== "" && uvmType !== "uv") {
        mappers.push([uvm, mat]);
      }
    }


    var seglist = null;
    var triangles = null;

    if (melem.getElementsByTagName("segments").length) {
      seglist = util.intDelimArray(util.collectTextNode(melem.getElementsByTagName("segments")[0]), " ");
    }
    if (melem.getElementsByTagName("triangles").length) {
      triangles = util.intDelimArray(util.collectTextNode(melem.getElementsByTagName("triangles")[0]), " ");
    }


    if (seglist === null) {
      seglist = [0, parseInt((triangles.length) / 3, 10)];
    }

    var ofs = 0;

    if (triangles.length) {
      for (p = 0, pMax = seglist.length; p < pMax; p += 2) {
        var currentSegment = seglist[p];
        var totalPts = seglist[p + 1] * 3;

        obj.setSegment(currentSegment);
        obj.setFaceMaterial(mat);

        for (j = ofs, jMax = ofs + totalPts; j < jMax; j += 3) {
          var newFace = obj.addFace([triangles[j], triangles[j + 1], triangles[j + 2]]);
          if (uvSet) {
            obj.faces[newFace].setUV([uvSet[j], uvSet[j + 1], uvSet[j + 2]]);
          }
        }

        ofs += totalPts;
      }
    }
  }

  obj.calcNormals();

  for (i = 0, iMax = mappers.length; i < iMax; i++) {
    mappers[i][0].apply(obj, mappers[i][1]);
  }

  obj.compile();

  MeshPool[meshUrl] = obj;

  return obj;
}







function cubicvr_loadScene(sceneUrl, model_prefix, image_prefix) {
  if (model_prefix === undef) {
    model_prefix = "";
  }
  if (image_prefix === undef) {
    image_prefix = "";
  }

  var obj = new Mesh();
  var scene = util.getXML(sceneUrl);

  var sceneOut = new Scene();

  var parentingSet = [];

  var sceneobjs = scene.getElementsByTagName("sceneobjects");

  var tempNode;

  var position, rotation, scale;

  //  var pts_str = util.collectTextNode(pts_elem[0]);
  for (var i = 0, iMax = sceneobjs[0].childNodes.length; i < iMax; i++) {
    var sobj = sceneobjs[0].childNodes[i];

    if (sobj.tagName === "sceneobject") {

      var name = "unnamed";
      var parent = "";
      var model = "";

      tempNode = sobj.getElementsByTagName("name");
      if (tempNode.length) {
        name = util.collectTextNode(tempNode[0]);
      }

      tempNode = sobj.getElementsByTagName("parent");
      if (tempNode.length) {
        parent = util.collectTextNode(tempNode[0]);
      }

      tempNode = sobj.getElementsByTagName("model");
      if (tempNode.length) {
        model = util.collectTextNode(tempNode[0]);
      }

      position = null;
      rotation = null;
      scale = null;

      tempNode = sobj.getElementsByTagName("position");
      if (tempNode.length) {
        position = tempNode[0];
      }

      tempNode = sobj.getElementsByTagName("rotation");
      if (tempNode.length) {
        rotation = tempNode[0];
      }

      tempNode = sobj.getElementsByTagName("scale");
      if (tempNode.length) {
        scale = tempNode[0];
      }

      obj = null;

      if (model !== "") {
        obj = cubicvr_loadMesh(model_prefix + model, image_prefix);
      }

      var sceneObject = new SceneObject(obj, name);

      if (cubicvr_isMotion(position)) {
        if (!sceneObject.motion) {
          sceneObject.motion = new Motion();
        }
        cubicvr_nodeToMotion(position, enums.motion.POS, sceneObject.motion);
      } else if (position) {
        sceneObject.position = util.floatDelimArray(util.collectTextNode(position));
      }

      if (cubicvr_isMotion(rotation)) {
        if (!sceneObject.motion) {
          sceneObject.motion = new Motion();
        }
        cubicvr_nodeToMotion(rotation, enums.motion.ROT, sceneObject.motion);
      } else {
        sceneObject.rotation = util.floatDelimArray(util.collectTextNode(rotation));
      }

      if (cubicvr_isMotion(scale)) {
        if (!sceneObject.motion) {
          sceneObject.motion = new Motion();
        }
        cubicvr_nodeToMotion(scale, enums.motion.SCL, sceneObject.motion);
      } else {
        sceneObject.scale = util.floatDelimArray(util.collectTextNode(scale));

      }

      sceneOut.bindSceneObject(sceneObject);

      if (parent !== "") {
        parentingSet.push([sceneObject, parent]);
      }
    }
  }

  for (var j in parentingSet) {
    if (parentingSet.hasOwnProperty(j)) {
      sceneOut.getSceneObject(parentingSet[j][1]).bindChild(parentingSet[j][0]);
    }
  }

  var camera = scene.getElementsByTagName("camera");

  if (camera.length) {
    position = null;
    rotation = null;

    var target = "";

    tempNode = camera[0].getElementsByTagName("name");

    var cam = sceneOut.camera;

    var fov = null;

    if (tempNode.length) {
      target = tempNode[0].firstChild.nodeValue;
    }

    tempNode = camera[0].getElementsByTagName("target");
    if (tempNode.length) {
      target = tempNode[0].firstChild.nodeValue;
    }

    if (target !== "") {
      cam.targetSceneObject = sceneOut.getSceneObject(target);
    }

    tempNode = camera[0].getElementsByTagName("position");
    if (tempNode.length) {
      position = tempNode[0];
    }

    tempNode = camera[0].getElementsByTagName("rotation");
    if (tempNode.length) {
      rotation = tempNode[0];
    }

    tempNode = camera[0].getElementsByTagName("fov");
    if (tempNode.length) {
      fov = tempNode[0];
    }

    if (cubicvr_isMotion(position)) {
      if (!cam.motion) {
        cam.motion = new Motion();
      }
      cubicvr_nodeToMotion(position, enums.motion.POS, cam.motion);
    } else if (position) {
      cam.position = util.floatDelimArray(position.firstChild.nodeValue);
    }

    if (cubicvr_isMotion(rotation)) {
      if (!cam.motion) {
        cam.motion = new Motion();
      }
      cubicvr_nodeToMotion(rotation, enums.motion.ROT, cam.motion);
    } else if (rotation) {
      cam.rotation = util.floatDelimArray(rotation.firstChild.nodeValue);
    }

    if (cubicvr_isMotion(fov)) {
      if (!cam.motion) {
        cam.motion = new Motion();
      }
      cubicvr_nodeToMotion(fov, enums.motion.FOV, cam.motion);
    } else if (fov) {
      cam.fov = parseFloat(fov.firstChild.nodeValue);
    }

  }


  return sceneOut;
}


function RenderBuffer(width, height, depth_enabled) {
  this.createBuffer(width, height, depth_enabled);
}

RenderBuffer.prototype.createBuffer = function(width, height, depth_enabled) {
  this.fbo = null;
  this.depth = null;
  this.texture = null;
  this.width = parseInt(width, 10);
  this.height = parseInt(height, 10);

  var w = this.sizeParam(width);
  var h = this.sizeParam(height);

  var gl = GLCore.gl;

  this.fbo = gl.createFramebuffer();

  if (depth_enabled) {
    this.depth = gl.createRenderbuffer();
  }

  // configure fbo
  gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);

  if (depth_enabled) {
    gl.bindRenderbuffer(gl.RENDERBUFFER, this.depth);

    if (navigator.appVersion.indexOf("Windows")!==-1 || 1)
    {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depth); 
    }
    else
    {
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.depth); 
    }
  }


  // if (depth_enabled) {
  //   gl.bindRenderbuffer(gl.RENDERBUFFER, this.depth);
  //   gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
  // }

  //  GL_DEPTH_COMPONENT32 0x81A7
  //  if (depth_enabled) { gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT, w, h); }
  // if (depth_enabled) {
  //   gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depth);
  // }



  // init texture
  this.texture = new Texture();
  gl.bindTexture(gl.TEXTURE_2D, Textures[this.texture.tex_id]);

  // configure texture params
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  // clear buffer
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, Textures[this.texture.tex_id], 0);

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

RenderBuffer.prototype.destroyBuffer = function() {
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteRenderbuffer(this.depth);
  gl.deleteFramebuffer(this.fbo);
  gl.deleteTexture(Textures[this.texture.tex_id]);
  Textures[this.texture.tex_id] = null;
};

RenderBuffer.prototype.sizeParam = function(t) {
  return t;
  // var s = 32;
  //
  // while (t > s) s *= 2;
  //
  // return s;
};


RenderBuffer.prototype.use = function() {
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
  //  if (this.depth !== null) { gl.bindRenderbuffer(gl.RENDERBUFFER, this.depth); }
  //  gl.viewport(0, 0, this.width, this.height);
};



function PostProcessFX(width, height) {
  this.bloom = true;

  this.renderBuffer = new RenderBuffer(width, height, true);
  this.blurBuffer = new RenderBuffer(width, height, false);
  this.bloomBuffer = new RenderBuffer(parseInt(width / 6, 10), parseInt(height / 6, 10), false);

  this.copyShader = new Shader("attribute vec3 aVertex;\n" + "attribute vec2 aTex;\n" + "varying vec2 vTex;\n" + "void main(void)\n" + "{\n" + "vTex = aTex;\n" + "vec4 vPos = vec4(aVertex.xyz,1.0);\n" + "gl_Position = vPos;\n" + "}\n", "#ifdef GL_ES\nprecision highp float;\n#endif\n" + "uniform sampler2D srcTex;\n" + "varying vec2 vTex;\n" + "void main(void)\n" + "{\n" + "gl_FragColor = texture2D(srcTex, vTex);\n" + "}\n");


  this.copyShader.use();
  this.copyShader.addUVArray("aTex");
  this.copyShader.addVertexArray("aVertex");
  this.copyShader.addInt("srcTex", 0);

  this.fsQuad = this.makeFSQuad(width, height);

  this.bloomShader = new Shader("attribute vec3 aVertex;\n" + "attribute vec2 aTex;\n" + "varying vec2 vTex;\n" + "void main(void)\n" + "{\n" + "vTex = aTex;\n" + "vec4 vPos = vec4(aVertex.xyz,1.0);\n" + "gl_Position = vPos;\n" + "}\n",

  "#ifdef GL_ES\nprecision highp float;\n#endif\n" + "uniform sampler2D srcTex;\n" + "uniform vec3 texel_ofs;\n" + "varying vec2 vTex;\n" + "vec3 rangeValHDR(vec3 src)\n" + "{\n" + "return (src.r>0.90||src.g>0.90||src.b>0.90)?(src):vec3(0.0,0.0,0.0);\n" + "}\n" + "vec4 hdrSample(float rad)\n" + "{\n" + "vec3 accum;\n" + "float radb = rad*0.707106781;\n" + "accum =  rangeValHDR(texture2D(srcTex, vec2(vTex.s+texel_ofs.x*rad,  vTex.t)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s,          vTex.t+texel_ofs.y*rad)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s-texel_ofs.x*rad,  vTex.t)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s,          vTex.t-texel_ofs.y*rad)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s+texel_ofs.x*radb, vTex.t+texel_ofs.y*radb)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s-texel_ofs.x*radb, vTex.t-texel_ofs.y*radb)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s+texel_ofs.x*radb, vTex.t-texel_ofs.y*radb)).rgb);\n" + "accum += rangeValHDR(texture2D(srcTex, vec2(vTex.s-texel_ofs.x*radb, vTex.t+texel_ofs.y*radb)).rgb);\n" + "accum /= 8.0;\n" + "return vec4(accum,1.0);\n" + "}\n" + "void main(void)\n" + "{\n" + "vec4 color;\n" + "color = hdrSample(2.0);\n" + "color += hdrSample(8.0);\n" + "color += hdrSample(12.0);\n" + "gl_FragColor = color/2.0;\n" + "}\n");

  this.bloomShader.use();
  this.bloomShader.addUVArray("aTex");
  this.bloomShader.addVertexArray("aVertex");
  this.bloomShader.addInt("srcTex", 0);
  this.bloomShader.addVector("texel_ofs");
  this.bloomShader.setVector("texel_ofs", [1.0 / this.renderBuffer.sizeParam(width), 1.0 / this.renderBuffer.sizeParam(height), 0]);

  this.fsQuadBloom = this.makeFSQuad(this.bloomBuffer.width, this.bloomBuffer.height);

  this.blurShader = new Shader("attribute vec3 aVertex;\n" + "attribute vec2 aTex;\n" + "varying vec2 vTex;\n" + "void main(void)\n" + "{\n" + "vTex = aTex;\n" + "vec4 vPos = vec4(aVertex.xyz,1.0);\n" + "gl_Position = vPos;\n" + "}\n", "#ifdef GL_ES\nprecision highp float;\n#endif\n" + "uniform sampler2D srcTex;\n" + "varying vec2 vTex;\n" + "uniform float opacity;\n" + "void main(void)\n" + "{\n" + "gl_FragColor = vec4(texture2D(srcTex, vTex).rgb, opacity);\n" + "}\n");

  this.blurShader.use();
  this.blurShader.addUVArray("aTex");
  this.blurShader.addVertexArray("aVertex");
  this.blurShader.addInt("srcTex", 0);
  this.blurShader.addFloat("opacity");
  this.blurOpacity = 0.1;


  var gl = GLCore.gl;

  this.blurBuffer.use();
  gl.clear(gl.COLOR_BUFFER_BIT);
  this.end();
}

PostProcessFX.prototype.resize = function(width, height) {
  this.renderBuffer.destroyBuffer();
  this.blurBuffer.destroyBuffer();
  this.bloomBuffer.destroyBuffer();
  this.renderBuffer.createBuffer(width, height, true);
  this.blurBuffer.createBuffer(width, height, false);
  this.bloomBuffer.createBuffer(parseInt(width / 6, 10), parseInt(height / 6, 10), false);

  this.bloomShader.use();
  this.bloomShader.setVector("texel_ofs", [1.0 / this.renderBuffer.sizeParam(width), 1.0 / this.renderBuffer.sizeParam(height), 0]);

  this.destroyFSQuad(this.fsQuad);
  this.fsQuad = this.makeFSQuad(width, height);
  this.destroyFSQuad(this.fsQuadBloom);
  this.fsQuadBloom = this.makeFSQuad(this.bloomBuffer.width, this.bloomBuffer.height);
};

PostProcessFX.prototype.begin = function() {
  this.renderBuffer.use();
};

PostProcessFX.prototype.end = function() {
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  //  if (this.depth !== null) { gl.bindRenderbuffer(gl.RENDERBUFFER, null); }
};

PostProcessFX.prototype.makeFSQuad = function(width, height) {
  var gl = GLCore.gl;
  var fsQuad = []; // intentional empty object
  // var w = this.renderBuffer.sizeParam(width);
  // var h = this.renderBuffer.sizeParam(height);

  // var uscale = (width / w);
  // var vscale = (height / h);

  var uscale, vscale; 
  
  uscale=vscale=1;

  // fsQuad.addPoint([[-1,-1,0],[1, -1, 0],[1, 1, 0],[-1, 1, 0]]);
  // var faceNum = fsQuad.addFace([0,1,2,3]);
  // fsQuad.faces[faceNum].setUV([[0, 0],[uscale, 0],[uscale, vscale],[0, vscale]]);
  // fsQuad.triangulateQuads();
  // fsQuad.calcNormals();
  // fsQuad.compile();
  fsQuad.vbo_points = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0]);
  fsQuad.vbo_uvs = new Float32Array([0, 0, uscale, 0, uscale, vscale, 0, vscale, 0, 0, uscale, vscale]);

  fsQuad.gl_points = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, fsQuad.gl_points);
  gl.bufferData(gl.ARRAY_BUFFER, fsQuad.vbo_points, gl.STATIC_DRAW);

  fsQuad.gl_uvs = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, fsQuad.gl_uvs);
  gl.bufferData(gl.ARRAY_BUFFER, fsQuad.vbo_uvs, gl.STATIC_DRAW);


  return fsQuad;
};

PostProcessFX.prototype.destroyFSQuad = function(fsQuad) {
  var gl = GLCore.gl;

  gl.deleteBuffer(fsQuad.gl_points);
  gl.deleteBuffer(fsQuad.gl_uvs);
};

PostProcessFX.prototype.renderFSQuad = function(shader, fsq) {
  var gl = GLCore.gl;

  shader.use();

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  gl.bindBuffer(gl.ARRAY_BUFFER, fsq.gl_points);
  gl.vertexAttribPointer(shader.aVertex, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribPointer(shader.aVertex);
  gl.bindBuffer(gl.ARRAY_BUFFER, fsq.gl_uvs);
  gl.vertexAttribPointer(shader.aTex, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribPointer(shader.aTex);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

};

PostProcessFX.prototype.render = function() {
  var gl = GLCore.gl;

  gl.disable(gl.DEPTH_TEST);

  this.renderBuffer.texture.use(gl.TEXTURE0);
  this.copyShader.use();
  this.copyShader.setInt("srcTex", 0);

  this.renderFSQuad(this.copyShader, this.fsQuad);

  if (this.blur) {
    this.renderBuffer.texture.use(gl.TEXTURE0);
    this.blurShader.use();
    this.blurShader.setInt("srcTex", 0);
    this.blurShader.setFloat("opacity", this.blurOpacity);

    this.blurBuffer.use();
    gl.enable(gl.BLEND);
    gl.depthMask(0);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    this.renderFSQuad(this.blurShader, this.fsQuad);
    gl.disable(gl.BLEND);
    gl.depthMask(1);
    gl.blendFunc(gl.ONE, gl.ONE);
    this.end();

    this.blurBuffer.texture.use(gl.TEXTURE0);

    this.blurShader.setFloat("opacity", 0.5);

    gl.enable(gl.BLEND);
    gl.depthMask(0);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    this.renderFSQuad(this.blurShader, this.fsQuad);

    gl.disable(gl.BLEND);
    gl.depthMask(1);
    gl.blendFunc(gl.ONE, gl.ONE);
  }

  if (this.bloom) {
    this.renderBuffer.texture.use(gl.TEXTURE0);

    gl.viewport(0, 0, this.bloomBuffer.width, this.bloomBuffer.height);

    this.bloomShader.use();
    this.bloomShader.setInt("srcTex", 0);

    this.bloomBuffer.use();
    this.renderFSQuad(this.bloomShader, this.fsQuad);
    this.end();

    this.bloomBuffer.texture.use(gl.TEXTURE0);
    this.copyShader.use();
    this.copyShader.setInt("srcTex", 0);

    gl.viewport(0, 0, this.renderBuffer.width, this.renderBuffer.height);

    gl.enable(gl.BLEND);
    gl.depthMask(0);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);

    this.renderFSQuad(this.copyShader, this.fsQuadBloom);

    gl.disable(gl.BLEND);
    gl.depthMask(1);
    gl.blendFunc(gl.ONE, gl.ONE);

  }

  gl.enable(gl.DEPTH_TEST);
};

/*
    PostProcessShader:
    
    shaderInfo
    {
      enabled: enabled (default true)
      shader_vertex: id or url for vertex shader
      shader_fragment: id or url for fragment shader
      outputMode: method of output for this shader
      init: function to perform to initialize shader
      onresize: function to perform on resize; params ( shader, width, height )
      onupdate: function to perform on update; params ( shader )
      outputDivisor: use custom output buffer size, divisor of (outputDivisor) eg. 1 (default) = 1024x768, 2 = 512x384, 3 = 256x192
    }

  */

var postProcessDivisorBuffers = [];
var postProcessDivisorQuads = [];

function PostProcessShader(shaderInfo) {
  if (shaderInfo.shader_vertex === undef) {
    return null;
  }
  if (shaderInfo.shader_fragment === undef) {
    return null;
  }

  this.outputMode = (shaderInfo.outputMode === undef) ? enums.post.output.REPLACE : shaderInfo.outputMode;
  this.onresize = (shaderInfo.onresize === undef) ? null : shaderInfo.onresize;
  this.onupdate = (shaderInfo.onupdate === undef) ? null : shaderInfo.onupdate;
  this.init = (shaderInfo.init === undef) ? null : shaderInfo.init;
  this.enabled = (shaderInfo.enabled === undef) ? true : shaderInfo.enabled;
  this.outputDivisor = (shaderInfo.outputDivisor === undef) ? 1 : shaderInfo.outputDivisor;

  this.shader = new Shader(shaderInfo.shader_vertex, shaderInfo.shader_fragment);
  this.shader.use();

  // set defaults
  this.shader.addUVArray("aTex");
  this.shader.addVertexArray("aVertex");
  this.shader.addInt("srcTex", 0);
  this.shader.addInt("captureTex", 1);
  this.shader.addVector("texel");

  if (this.init !== null) {
    this.init(this.shader);
  }
}

/* New post-process shader chain -- to replace postProcessFX */

function PostProcessChain(width, height, accum) {
  var gl = GLCore.gl;

  this.width = width;
  this.height = height;
  this.accum = (accum === undef)?false:true;
  this.vTexel = [1.0 / this.width, 1.0 / this.height, 0];

  // buffers
  this.captureBuffer = new RenderBuffer(width, height, true);
  this.bufferA = new RenderBuffer(width, height, false);
  this.bufferB = new RenderBuffer(width, height, false);
  this.bufferC = new RenderBuffer(width, height, false);

  this.accumOpacity = 1.0;
  this.accumIntensity = 0.3;
  
  if (this.accum) {
    this.accumBuffer = new RenderBuffer(width, height, false);
    this.accumBuffer.use();

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    this.blur_shader = new PostProcessShader({
      shader_vertex: ["attribute vec3 aVertex;",
                      "attribute vec2 aTex;",
                      "varying vec2 vTex;",
                      "void main(void)",
                      "{",
                        "vTex = aTex;",
                        "vec4 vPos = vec4(aVertex.xyz,1.0);",
                        "gl_Position = vPos;",
                        "}"].join("\n"),
      shader_fragment: ["#ifdef GL_ES",
                        "precision highp float;",
                        "#endif",
                        "uniform sampler2D srcTex;",
                        "varying vec2 vTex;",
                        "uniform float opacity;",
                        "void main(void)",
                        "{ gl_FragColor = vec4(texture2D(srcTex, vTex).rgb, opacity);",
                        "}"].join("\n"),
      init: function(shader) {
        shader.addFloat("opacity");
        shader.setFloat("opacity",1.0);
      }});
  }

  this.bufferA.use();

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  this.bufferB.use();

  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  this.end();

  // quad
  this.fsQuad = this.makeFSQuad(this.width, this.height);

  this.shaders = [];

  this.copy_shader = new PostProcessShader({
    shader_vertex: ["attribute vec3 aVertex;",
                "attribute vec2 aTex;",
                "varying vec2 vTex;",
                "void main(void) {",
                  "vTex = aTex;",
                  "vec4 vPos = vec4(aVertex.xyz,1.0);",
                  "gl_Position = vPos;",
                "}"].join("\n"),
    shader_fragment: [
      "#ifdef GL_ES",
      "precision highp float;",
      "#endif",
      "uniform sampler2D srcTex;",
      "varying vec2 vTex;",
      "void main(void) {",
        "gl_FragColor = texture2D(srcTex, vTex);",
      "}"].join("\n")
  });

  this.resize(width, height);
}

PostProcessChain.prototype.setBlurOpacity = function (opacity)
{  
  this.accumOpacity = opacity;
}

PostProcessChain.prototype.setBlurIntensity = function (intensity)
{  
  this.accumIntensity = intensity;
}


PostProcessChain.prototype.makeFSQuad = makeFSQuad = function(width, height) {
  var gl = GLCore.gl;
  var fsQuad = []; // intentional empty object
  var w = width;
  var h = height;

  var uscale = (width / w);
  var vscale = (height / h);

  fsQuad.vbo_points = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0]);
  fsQuad.vbo_uvs = new Float32Array([0, 0, uscale, 0, uscale, vscale, 0, vscale, 0, 0, uscale, vscale]);

  fsQuad.gl_points = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, fsQuad.gl_points);
  gl.bufferData(gl.ARRAY_BUFFER, fsQuad.vbo_points, gl.STATIC_DRAW);

  fsQuad.gl_uvs = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, fsQuad.gl_uvs);
  gl.bufferData(gl.ARRAY_BUFFER, fsQuad.vbo_uvs, gl.STATIC_DRAW);

  return fsQuad;
};

PostProcessChain.prototype.destroyFSQuad = destroyFSQuad = function(fsQuad) {
  var gl = GLCore.gl;

  gl.deleteBuffer(fsQuad.gl_points);
  gl.deleteBuffer(fsQuad.gl_uvs);
};

PostProcessChain.prototype.renderFSQuad = renderFSQuad = function(shader, fsq) {
  var gl = GLCore.gl;

  shader.use();

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  gl.bindBuffer(gl.ARRAY_BUFFER, fsq.gl_points);
  gl.vertexAttribPointer(shader.aVertex, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(shader.aVertex);
  gl.bindBuffer(gl.ARRAY_BUFFER, fsq.gl_uvs);
  gl.vertexAttribPointer(shader.aTex, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(shader.aTex);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  gl.drawArrays(gl.TRIANGLES, 0, 6);

};


PostProcessChain.prototype.addShader = function(shader) {
  this.shaders[this.shaders.length] = shader;
  shader.shader.use();
  shader.shader.setVector("texel", this.vTexel);  

  if (shader.outputDivisor && shader.outputDivisor != 1)
  {
    if (postProcessDivisorBuffers[shader.outputDivisor] === undef)
    
    var divw = parseInt(this.width/shader.outputDivisor);
    var divh = parseInt(this.height/shader.outputDivisor);
    
    postProcessDivisorBuffers[shader.outputDivisor] = new RenderBuffer(divw, divh, false);  
    postProcessDivisorQuads[shader.outputDivisor] = this.makeFSQuad(divw, divh);
  
  }
};

PostProcessChain.prototype.resize = function(width, height) {
  var gl = GLCore.gl;

  this.width = width;
  this.height = height;

  this.vTexel = [1.0 / this.width, 1.0 / this.height, 0];

  this.captureBuffer.destroyBuffer();
  this.captureBuffer.createBuffer(this.width, this.height, true);

  this.bufferA.destroyBuffer();
  this.bufferA.createBuffer(this.width, this.height, false);

  this.bufferB.destroyBuffer();
  this.bufferB.createBuffer(this.width, this.height, false);

  this.bufferC.destroyBuffer();
  this.bufferC.createBuffer(this.width, this.height, false);

  if (this.accum) {
    this.accumBuffer.destroyBuffer();
    this.accumBuffer.createBuffer(this.width, this.height, false);
    this.accumBuffer.use();

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }

  for (var p in postProcessDivisorBuffers)
  {
    var divw = parseInt(this.width/p);
    var divh = parseInt(this.height/p);

    postProcessDivisorBuffers[p].destroyBuffer();
    postProcessDivisorBuffers[p].createBuffer(divw, divh, false); 

    this.destroyFSQuad(postProcessDivisorQuads[p]);
    postProcessDivisorQuads[p] = this.makeFSQuad(divw, divh);            
  }

  this.inputBuffer = this.bufferA;
  this.outputBuffer = this.bufferB;

  for (var i = 0, iMax = this.shaders.length; i < iMax; i++) {
    this.shaders[i].shader.use();
    this.shaders[i].shader.setVector("texel", this.vTexel);
    if (this.shaders[i].onresize !== null) {
      this.shaders[i].onresize(this.shaders[i].shader, this.width, this.height);
    }
  }

  this.destroyFSQuad(this.fsQuad);
  this.fsQuad = this.makeFSQuad(this.width, this.height);
};

PostProcessChain.prototype.swap = function() {
  var t = this.inputBuffer;

  this.inputBuffer = this.outputBuffer;
  this.outputBuffer = t;
};

PostProcessChain.prototype.begin = function() {
  this.captureBuffer.use();
};

PostProcessChain.prototype.end = function() {
  var gl = GLCore.gl;

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
};

PostProcessChain.prototype.render = function() {
  var gl = GLCore.gl;

  var initBuffer = null;

  this.captureBuffer.texture.use(gl.TEXTURE1);

  this.outputBuffer.use();
  this.captureBuffer.texture.use(gl.TEXTURE0);
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  this.renderFSQuad(this.copy_shader.shader, this.fsQuad);
  this.end();

  var c = 0;
  for (var i = 0, iMax = this.shaders.length; i < iMax; i++) {
    var s = this.shaders[i];
    if (!s.enabled) {
      continue;
    }
    this.swap();
    this.inputBuffer.texture.use(gl.TEXTURE0);

    var o_mode = s.outputMode;
    //switch (s.outputMode) {
    if (o_mode === enums.post.output.REPLACE) {
    //case enums.post.output.REPLACE:
      if (s.outputDivisor !== 1) {
        postProcessDivisorBuffers[s.outputDivisor].use();
      }
      else {
        this.outputBuffer.use();
      } //if
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      //break;
    }
    else if (o_mode === enums.post.output.ADD || o_mode === enums.post.output.BLEND) {
    //case enums.post.output.ADD:
    //case enums.post.output.BLEND:
      if (s.outputDivisor !== 1) {
        postProcessDivisorBuffers[s.outputDivisor].use();
      }
      else {
        this.bufferC.use();        
      } //if

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      //break;
    } //if

    if (s.onupdate !== null) {
      s.shader.use();
      s.onupdate(s.shader);
    } //if

    if (s.outputDivisor !== 1) {
      gl.viewport(0, 0, postProcessDivisorBuffers[s.outputDivisor].width, postProcessDivisorBuffers[s.outputDivisor].height);

      this.renderFSQuad(s.shader, postProcessDivisorQuads[s.outputDivisor]);

      if (s.outputMode === enums.post.output.REPLACE) {
        this.outputBuffer.use();

        postProcessDivisorBuffers[s.outputDivisor].texture.use(gl.TEXTURE0);

        gl.viewport(0, 0, this.width, this.height);

        this.renderFSQuad(this.copy_shader.shader, this.fsQuad);
      }
      else {
        gl.viewport(0, 0, this.width, this.height);        
      } //if
    }
    else {
      this.renderFSQuad(s.shader, this.fsQuad);      
    } //if

    //switch (s.outputMode) {
    
    //case enums.post.output.REPLACE:
    //  break;
    if (o_mode === enums.post.output.BLEND) {
    //case enums.post.output.BLEND:
      this.swap();
      this.outputBuffer.use();

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

      this.inputBuffer.texture.use(gl.TEXTURE0);

      if (s.outputDivisor !== 1) {
        postProcessDivisorBuffers[s.outputDivisor].texture.use(gl.TEXTURE0);
      }
      else {
        this.bufferC.texture.use(gl.TEXTURE0);
      } //if

      this.renderFSQuad(this.copy_shader.shader, this.fsQuad);

      gl.disable(gl.BLEND);
      //break;
    }
    else if (o_mode === enums.post.output.ADD) {
    //case enums.post.output.ADD:
      this.swap();
      this.outputBuffer.use();

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE);

      if (s.outputDivisor !== 1) {
        postProcessDivisorBuffers[s.outputDivisor].texture.use(gl.TEXTURE0);
      }
      else {
        this.bufferC.texture.use(gl.TEXTURE0);
      } //if

      this.renderFSQuad(this.copy_shader.shader, this.fsQuad);

      gl.disable(gl.BLEND);
      //break;
    } //if

    this.end();
    c++;
  } //for

  if (c === 0) {
    this.captureBuffer.texture.use(gl.TEXTURE0);
  } else {
    this.outputBuffer.texture.use(gl.TEXTURE0);
  } //if

  if (this.accum && this.accumOpacity !== 1.0)
  {
    this.blur_shader.shader.use();
    this.blur_shader.shader.setFloat("opacity",this.accumOpacity);

    this.accumBuffer.use();

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);

    this.renderFSQuad(this.blur_shader.shader, this.fsQuad);

    this.end();

    gl.disable(gl.BLEND);

    this.renderFSQuad(this.copy_shader.shader, this.fsQuad);

    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
    
    this.blur_shader.shader.use();
    this.blur_shader.shader.setFloat("opacity",this.accumIntensity);
    
    this.accumBuffer.texture.use(gl.TEXTURE0);
    
    this.renderFSQuad(this.blur_shader.shader, this.fsQuad);
    
    gl.disable(gl.BLEND);
  }
  else
  {
    this.renderFSQuad(this.copy_shader.shader, this.fsQuad);    
  }

};



  function NormalMapGen(inTex,width,height)
  {
    var gl = GLCore.gl;

    this.width = width;
    this.height = height;
    this.srcTex = inTex;      
    this.outTex = new RenderBuffer(width,height);
    
     var tw = width, th = height;

     var isPOT = true;

     if (tw===1||th===1) {
       isPOT = false;
     } else {
       if (tw !== 1) { while ((tw % 2) === 0) { tw /= 2; } }
       if (th !== 1) { while ((th % 2) === 0) { th /= 2; } }
       if (tw > 1) { isPOT = false; }
       if (th > 1) { isPOT = false; }       
     }

      var vTexel = [1.0/width,1.0/height,0];

    // buffers
    this.outputBuffer = new RenderBuffer(width,height,false);

    // quads
    this.fsQuad = PostProcessChain.prototype.makeFSQuad(width,height);
    
    var vs = ["attribute vec3 aVertex;",
    "attribute vec2 aTex;",
    "varying vec2 vTex;",
    "void main(void)",
    "{",
    "  vTex = aTex;",
    "  vec4 vPos = vec4(aVertex.xyz,1.0);",
    "  gl_Position = vPos;",
    "}"].join("\n");
  

    // simple convolution test shader
    shaderNMap = new Shader(vs,      
    ["#ifdef GL_ES",
    "precision highp float;",
    "#endif",
    "uniform sampler2D srcTex;",
    "varying vec2 vTex;",
    "uniform vec3 texel;",
    "void main(void)",
    "{",
    " vec3 color;",
    " color.r = (texture2D(srcTex,vTex + vec2(texel.x,0)).r-texture2D(srcTex,vTex + vec2(-texel.x,0)).r)/2.0 + 0.5;",
    " color.g = (texture2D(srcTex,vTex + vec2(0,-texel.y)).r-texture2D(srcTex,vTex + vec2(0,texel.y)).r)/2.0 + 0.5;",
    " color.b = 1.0;",
    " gl_FragColor.rgb = color;",
    " gl_FragColor.a = 1.0;",
    "}"].join("\n"));
    
    shaderNMap.use();      
    shaderNMap.addUVArray("aTex");
    shaderNMap.addVertexArray("aVertex");
    shaderNMap.addInt("srcTex",0);
    shaderNMap.addVector("texel");
    shaderNMap.setVector("texel",vTexel);      

    this.shaderNorm = shaderNMap;

    // bind functions to "subclass" a texture
    this.setFilter=this.outputBuffer.texture.setFilter;
    this.clear=this.outputBuffer.texture.clear;
    this.use=this.outputBuffer.texture.use;
    this.tex_id=this.outputBuffer.texture.tex_id;
    this.filterType=this.outputBuffer.texture.filterType;

    this.outTex.use(gl.TEXTURE0);
    // 
    // if (!isPOT) {
    //    this.setFilter(enums.texture.filter.LINEAR);
    //    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    //    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);    
    //  } else {
       this.setFilter(enums.texture.filter.LINEAR);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
    //  }
    
  }
  
  
  
  NormalMapGen.prototype.update = function()
  {
    var gl = GLCore.gl;

    var dims = gl.getParameter(gl.VIEWPORT);

    this.outputBuffer.use();
    
    gl.viewport(0, 0, this.width, this.height);
    
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    this.srcTex.use(gl.TEXTURE0);

    PostProcessChain.prototype.renderFSQuad(this.shaderNorm,this.fsQuad);  // copy the output buffer to the screen via fullscreen quad

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    
    gl.viewport(dims[0], dims[1], dims[2], dims[3]);
  }



 function DeferredBin()
 {
   this.meshBin = {};
   this.imageBin = {};
   
   this.meshMap = {};
   this.imageMap = {};
   
   this.imageBinPtr = {};
   this.meshBinPtr = {};
 }
 
 DeferredBin.prototype.addMesh = function(binId,meshId,meshObj) {
   if (this.meshBin[binId] === undef)
   {
     this.meshBin[binId] = [];
     if (this.meshBinPtr[binId]===undef) {
       this.meshBinPtr[binId] = 0;       
     }
   }

   if (this.meshMap[meshId] === undef)
   {
     this.meshMap[meshId] = meshObj;
     this.meshBin[binId].push(meshObj);
   }
 }
 
 DeferredBin.prototype.addImage = function(binId,imageId,imageObj) {
   if (this.imageBin[binId] === undef)
   {
     this.imageBin[binId] = [];
     if (this.imageBinPtr[binId]===undef) {
       this.imageBinPtr[binId] = 0;       
     }
   }
   
   if (this.imageMap[imageId] === undef)
   {
     this.imageMap[imageId] = imageObj;
     this.imageBin[binId].push(imageObj);
   }
 };
 
 DeferredBin.prototype.getMeshes = function(binId) {
   return this.meshBin[binId];
 };

 DeferredBin.prototype.getImages = function(binId) {
   return this.imageBin[binId];
 };
 
 DeferredBin.prototype.rewindMeshes = function(binId) {
   this.meshBinPtr[binId] = 0;
 };
 
 DeferredBin.prototype.rewindImages = function(binId) {
   this.imageBinPtr[binId] = 0;
 };
 
 DeferredBin.prototype.getNextMesh = function(binId) {
   var cBin = this.meshBinPtr[binId];

   if (cBin<this.meshBin[binId].length)
   {
     this.meshBinPtr[binId]++;
     return this.meshBin[binId][cBin];
   }
   
   return null;
 };
 
 DeferredBin.prototype.loadNextMesh = function(binId)
 {
   var mesh = this.getNextMesh(binId);
   
   if (mesh !== null)
   {
     if (mesh.compiled===null)
     {
       mesh.triangulateQuads();
       mesh.compile();
       mesh.clean();
     }
     
     return true;
   }

   return false;
 };

 DeferredBin.prototype.isMeshBinEmpty = function(binId) {
   //console.log('isMeshBinEmpty[' + binId + '] = ' + (this.meshBinPtr[binId] === this.meshBin[binId].length) + ' meshBinPtr = ' + this.meshBinPtr[binId] + ' meshBin.length = ' + this.meshBin[binId].length);
   return this.meshBinPtr[binId] === this.meshBin[binId].length;
 };

 DeferredBin.prototype.loadNextImage = function(binId)
 {
   var img = this.getNextImage(binId);
   
   if (img !== null) {
     img.src = img.deferredSrc;
//     return true;
   }

//   return false;
 };
 
 
 DeferredBin.prototype.getNextImage = function(binId) {
   var cBin = this.imageBinPtr[binId];
   
   if (cBin<this.imageBin[binId].length)
   {
     this.imageBinPtr[binId]++;
     return this.imageBin[binId][cBin];
   }
   
   return null;
 };

 DeferredBin.prototype.isImageBinEmpty = function(binId) {
   //console.log('isImageBinEmpty[' + binId + '] = ' + (this.imageBinPtr[binId] === this.imageBin[binId].length));
   return this.imageBinPtr[binId] === this.imageBin[binId].length ;
 };
 
function cubicvr_loadColladaWorker(meshUrl, prefix, callback, deferred_bin) {
  var worker;
  try {
    worker = new Worker(SCRIPT_LOCATION + 'collada.js');
  }
  catch(e) {
    throw new Error("Can't find collada.js");
  } //try

  var materials_map = [];
  var meshes_map = [];

  worker.onmessage = function(e) {

    function copyObjectFromJSON(json, obj) {
      for (var i in json) {
        obj[i] = json[i];
      } //for
    } //new_obj

    var message = e.data.message;
    if (message == 'materials') {
      var mats = JSON.parse(e.data.data);
      for (var i=0, maxI=mats.length; i<maxI; ++i) {
        var new_mat = new Material(mats[i].name);
        var mat_id = new_mat.material_id;
        copyObjectFromJSON(mats[i], new_mat);
        new_mat.material_id = mat_id;
        materials_map[mats[i].material_id] = mat_id;
        for (var j=0, maxJ=mats[i].textures.length; j<maxJ; ++j) {
          var dt = mats[i].textures[j];
          if (dt) {
            var stored_tex = Texture_ref[dt.img_path];

            if (stored_tex === undefined) {
              var t = new Texture(dt.img_path, dt.filter_type, deferred_bin, meshUrl);
              new_mat.textures[j] = t;
            }
            else {
              new_mat.textures[j] = Textures_obj[stored_tex];
            } //if
          }
          else {
            new_mat.textures[j] = 0;
          } //if
        } //for
      } //for
    }
    else if (message == 'scene') {
      var scene = JSON.parse(e.data.data);

      function reassembleMotion(obj) {
        //reassemble linked-list for sceneObject motion envelope keys
        if (obj.motion) {
          var co = obj.motion.controllers;
          var new_controllers = [];
          for (var j=0, maxJ=co.length; j<maxJ; ++j) {
            var con = co[j];
            if (!con) {
              co[j] = undefined;
              continue;
            }
            var new_con = [];
            for (var k=0, maxK=con.length; k<maxK; ++k) {
              var env = con[k];
              if (!env) {
                con[k] = undefined;
                continue;
              }
              var keys = env.keys[0];
              if (env.keys.length > 1) {
                keys.prev = null;
                keys.next = env.keys[1];
                keys = env.keys[1];
              } //if
              for (var keyI=1,maxKeyI=env.keys.length-1; keyI<maxKeyI; ++keyI) {
                keys.prev = env.keys[keyI-1];
                keys.next = env.keys[keyI+1];
                keys = env.keys[keyI+1];
              } //for keyI
              if (env.keys.length > 1) {
                keys = env.keys[env.keys.length-1];
                keys.prev = env.keys[env.keys.length-2];
                keys.next = null;
              } //if
              env.firstKey = env.keys[0];
              env.lastKey = env.keys[env.keys.length-1];
              env.keys = env.firstKey;

              var envelope = new Envelope();
              copyObjectFromJSON(env, envelope);
              new_con[k]=envelope;
            } //for k
            new_controllers[j] = new_con;
          } //for j
          obj.motion.controllers = new_controllers;
          var motion = new Motion();
          copyObjectFromJSON(obj.motion, motion);
          obj.motion = motion;
        } //if
      } //reassembleMotion

      for (var i=0, maxI=scene.sceneObjects.length; i<maxI; ++i) {
        var so = scene.sceneObjects[i];
   
        if (so.obj !== null) {
          
        } //if

        if (so.reassembled === undefined) {
          reassembleMotion(so);
          so.reassembled = true;
        } //if

        function createSceneObject(scene_obj) {
          var sceneObject = new SceneObject();
          copyObjectFromJSON(scene_obj, sceneObject);
          if (scene_obj.obj !== null) {
            var stored_mesh = meshes_map[scene_obj.obj.id];
            if (stored_mesh === undefined) {
              var mesh = new Mesh();
              copyObjectFromJSON(scene_obj.obj, mesh);
              sceneObject.obj = mesh;
              meshes_map[scene_obj.obj.id] = mesh;
              if (deferred_bin) {
                if (mesh.points.length > 0) {
                  deferred_bin.addMesh(meshUrl,meshUrl+":"+mesh.id,mesh) 
                  for (var f=0,maxF=mesh.faces.length; f<maxF; ++f) {
                    var face = mesh.faces[f];
                    var m_index = face.material;
                    var mapped = materials_map[m_index];
                    if (mapped !== undefined) {
                      face.material = materials_map[m_index];
                    }
                    else {
                      face.material = 0;
                    } //if
                  } //for
                } //if
              }
              else {
                sceneObject.obj.triangulateQuads();
                sceneObject.obj.calcNormals();
                sceneObject.obj.compile();
                sceneObject.obj.clean();
              } //if
            }
            else {
              sceneObject.obj = stored_mesh;
            } //if
          } //if
          
          sceneObject.trans = new Transform();

          if (scene_obj.children && scene_obj.children.length > 0) {
            sceneObject.children = [];
            createChildren(scene_obj, sceneObject);
          } //if

          return sceneObject;
        } //createSceneObject

        function createChildren(scene_obj, sceneObject) {
          if (scene_obj.children) {
            for (var j=0, maxJ=scene_obj.children.length; j<maxJ; ++j) {
              var child = createSceneObject(scene_obj.children[j]);
              sceneObject.bindChild(child);
            } //for
          } //if
        } //createChildren

        scene.sceneObjects[i] = createSceneObject(so);

      } //for i

      var new_scene = new Scene();
      // place parsed scene elements into new scene (since parse scene has no prototype)
      var camera = new_scene.camera;
      var camera_transform = camera.transform;
      copyObjectFromJSON(scene.camera, camera);
      copyObjectFromJSON(scene.camera.transform, camera_transform);
      reassembleMotion(camera);
      new_scene.camera = camera;
      new_scene.camera.transform = camera_transform;
      new_scene.camera.frustum = new Frustum();

      for (var i=0, maxI=scene.sceneObjects.length; i<maxI; ++i) {
        var o = scene.sceneObjects[i];
        new_scene.bindSceneObject(o);
        try {
          o.getAABB();
        }
        catch(e) {
          //console.log(o);
        } //try
        
      } //for

      for (var i=0, maxI=scene.lights.length; i<maxI; ++i) {
        var l = new Light();
        copyObjectFromJSON(scene.lights[i], l);
        l.trans = new Transform();
        reassembleMotion(l);
        new_scene.bindLight(l);
      } //for

      callback(new_scene);
    }
    else {
      console.log("message from collada worker:", e.data.message);
    } //if
  } //onmessage

  worker.onerror = function(e) {
    console.log("error from collada worker:", e.message);
  } //onerror

  worker.postMessage({message:'start', params: {meshUrl: meshUrl, prefix: prefix, rootDir: SCRIPT_LOCATION}});
} //cubicvr_loadColladaWorker


function xml2badgerfish(xmlDoc) {
    var jsonData = {};
    var nodeStack = [];

    var i, iMax, iMin;

    var n = xmlDoc;
    var j = jsonData;
    var cn, tn;
    var regEmpty = /^\s+|\s+$/g;

    xmlDoc.jsonParent = j;
    nodeStack.push(xmlDoc);

    while (nodeStack.length) {
        var n = nodeStack.pop();
        var tagGroup = null;

        j = n.jsonParent;

        for (i = 0, iMax = n.childNodes.length; i < iMax; i++) {
            cn = n.childNodes[i];
            tn = cn.tagName;

            if (tn !== undef) {
                tagGroup = tagGroup || {};
                tagGroup[tn] = tagGroup[tn] || 0;
                tagGroup[tn]++;
            }
        }

        if (n.attributes) if (n.attributes.length) {
            for (i = 0, iMax = n.attributes.length; i < iMax; i++) {
                var att = n.attributes[i];

                j["@" + att.name] = att.value;
            }
        }

        for (i = 0, iMax = n.childNodes.length; i < iMax; i++) {
            cn = n.childNodes[i];
            tn = cn.tagName;

            if (cn.nodeType === 1) {
                if (tagGroup[tn] > 1) {
                    j[tn] = j[tn] || [];
                    j[tn].push({});
                    cn.jsonParent = j[tn][j[tn].length - 1];
                } else {
                    j[tn] = j[tn] || {};
                    cn.jsonParent = j[tn];
                }
                nodeStack.push(cn);
            } else if (cn.nodeType === 3) {
                if (cn.nodeValue.replace(regEmpty, "") !== "") {
                    j.$ = j.$ || "";
                    j.$ += cn.nodeValue;
                }
            }
        }
    }

    return jsonData;
}

var collada_tools = {
    fixuaxis: function (up_axis, v) {
        if (up_axis === 0) { // untested
            return [v[1], v[0], v[2]];
        } else if (up_axis === 1) {
            return v;
        } else if (up_axis === 2) {
            return [v[0], v[2], -v[1]];
        }
    },
    fixscaleaxis: function (up_axis, v) {
        if (up_axis === 0) { // untested
            return [v[1], v[0], v[2]];
        } else if (up_axis === 1) {
            return v;
        } else if (up_axis === 2) {
            return [v[0], v[2], v[1]];
        }
    },
    fixukaxis: function (up_axis, mot, chan, val) {
        // if (mot === enums.motion.POS && chan === enums.motion.Y && up_axis === enums.motion.Z) return -val;
        if (mot === enums.motion.POS && chan === enums.motion.Z && up_axis === enums.motion.Z) {
            return -val;
        }
        return val;
    },
    getAllOf: function (root_node, leaf_name) {
        var nStack = [root_node];
        var results = [];

        while (nStack.length) {
            var n = nStack.pop();

            for (var i in n) {
                if (!n.hasOwnProperty(i)) continue;

                if (i === leaf_name) {
                    if (n[i].length) {
                        for (var p = 0, pMax = n[i].length; p < pMax; p++) {
                            results.push(n[i][p]);
                        }
                    } else {
                        results.push(n[i]);
                    }
                }
                if (typeof(n[i]) == 'object') {
                    if (n[i].length) {
                        for (var p = 0, pMax = n[i].length; p < pMax; p++) {
                            nStack.push(n[i][p]);
                        }
                    } else {
                        nStack.push(n[i]);
                    }
                }
            }
        }

        return results;
    },
    quaternionFilterZYYZ: function (rot, ofs) {
        var r = rot;
        var temp_q = new Quaternion();

        if (ofs !== undef) {
            r = vec3.add(rot, ofs);
        }

        temp_q.fromEuler(r[0], r[2], -r[1]);

        return temp_q.toEuler();
    },
    cl_getInitalTransform: function (up_axis, scene_node) {
        var retObj = {
            position: [0, 0, 0],
            rotation: [0, 0, 0],
            scale: [1, 1, 1]
        };

        var translate = scene_node.translate;
        var rotate = scene_node.rotate;
        var scale = scene_node.scale;

        if (translate) {
            retObj.position = collada_tools.fixuaxis(up_axis, util.floatDelimArray(translate.$, " "));
        }


        if (rotate) {
            for (var r = 0, rMax = rotate.length; r < rMax; r++) {
                var cl_rot = rotate[r];

                var rType = cl_rot["@sid"];

                var rVal = util.floatDelimArray(cl_rot.$, " ");

                if (rType == "rotateX" || rType == "rotationX") {
                    retObj.rotation[0] = rVal[3];
                } else if (rType == "rotateY" || rType == "rotationY") {
                    retObj.rotation[1] = rVal[3];
                } else if (rType == "rotateZ" || rType == "rotationZ") {
                    retObj.rotation[2] = rVal[3];
                } //if
            } //for
        } //if
        if (scale) {
            retObj.scale = collada_tools.fixscaleaxis(up_axis, util.floatDelimArray(scale.$, " "));
        }

        // var cl_matrix = scene_node.getElementsByTagName("matrix");
        // 
        // if (cl_matrix.length)
        // {
        //   console.log(util.collectTextNode(cl_matrix[0]));
        // }
        return retObj;
    }
};



function cubicvr_parseCollada(meshUrl, prefix, deferred_bin) {
    //  if (MeshPool[meshUrl] !== undef) return MeshPool[meshUrl];
    var obj = new Mesh();
    var scene = new Scene();
    var cl = util.getXML(meshUrl);
    var tech;
    var sourceId;
    var materialRef, nameRef, nFace, meshName;

    var norm, vert, uv, mapLen, computedLen;

    var i, iCount, iMax, iMod, mCount, mMax, k, kMax, cCount, cMax, sCount, sMax, pCount, pMax, j, jMax;

    var cl_source = xml2badgerfish(cl);

    cl = null;

    if (!cl_source.COLLADA) {
        throw new Error(meshUrl + " does not appear to be a valid COLLADA file.");
    }

    cl_source = cl_source.COLLADA;

    var clib = {
        up_axis: 1,
        images: [],
        effects: [],
        materials: [],
        meshes: [],
        scenes: [],
        lights: [],
        cameras: [],
        animations: [],
    };


    // var up_axis = 1; // Y
    if (cl_source.asset) {
        var sAxis = cl_source.asset.up_axis.$;
        if (sAxis === "X_UP") {
            clib.up_axis = 0;
        } else if (sAxis === "Y_UP") {
            clib.up_axis = 1;
        } else if (sAxis === "Z_UP") {
            clib.up_axis = 2;
        }
    }

    var up_axis = clib.up_axis;

    if (cl_source.library_images) if (cl_source.library_images.image.length) {
        var cl_images = cl_source.library_images.image;
        for (var imgCount = 0, imgCountMax = cl_images.length; imgCount < imgCountMax; imgCount++) {
            var cl_img = cl_images[imgCount];
            var imageId = cl_img["@id"];
            var imageName = cl_img["@name"];
            var cl_imgsrc = cl_img.init_from;

            if (cl_imgsrc.$) {
                var imageSource = cl_imgsrc.$;

                if (prefix !== undef && (imageSource.lastIndexOf("/") !== -1)) {
                    imageSource = imageSource.substr(imageSource.lastIndexOf("/") + 1);
                }
                if (prefix !== undef && (imageSource.lastIndexOf("\\") !== -1)) {
                    imageSource = imageSource.substr(imageSource.lastIndexOf("\\") + 1);
                }

                // console.log("Image reference: "+imageSource+" @"+imageId+":"+imageName);
                clib.images[imageId] = {
                    source: imageSource,
                    id: imageId,
                    name: imageName
                };
            }
        }
    }

    // Effects
    var effectId;
    var effectCount, effectMax;
    var tCount, tMax, inpCount, inpMax;
    var cl_params, cl_inputs, cl_input, cl_inputmap, cl_samplers, cl_camera, cl_cameras, cl_scene;
    var ofs;


    if (cl_source.library_effects) {
        var cl_effects = cl_source.library_effects.effect;

        if (cl_effects && !cl_effects.length) cl_effects = [cl_effects];

        for (effectCount = 0, effectMax = cl_effects.length; effectCount < effectMax; effectCount++) {
            var cl_effect = cl_effects[effectCount];

            effectId = cl_effect["@id"];

            var effect = {};

            effect.id = effectId;

            effect.surfaces = [];
            effect.samplers = [];

            cl_params = cl_effect.profile_COMMON.newparam;

            if (cl_params && !cl_params.length) {
                cl_params = [cl_params];
            };

            var params = [];

            var cl_init;

            if (cl_params) {
                for (pCount = 0, pMax = cl_params.length; pCount < pMax; pCount++) {
                    var cl_param = cl_params[pCount];

                    var paramId = cl_param["@sid"];

                    if (cl_param.surface) {
                        effect.surfaces[paramId] = {};

                        var initFrom = cl_param.surface.init_from.$;

                        if (typeof(clib.images[initFrom]) === 'object') {

                            var img_path = prefix + "/" + clib.images[initFrom].source;
                            effect.surfaces[paramId].source = img_path;
                            //                console.log(prefix+"/"+clib.images[initFrom].source);
                        }
                    } else if (cl_param.sampler2D) {
                        effect.samplers[paramId] = {};

                        effect.samplers[paramId].source = cl_param.sampler2D.source.$;

                        if (cl_param.sampler2D.minfilter) {
                            effect.samplers[paramId].minfilter = cl_param.sampler2D.minfilter.$;
                        }

                        if (cl_param.sampler2D.magfilter) {
                            effect.samplers[paramId].magfiter = cl_param.sampler2D.magfilter.$;
                        }
                    }

                }
            }

            var cl_technique = cl_effect.profile_COMMON.technique;

            if (cl_technique && !cl_technique.length) cl_technique = [cl_technique];

            var getColorNode = (function () {
                return function (n) {
                    var el = n.color;
                    if (!el) {
                        return false;
                    }

                    var cn = n.color;
                    var ar = cn ? util.floatDelimArray(cn.$, " ") : false;

                    return ar;
                };
            }());

            var getFloatNode = (function () {
                return function (n) {
                    var el = n.float;
                    if (!el) {
                        return false;
                    }

                    var cn = n.float;
                    cn = cn ? parseFloat(cn.$) : 0;

                    return cn;
                };
            }());

            var getTextureNode = (function () {
                return function (n) {
                    var el = n.texture;
                    if (!el) {
                        return false;
                    }

                    var cn = n.texture["@texture"];

                    return cn;
                };
            }());

            //            effect.material = new Material(effectId);
            effect.material = {
                textures_ref: []
            }

            for (tCount = 0, tMax = cl_technique.length; tCount < tMax; tCount++) {
                //        if (cl_technique[tCount].getAttribute("sid") === 'common') {
                tech = cl_technique[tCount].blinn;

                if (!tech) {
                    tech = cl_technique[tCount].phong;
                }
                if (!tech) {
                    tech = cl_technique[tCount].lambert;
                }

                if (tech) {
                    // for (var eCount = 0, eMax = tech[0].childNodes.length; eCount < eMax; eCount++) {
                    //   var node = tech[0].childNodes[eCount];
                    for (var tagName in tech) {
                        var node = tech[tagName];

                        var c = getColorNode(node);
                        var f = getFloatNode(node);
                        var t = getTextureNode(node);

                        if (c !== false) {
                            if (c.length > 3) {
                                c.pop();
                            }
                        }

                        if (tagName == "emission") {
                            if (c !== false) {
                                effect.material.ambient = c;
                            }
                        } else if (tagName == "ambient") {} else if (tagName == "diffuse") {
                            if (c !== false) {
                                effect.material.color = c;
                            }
                        } else if (tagName == "specular") {
                            if (c !== false) {
                                effect.material.specular = c;
                            }
                        } else if (tagName == "shininess") {
                            if (f !== false) {
                                effect.material.shininess = f;
                            }
                        } else if (tagName == "reflective") {} else if (tagName == "reflectivity") {} else if (tagName == "transparent") {} else if (tagName == "index_of_refraction") {}
                        // case "transparency": if (f!==false) effect.material.opacity = 1.0-f; break;
                        if (t !== false) {
                            effect.material
                            var srcTex = effect.surfaces[effect.samplers[t].source].source;
                            if (tagName == "emission") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.AMBIENT
                                });
                            } else if (tagName == "ambient") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.AMBIENT
                                });
                            } else if (tagName == "diffuse") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.COLOR
                                });
                            } else if (tagName == "specular") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.SPECULAR
                                });
                            } else if (tagName == "shininess") {} else if (tagName == "reflective") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.REFLECT
                                });
                            } else if (tagName == "reflectivity") {} else if (tagName == "transparent") {
                                effect.material.textures_ref.push({
                                    image: srcTex,
                                    type: enums.texture.map.ALPHA
                                });
                            } else if (tagName == "transparency") {} else if (tagName == "index_of_refraction") {}
                        }
                    }
                }

                clib.effects[effectId] = effect;
            }
        }
    }

    // End Effects

    var cl_lib_mat_inst = collada_tools.getAllOf(cl_source.library_visual_scenes, "instance_material");
    var materialMap = [];

    if (cl_lib_mat_inst.length) {
        for (i = 0, iMax = cl_lib_mat_inst.length; i < iMax; i++) {
            var cl_mat_inst = cl_lib_mat_inst[i];

            var symbolId = cl_mat_inst["@symbol"];
            var targetId = cl_mat_inst["@target"].substr(1);

            materialMap[symbolId] = targetId;
        }
    }


    var cl_lib_materials = cl_source.library_materials;

    if (cl_lib_materials.material) {
        var cl_materials = cl_lib_materials.material;
        if (cl_materials && !cl_materials.length) cl_materials = [cl_materials];

        for (mCount = 0, mMax = cl_materials.length; mCount < mMax; mCount++) {
            var cl_material = cl_materials[mCount];

            var materialId = cl_material["@id"];
            var materialName = cl_material["@name"];

            var cl_einst = cl_material.instance_effect;

            if (cl_einst) {
                effectId = cl_einst["@url"].substr(1);
                clib.materials.push({
                    id: materialId,
                    name: materialName,
                    mat: clib.effects[effectId].material
                });
            }
        }
    }

    var cl_lib_geo = cl_source.library_geometries;

    if (cl_lib_geo) {
        var cl_geo_node = cl_lib_geo.geometry;

        if (cl_geo_node && !cl_geo_node.length) cl_geo_node = [cl_geo_node];

        if (cl_geo_node.length) {
            for (var meshCount = 0, meshMax = cl_geo_node.length; meshCount < meshMax; meshCount++) {
                var meshData = {
                    id: undef,
                    points: [],
                    parts: []
                };

                var currentMaterial;

                var cl_geomesh = cl_geo_node[meshCount].mesh;

                // console.log("found "+meshUrl+"@"+meshName);
                if (cl_geomesh) {
                    var meshId = cl_geo_node[meshCount]["@id"];
                    meshName = cl_geo_node[meshCount]["@name"];

                    //                    MeshPool[meshUrl + "@" + meshName] = newObj;
                    var cl_geosources = cl_geomesh.source;
                    if (cl_geosources && !cl_geosources.length) cl_geosources = [cl_geosources];

                    var geoSources = [];

                    for (var sourceCount = 0, sourceMax = cl_geosources.length; sourceCount < sourceMax; sourceCount++) {
                        var cl_geosource = cl_geosources[sourceCount];

                        sourceId = cl_geosource["@id"];
                        var sourceName = cl_geosource["@name"];
                        var cl_floatarray = cl_geosource.float_array;


                        if (cl_floatarray) {
                            geoSources[sourceId] = {
                                id: sourceId,
                                name: sourceName,
                                data: util.floatDelimArray(cl_floatarray.$?cl_floatarray.$:"", " ")
                            };
                        }

                        var cl_accessor = cl_geosource.technique_common.accessor;

                        if (cl_accessor) {
                            geoSources[sourceId].count = parseInt(cl_accessor["@count"]);
                            geoSources[sourceId].stride = parseInt(cl_accessor["@stride"]);
                            if (geoSources[sourceId].count) {
                                geoSources[sourceId].data = util.repackArray(geoSources[sourceId].data, geoSources[sourceId].stride, geoSources[sourceId].count);
                            }
                        }
                    }

                    var geoVerticies = [];

                    var cl_vertices = cl_geomesh.vertices;

                    var pointRef = null;
                    var pointRefId = null;
                    var triangleRef = null;
                    var normalRef = null;
                    var uvRef = null;


                    if (cl_vertices) {
                        pointRefId = cl_vertices["@id"];
                        cl_inputs = cl_vertices.input;

                        if (cl_inputs && !cl_inputs.length) cl_inputs = [cl_inputs];

                        if (cl_inputs) {
                            for (inpCount = 0, inpMax = cl_inputs.length; inpCount < inpMax; inpCount++) {
                                cl_input = cl_inputs[inpCount];

                                if (cl_input["@semantic"] === "POSITION") {
                                    pointRef = cl_input["@source"].substr(1);
                                }
                            }
                        }
                    }

                    var CL_VERTEX = 0,
                        CL_NORMAL = 1,
                        CL_TEXCOORD = 2,
                        CL_OTHER = 3;


                    var cl_triangles = cl_geomesh.triangles;
                    if (cl_triangles && !cl_triangles.length) cl_triangles = [cl_triangles];

                    var v_c = false,
                        n_c = false,
                        u_c = false;

                    if (cl_triangles) {
                        for (tCount = 0, tMax = cl_triangles.length; tCount < tMax; tCount++) {
                            var meshPart = {
                                material: 0,
                                faces: [],
                                normals: [],
                                texcoords: []
                            }

                            var cl_trianglesCount = parseInt(cl_triangles[tCount]["@count"], 10);
                            cl_inputs = cl_triangles[tCount].input;
                            if (cl_inputs && !cl_inputs.length) cl_inputs = [cl_inputs];

                            cl_inputmap = [];

                            if (cl_inputs.length) {
                                for (inpCount = 0, inpMax = cl_inputs.length; inpCount < inpMax; inpCount++) {
                                    cl_input = cl_inputs[inpCount];

                                    ofs = parseInt(cl_input["@offset"], 10);
                                    nameRef = cl_input["@source"].substr(1);

                                    if (cl_input["@semantic"] === "VERTEX") {
                                        if (nameRef === pointRefId) {
                                            nameRef = triangleRef = pointRef;
                                        } else {
                                            triangleRef = nameRef;
                                        }
                                        v_c = true;
                                        cl_inputmap[ofs] = CL_VERTEX;
                                    } else if (cl_input["@semantic"] === "NORMAL") {
                                        normalRef = nameRef;
                                        if (geoSources[normalRef].count) {
                                            cl_inputmap[ofs] = CL_NORMAL;
                                        }
                                        n_c = true;
                                    } else if (cl_input["@semantic"] === "TEXCOORD") {
                                        uvRef = nameRef;
                                        if (geoSources[uvRef].count) {
                                            cl_inputmap[ofs] = CL_TEXCOORD;
                                        }
                                        u_c = true;
                                    } else {
                                        cl_inputmap[ofs] = CL_OTHER;
                                    }
                                }
                            }
                            mapLen = cl_inputmap.length;

                            materialRef = cl_triangles[tCount]["@material"];

                            if (materialRef === null) {
                                meshPart.material = 0;
                            } else {
                                if (materialMap[materialRef] === undef) {
                                    log("missing material [" + materialRef + "]@" + meshName + "?");
                                    meshPart.material = 0;
                                } else {
                                    meshPart.material = materialMap[materialRef];
                                }
                            }


                            var cl_triangle_source = cl_triangles[tCount].p;

                            var triangleData = [];

                            if (cl_triangle_source) {
                                triangleData = util.intDelimArray(cl_triangle_source.$, " ");
                            }

                            if (triangleData.length) {
                                computedLen = ((triangleData.length) / cl_inputmap.length) / 3;

                                if (computedLen !== cl_trianglesCount) {
                                    //                console.log("triangle data doesn't add up, skipping object load: "+computedLen+" !== "+cl_trianglesCount);
                                } else {
                                    if (meshData.points.length === 0) {
                                        meshData.points = geoSources[pointRef].data;
                                    }

                                    ofs = 0;

                                    for (i = 0, iMax = triangleData.length, iMod = cl_inputmap.length; i < iMax; i += iMod * 3) {
                                        norm = [];
                                        vert = [];
                                        uv = [];

                                        for (j = 0; j < iMod * 3; j++) {
                                            var jMod = j % iMod;

                                            if (cl_inputmap[jMod] === CL_VERTEX) {
                                                vert.push(triangleData[i + j]);
                                            } else if (cl_inputmap[jMod] === CL_NORMAL) {
                                                norm.push(triangleData[i + j]);
                                            } else if (cl_inputmap[jMod] === CL_TEXCOORD) {
                                                uv.push(triangleData[i + j]);
                                            }
                                        }

                                        if (vert.length) {
                                            meshPart.faces.push(vert);

                                            if (norm.length === 3) {
                                                meshPart.normals.push([collada_tools.fixuaxis(clib.up_axis, geoSources[normalRef].data[norm[0]]), collada_tools.fixuaxis(clib.up_axis, geoSources[normalRef].data[norm[1]]), collada_tools.fixuaxis(clib.up_axis, geoSources[normalRef].data[norm[2]])]);
                                            }


                                            if (uv.length === 3) {
                                                meshPart.texcoords.push([geoSources[uvRef].data[uv[0]], geoSources[uvRef].data[uv[1]], geoSources[uvRef].data[uv[2]]]);
                                            }
                                        }
                                    }
                                }
                            }
                            
                            meshData.parts.push(meshPart);
                        }
                    }


                    var cl_polylist = cl_geomesh.polylist;
                    if (!cl_polylist) {
                        cl_polylist = cl_geomesh.polygons; // try polygons                
                    }

                    if (cl_polylist && !cl_polylist.length) cl_polylist = [cl_polylist];

                    if (cl_polylist) {
                        for (tCount = 0, tMax = cl_polylist.length; tCount < tMax; tCount++) {
                            var meshPart = {
                                material: 0,
                                faces: [],
                                normals: [],
                                texcoords: []
                            }

                            var cl_polylistCount = parseInt(cl_polylist[tCount]["@count"], 10);

                            cl_inputs = cl_polylist[tCount].input;

                            if (cl_inputs && !cl_inputs.length) cl_inputs = [cl_inputs];

                            cl_inputmap = [];

                            if (cl_inputs.length) {
                                for (inpCount = 0, inpMax = cl_inputs.length; inpCount < inpMax; inpCount++) {
                                    cl_input = cl_inputs[inpCount];

                                    var cl_ofs = cl_input["@offset"];

                                    if (cl_ofs === null) {
                                        cl_ofs = cl_input["@idx"];
                                    }

                                    ofs = parseInt(cl_ofs, 10);
                                    nameRef = cl_input["@source"].substr(1);

                                    if (cl_input["@semantic"] === "VERTEX") {
                                        if (nameRef === pointRefId) {
                                            nameRef = triangleRef = pointRef;

                                        } else {
                                            triangleRef = nameRef;
                                        }
                                        cl_inputmap[ofs] = CL_VERTEX;
                                    } else if (cl_input["@semantic"] === "NORMAL") {
                                        normalRef = nameRef;
                                        cl_inputmap[ofs] = CL_NORMAL;
                                    } else if (cl_input["@semantic"] === "TEXCOORD") {
                                        uvRef = nameRef;
                                        cl_inputmap[ofs] = CL_TEXCOORD;
                                    } else {
                                        cl_inputmap[ofs] = CL_OTHER;
                                    }
                                }
                            }


                            var cl_vcount = cl_polylist[tCount].vcount;
                            var vcount = [];

                            if (cl_vcount) {
                                vcount = util.intDelimArray(cl_vcount.$, " ");
                            }

                            materialRef = cl_polylist[tCount]["@material"];

                            if (materialRef === undef) {
                                meshPart.material = 0;
                            } else {
                                meshPart.material = materialMap[materialRef];
                            }

                            var cl_poly_source = cl_polylist[tCount].p;

                            mapLen = cl_inputmap.length;

                            var polyData = [];

                            if ((cl_poly_source.length > 1) && !vcount.length) // blender 2.49 style
                            {
                                var pText = "";
                                for (pCount = 0, pMax = cl_poly_source.length; pCount < pMax; pCount++) {
                                    var tmp = util.intDelimArray(cl_poly_source[pCount].$, " ");

                                    vcount[pCount] = parseInt(tmp.length / mapLen, 10);

                                    polyData.splice(polyData.length, 0, tmp);
                                }
                            } else {
                                if (cl_poly_source) {
                                    polyData = util.intDelimArray(cl_poly_source.$, " ");
                                }
                            }

                            if (polyData.length) {
                                computedLen = vcount.length;

                                if (computedLen !== cl_polylistCount) {
                                    log("poly vcount data doesn't add up, skipping object load: " + computedLen + " !== " + cl_polylistCount);
                                } else {
                                    if (meshData.points.length === 0) {
                                        meshData.points = geoSources[pointRef].data;
                                    }

                                    ofs = 0;

                                    for (i = 0, iMax = vcount.length; i < iMax; i++) {
                                        norm = [];
                                        vert = [];
                                        uv = [];

                                        for (j = 0, jMax = vcount[i] * mapLen; j < jMax; j++) {
                                            if (cl_inputmap[j % mapLen] === CL_VERTEX) {
                                                vert.push(polyData[ofs]);
                                                ofs++;
                                            } else if (cl_inputmap[j % mapLen] === CL_NORMAL) {
                                                norm.push(polyData[ofs]);
                                                ofs++;
                                            } else if (cl_inputmap[j % mapLen] === CL_TEXCOORD) {
                                                uv.push(polyData[ofs]);
                                                ofs++;
                                            }
                                        }


                                        if (vert.length) {
                                            // if (up_axis !== 1)
                                            // {
                                            //   vert.reverse();
                                            // }
                                            // nFace = newObj.addFace(vert);
                                            meshPart.faces.push(vert);

                                            if (norm.length) {
                                                var nlist = [];
                                                for (k = 0, kMax = norm.length; k < kMax; k++) {
                                                    // newObj.faces[nFace].point_normals[k] = fixuaxis(geoSources[normalRef].data[norm[k]]);
                                                    nlist.push(collada_tools.fixuaxis(clib.up_axis, geoSources[normalRef].data[norm[k]]));
                                                }
                                                meshPart.normals.push(nlist);
                                            }

                                            if (uv.length) {
                                                var tlist = [];
                                                for (k = 0, kMax = uv.length; k < kMax; k++) {
                                                    // newObj.faces[nFace].uvs[k] = geoSources[uvRef].data[uv[k]];
                                                    tlist.push(geoSources[uvRef].data[uv[k]]);
                                                }
                                                meshPart.texcoords.push(tlist);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (up_axis !== 1) {
                        for (i = 0, iMax = meshData.points.length; i < iMax; i++) {
                            meshData.points[i] = collada_tools.fixuaxis(clib.up_axis, meshData.points[i]);
                        }
                    }



                    meshData.id = meshId;
                    clib.meshes.push(meshData);

                }
            }
        }
    }





    var cl_lib_cameras = cl_source.library_cameras;
    var camerasBoundRef = [];

    if (cl_lib_cameras) {
        cl_cameras = cl_lib_cameras.camera;
        if (cl_cameras && !cl_cameras.length) cl_cameras = [cl_cameras];

        for (cCount = 0, cMax = cl_cameras.length; cCount < cMax; cCount++) {
            cl_camera = cl_cameras[cCount];

            var cameraId = cl_camera["@id"];
            var cameraName = cl_camera["@name"];

            //      var cl_perspective = cl_camera.getElementsByTagName("perspective");
            // if (cl_perspective.length) {
            //   var perspective = cl_perspective[0];
            var cl_yfov = 0;
            var cl_znear = 0;
            var cl_zfar = 0;

            if (cl_camera.optics) if (cl_camera.optics.technique_common) if (cl_camera.optics.technique_common.perspective) {
                cl_yfov = cl_camera.optics.technique_common.perspective.yfov;
                cl_znear = cl_camera.optics.technique_common.perspective.znear;
                cl_zfar = cl_camera.optics.technique_common.perspective.zfar;
            }


            var yfov;
            var znear;
            var zfar;

            if (!cl_yfov && !cl_znear && !cl_zfar) {
                cl_params = cl_camera.param;
                if (cl_params && !cl_params.length) cl_params = [cl_params];

                for (i = 0, iMax = cl_params.length; i < iMax; i++) {
                    var txt = cl_params[i].$;
                    var pName = cl_params[i]["@name"];
                    if (pName == "YFOV") {
                        yfov = parseFloat(txt);
                    } else if (pName == "ZNEAR") {
                        znear = parseFloat(txt);
                    } else if (pName == "ZFAR") {
                        zfar = parseFloat(txt);
                    }
                }
            } else {
                yfov = cl_yfov ? parseFloat(cl_yfov.$) : 60;
                znear = cl_znear ? parseFloat(cl_znear.$) : 0.1;
                zfar = cl_zfar ? parseFloat(cl_zfar.$) : 1000.0;
            }

            clib.cameras.push({
                id: cameraId,
                targeted: false,
                fov: parseFloat(yfov),
                nearclip: parseFloat(znear),
                farclip: parseFloat(zfar)
            });
        }
    }


    var cl_lib_lights = cl_source.library_lights;

    if (cl_lib_lights) {
        var cl_lights = cl_lib_lights.light;
        if (cl_lights && !cl_lights.length) cl_lights = [cl_lights];

        if (cl_lights) for (var lightCount = 0, lightMax = cl_lights.length; lightCount < lightMax; lightCount++) {

            var cl_light = cl_lights[lightCount];

            var cl_point = cl_light.technique_common.point;
            var cl_pointLight = cl_point ? cl_point : null;

            var lightId = cl_light["@id"];
            var lightName = cl_light["@name"];

            if (cl_pointLight !== null) {

                var cl_intensity = cl_pointLight.intensity;
                var intensity = cl_intensity ? parseFloat(cl_intensity.$) : 1.0;
                var cl_distance = cl_pointLight.distance;
                var distance = cl_distance ? parseFloat(cl_distance.$) : 10.0;

                var cl_color = cl_pointLight.color;
                var color = [1, 1, 1];

                if (cl_color) {
                    color = util.floatDelimArray(cl_color.$, " ");
                }

                clib.lights.push({
                    id: lightId,
                    name: lightId,
                    type: enums.light.type.POINT,
                    method: enums.light.method.STATIC,
                    diffuse: color,
                    specular: [0, 0, 0],
                    distance: distance,
                    intensity: intensity
                });
            }
        }
    }

    var cl_lib_scenes = cl_source.library_visual_scenes;

    if (cl_lib_scenes) {
        var cl_scenes = null;

        cl_scenes = cl_lib_scenes.visual_scene;
        if (cl_scenes && !cl_scenes.length) cl_scenes = [cl_scenes];

        for (var sceneCount = 0, sceneMax = cl_scenes.length; sceneCount < sceneMax; sceneCount++) {

            cl_scene = cl_scenes[sceneCount];

            var sceneId = cl_scene["@id"];
            var sceneName = cl_scene["@name"];

            var sceneData = {
                id: sceneName,
                sceneObjects: [],
                cameras: [],
                lights: [],
                parentMap: []
            };

            var nodeMap = {};

            var cl_nodes = [];
            var cl_stack = [cl_scene];

            while (cl_stack.length) {
                var ntemp = cl_stack.pop();
                if (ntemp.node) {
                    var nlist = ntemp.node;
                    if (nlist && !nlist.length) nlist = [nlist];

                    if (nlist) {
                        for (var i = 0, iMax = nlist.length; i < iMax; i++) {
                            nlist[i].parentNode = ntemp;
                            cl_nodes.push(nlist[i]);
                            cl_stack.push(nlist[i]);
                        }
                    }
                }
            }

            if (cl_nodes.length) {
                for (var nodeCount = 0, nodeMax = cl_nodes.length; nodeCount < nodeMax; nodeCount++) {
                    var cl_node = cl_nodes[nodeCount];

                    var cl_geom = cl_node.instance_geometry;
                    var cl_light = cl_nodes[nodeCount].instance_light;
                    cl_camera = cl_nodes[nodeCount].instance_camera;

                    var nodeId = cl_node["@id"];
                    var nodeName = cl_node["@name"];

                    var it = collada_tools.cl_getInitalTransform(clib.up_axis, cl_node);

                    if (up_axis === 2) {
                        it.rotation = collada_tools.quaternionFilterZYYZ(it.rotation, (cl_camera) ? [-90, 0, 0] : undef);
                    }

                    var sceneObject = {};

                    if (cl_geom) {
                        meshName = cl_geom["@url"].substr(1);

                        sceneObject.name = sceneObject.id = (nodeName) ? nodeName : nodeId;

                        sceneObject.position = it.position;
                        sceneObject.rotation = it.rotation;
                        sceneObject.scale = it.scale;
                        sceneObject.meshId = meshName;

                        sceneData.sceneObjects.push(sceneObject);

                        nodeMap[sceneObject.id] = true;;

                        if (cl_node.parentNode) {
                            var parentNodeId = cl_node.parentNode["@id"];
                            var parentNodeName = cl_node.parentNode["@name"];
                            if (parentNodeId) {

                                if (nodeMap[parentNodeId]) {
                                    sceneData.parentMap.push({
                                        parent: parentNodeId,
                                        child: sceneObject.id
                                    });
                                }
                            }
                        }
                    } else if (cl_camera) {
                        var cam_instance = cl_camera;

                        var camRefId = cam_instance["@url"].substr(1);

                        sceneData.cameras.push({
                            name: (nodeName) ? nodeName : nodeId,
                            id: (nodeName) ? nodeName : nodeId,
                            source: camRefId,
                            position: it.position,
                            rotation: it.rotation
                        });


                    } else if (cl_light) {

                        var lightRefId = cl_light["@url"].substr(1);

                        sceneData.lights.push({
                            name: (nodeName) ? nodeName : nodeId,
                            id: (nodeName) ? nodeName : nodeId,
                            source: lightRefId,
                            position: it.position
                        });

                    } else {
                        sceneData.sceneObjects.push({
                            id: (nodeName !== null) ? nodeName : nodeId,
                            name: (nodeName !== null) ? nodeName : nodeId,
                            position: it.position,
                            rotation: it.rotation,
                            scale: it.scale
                        });

                    }

                }
            }

            clib.scenes.push(sceneData);
        }
    }


    var cl_lib_anim = cl_source.library_animations;

    var animId;
    if (cl_lib_anim) {
        var cl_anim_sources = cl_lib_anim.animation;
        if (cl_anim_sources && !cl_anim_sources.length) cl_anim_sources = [cl_anim_sources];

        if (cl_anim_sources) {
            for (var aCount = 0, aMax = cl_anim_sources.length; aCount < aMax; aCount++) {
                var cl_anim = cl_anim_sources[aCount];

                animId = cl_anim["@id"];
                var animName = cl_anim["@name"];

                clib.animations[animId] = {};
                clib.animations[animId].sources = [];

                var cl_sources = cl_anim.source;
                if (cl_sources && !cl_sources.length) cl_sources = [cl_sources];

                if (cl_sources.length) {
                    for (sCount = 0, sMax = cl_sources.length; sCount < sMax; sCount++) {
                        var cl_csource = cl_sources[sCount];

                        sourceId = cl_csource["@id"];


                        var tech_common = cl_csource.technique_common;

                        var name_array = null;
                        var float_array = null;
                        var data = null;

                        if (cl_csource.name_array) {
                            name_array = util.textDelimArray(cl_csource.name_array.$, " ");
                        } else if (cl_csource.Name_array) {
                            name_array = util.textDelimArray(cl_csource.Name_array.$, " ");
                        } else if (cl_csource.float_array) {
                            float_array = util.floatDelimArray(cl_csource.float_array.$, " ");
                        }

                        var acCount = 0;
                        var acSource = "";
                        var acStride = 1;

                        if (tech_common) {
                            tech = tech_common;
                            var acc = tech.accessor;

                            acCount = parseInt(acc["@count"], 10);
                            acSource = acc["@source"].substr(1);
                            var aStride = acc["@stride"];

                            if (aStride) {
                                acStride = parseInt(aStride, 10);
                            }
                        }

                        clib.animations[animId].sources[sourceId] = {
                            data: name_array ? name_array : float_array,
                            count: acCount,
                            source: acSource,
                            stride: acStride
                        };

                        if (acStride !== 1) {
                            clib.animations[animId].sources[sourceId].data = util.repackArray(clib.animations[animId].sources[sourceId].data, acStride, acCount);
                        }
                    }
                }

                cl_samplers = cl_anim.sampler;
                if (cl_samplers && !cl_samplers.length) cl_samplers = [cl_samplers];

                if (cl_samplers) {
                    clib.animations[animId].samplers = [];

                    for (sCount = 0, sMax = cl_samplers.length; sCount < sMax; sCount++) {
                        var cl_sampler = cl_samplers[sCount];

                        var samplerId = cl_sampler["@id"];

                        cl_inputs = cl_sampler.input;

                        if (cl_inputs && !cl_inputs.length) cl_inputs = [cl_inputs];

                        if (cl_inputs) {
                            var inputs = [];

                            for (iCount = 0, iMax = cl_inputs.length; iCount < iMax; iCount++) {
                                cl_input = cl_inputs[iCount];

                                var semanticName = cl_input["@semantic"];

                                inputs[semanticName] = cl_input["@source"].substr(1);
                            }

                            clib.animations[animId].samplers[samplerId] = inputs;
                        }
                    }
                }

                var cl_channels = cl_anim.channel;
                if (cl_channels && !cl_channels.length) cl_channels = [cl_channels];


                if (cl_channels) {
                    clib.animations[animId].channels = [];

                    for (cCount = 0, cMax = cl_channels.length; cCount < cMax; cCount++) {
                        var channel = cl_channels[cCount];

                        var channelSource = channel["@source"].substr(1);
                        var channelTarget = channel["@target"];

                        var channelSplitA = channelTarget.split("/");
                        var channelTargetName = channelSplitA[0];
                        var channelSplitB = channelSplitA[1].split(".");
                        var channelParam = channelSplitB[0];
                        var channelType = channelSplitB[1];

                        clib.animations[animId].channels.push({
                            source: channelSource,
                            target: channelTarget,
                            targetName: channelTargetName,
                            paramName: channelParam,
                            typeName: channelType
                        });
                    }
                }
            }
        }
    }

    var cl_lib_scene = cl_source.scene;

    if (cl_lib_scene) {
        cl_scene = cl_lib_scene.instance_visual_scene;

        if (cl_scene) {
            var sceneUrl = cl_scene["@url"].substr(1);
            clib.scene = sceneUrl;
        }
    }


    return clib;
}


function cubicvr_loadCollada(meshUrl, prefix, deferred_bin) {

    var clib = cubicvr_parseCollada(meshUrl, prefix, deferred_bin);

    var up_axis = clib.up_axis;

    var materialRef = [];

    for (var m = 0, mMax = clib.materials.length; m < mMax; m++) {

        var material = clib.materials[m];
        var newMaterial = new Material(material.mat);

        for (var t = 0, tMax = material.mat.textures_ref.length; t < tMax; t++) {
            var tex = material.mat.textures_ref[t];

            var texObj = null;

            if (Texture_ref[tex.image] === undefined) {
                texObj = new Texture(tex.image, GLCore.default_filter, deferred_bin, meshUrl);
            } else {
                texObj = Textures_obj[Texture_ref[tex.image]];
            }

            newMaterial.setTexture(texObj, tex.type);
        }

        materialRef[material.id] = newMaterial;
    }


    var meshRef = [];

    for (var m = 0, mMax = clib.meshes.length; m < mMax; m++) {

        var meshData = clib.meshes[m];

        var newObj = new Mesh(meshData.id);

        newObj.points = meshData.points;

        for (var mp = 0, mpMax = meshData.parts.length; mp < mpMax; mp++) {
            var part = meshData.parts[mp];

            if (part.material !== 0) {
                newObj.setFaceMaterial(materialRef[part.material]);
            }

            var bNorm = part.normals.length ? true : false;
            var bTex = part.texcoords.length ? true : false;

            for (var p = 0, pMax = part.faces.length; p < pMax; p++) {
                var faceNum = newObj.addFace(part.faces[p]);
                if (bNorm) newObj.faces[faceNum].point_normals = part.normals[p];
                if (bTex) newObj.faces[faceNum].uvs = part.texcoords[p];
            }
        }

        // newObj.calcNormals();
        if (!deferred_bin) {
            newObj.triangulateQuads();
            newObj.compile();
        } else {
            deferred_bin.addMesh(meshUrl, meshUrl + ":" + meshId, newObj);
        }

        meshRef[meshData.id] = newObj;
    }


    var camerasRef = [];

    for (var c = 0, cMax = clib.cameras.length; c < cMax; c++) {
        camerasRef[clib.cameras[c].id] = clib.cameras[c];
    }


    var lightsRef = [];

    for (var l = 0, lMax = clib.lights.length; l < lMax; l++) {
        lightsRef[clib.lights[l].id] = clib.lights[l];
    }



    var sceneObjectMap = {};
    var sceneLightMap = {};
    var sceneCameraMap = {};

    var scenesRef = {};

    for (var s = 0, sMax = clib.scenes.length; s < sMax; s++) {
        var scn = clib.scenes[s];

        var newScene = new CubicVR.Scene();

        for (var so = 0, soMax = scn.sceneObjects.length; so < soMax; so++) {
            var sceneObj = scn.sceneObjects[so];
            var newSceneObject = new SceneObject(sceneObj);
            var srcMesh = meshRef[sceneObj.meshId] || null;
            newSceneObject.obj = srcMesh;

            sceneObjectMap[sceneObj.id] = newSceneObject;
            newScene.bindSceneObject(newSceneObject);
        }

        for (var l = 0, lMax = scn.lights.length; l < lMax; l++) {
            var lt = scn.lights[l];

            var newLight = new Light(lightsRef[lt.source]);
            newLight.position = lt.position;

            sceneLightMap[lt.id] = newLight;
            newScene.bindLight(newLight);
        }

        if (scn.cameras.length) { // single camera for the moment until we support it
            var cam = scn.cameras[0];
            var newCam = new Camera(camerasRef[cam.source]);
            newCam.position = cam.position;
            newCam.rotation = cam.rotation;

            sceneCameraMap[cam.id] = newCam;
            newScene.camera = newCam;
        }
        for (var p = 0, pMax = scn.parentMap.length; p < pMax; p++) {
            var pmap = scn.parentMap[p];
            sceneObjectMap[pmap.parent].bindChild(sceneObjectMap[pmap.child]);
        }

        scenesRef[scn.id] = newScene;
    }



    for (animId in clib.animations) {
        if (clib.animations.hasOwnProperty(animId)) {
            var anim = clib.animations[animId];

            if (anim.channels.length) {
                for (cCount = 0, cMax = anim.channels.length; cCount < cMax; cCount++) {
                    var chan = anim.channels[cCount];
                    var sampler = anim.samplers[chan.source];
                    var samplerInput = anim.sources[sampler["INPUT"]];
                    var samplerOutput = anim.sources[sampler["OUTPUT"]];
                    var samplerInterp = anim.sources[sampler["INTERPOLATION"]];
                    var samplerInTangent = anim.sources[sampler["IN_TANGENT"]];
                    var samplerOutTangent = anim.sources[sampler["OUT_TANGENT"]];
                    var hasInTangent = (sampler["IN_TANGENT"] !== undef);
                    var hasOutTangent = (sampler["OUT_TANGENT"] !== undef);
                    var mtn = null;

                    var targetSceneObject = sceneObjectMap[chan.targetName];
                    var targetCamera = sceneCameraMap[chan.targetName];
                    var targetLight = sceneLightMap[chan.targetName];

                    if (targetSceneObject) {
                        if (targetSceneObject.motion === null) {
                            targetSceneObject.motion = new Motion();
                        }
                        mtn = targetSceneObject.motion;
                    } else if (targetCamera) {
                        if (targetCamera.motion === null) {
                            targetCamera.motion = new Motion();
                        }

                        mtn = targetCamera.motion;
                    } else if (targetLight) {
                        if (targetLight.motion === null) {
                            targetLight.motion = new Motion();
                        }

                        mtn = targetLight.motion;
                    }
                    // else
                    // {
                    //   console.log("missing",chan.targetName);
                    //   console.log("missing",chan.paramName);
                    // }
                    if (mtn === null) {
                        continue;
                    }

                    var controlTarget = enums.motion.POS;
                    var motionTarget = enums.motion.X;

                    if (up_axis === 2) {
                        mtn.yzflip = true;
                    }

                    var pName = chan.paramName;

                    if (pName === "rotateX" || pName === "rotationX") {
                        controlTarget = enums.motion.ROT;
                        motionTarget = enums.motion.X;
                    } else if (pName === "rotateY" || pName === "rotationY") {
                        controlTarget = enums.motion.ROT;
                        motionTarget = enums.motion.Y;
                    } else if (pName === "rotateZ" || pName === "rotationZ") {
                        controlTarget = enums.motion.ROT;
                        motionTarget = enums.motion.Z;
                    } else if (pName === "location") {
                        controlTarget = enums.motion.POS;
                        if (chan.typeName === "X") {
                            motionTarget = enums.motion.X;
                        }
                        if (chan.typeName === "Y") {
                            motionTarget = enums.motion.Y;
                        }
                        if (chan.typeName === "Z") {
                            motionTarget = enums.motion.Z;
                        }
                    } else if (pName === "translate") {
                        controlTarget = enums.motion.POS;
                        if (chan.typeName === "X") {
                            motionTarget = enums.motion.X;
                        }
                        if (chan.typeName === "Y") {
                            motionTarget = enums.motion.Y;
                        }
                        if (chan.typeName === "Z") {
                            motionTarget = enums.motion.Z;
                        }
                    } else if (pName === "LENS") {
                        // controlTarget = enums.motion.LENS;
                        // motionTarget = 4;
                        controlTarget = 10;
                        motionTarget = 10;
                        continue; // disabled, only here for temporary collada files
                    } else if (pName === "FOV") {
                        controlTarget = enums.motion.FOV;
                        motionTarget = 3; // ensure no axis fixes are applied
                    } else if (pName === "ZNEAR") {
                        controlTarget = enums.motion.NEARCLIP;
                        motionTarget = 3; // ensure no axis fixes are applied
                    } else if (pName === "ZFAR") {
                        controlTarget = enums.motion.FARCLIP;
                        motionTarget = 3; // ensure no axis fixes are applied
                    } else if (pName === "intensity") {
                        controlTarget = enums.motion.INTENSITY;
                        motionTarget = 3; // ensure no axis fixes are applied
                    }

                    if (targetLight && controlTarget < 3) targetLight.method = enums.light.method.DYNAMIC;

                    // if (up_axis === 2 && motionTarget === enums.motion.Z) motionTarget = enums.motion.Y;
                    // else if (up_axis === 2 && motionTarget === enums.motion.Y) motionTarget = enums.motion.Z;
                    // 
                    var ival;
                    for (mCount = 0, mMax = samplerInput.data.length; mCount < mMax; mCount++) { // in the process of being deprecated
                        k = null;

                        if (typeof(samplerOutput.data[mCount]) === 'object') {
                            for (i = 0, iMax = samplerOutput.data[mCount].length; i < iMax; i++) {
                                ival = i;

                                if (up_axis === 2 && i === 2) {
                                    ival = 1;
                                } else if (up_axis === 2 && i === 1) {
                                    ival = 2;
                                }

                                k = mtn.setKey(controlTarget, ival, samplerInput.data[mCount], collada_tools.fixukaxis(clib.up_axis, controlTarget, ival, samplerOutput.data[mCount][i]));

                                if (samplerInterp) {
                                    var pInterp = samplerInterp.data[mCount][i];
                                    if (pInterp === "LINEAR") {
                                        k.shape = enums.envelope.shape.LINE;
                                    } else if (pInterp === "BEZIER") {
                                        if (!(hasInTangent || hasOutTangent)) {
                                            k.shape = enums.envelope.shape.LINEAR;
                                        } else {
                                            k.shape = enums.envelope.shape.BEZI;
                                        }
                                    }
                                }
                            }
                        } else {
                            ival = motionTarget;
                            ofs = 0;

                            if (targetCamera) {
                                if (controlTarget === enums.motion.ROT) {
                                    if (up_axis === 2 && ival === 0) {
                                        ofs = -90;
                                    }
                                }
                            }

                            if (controlTarget === enums.motion.ROT) {
                                k = mtn.setKey(controlTarget, ival, samplerInput.data[mCount], samplerOutput.data[mCount] + ofs);
                            } else {
                                if (up_axis === 2 && motionTarget === 2) {
                                    ival = 1;
                                } else if (up_axis === 2 && motionTarget === 1) {
                                    ival = 2;
                                }

                                k = mtn.setKey(controlTarget, ival, samplerInput.data[mCount], collada_tools.fixukaxis(clib.up_axis, controlTarget, ival, samplerOutput.data[mCount]));
                            }

                            if (samplerInterp) {
                                var pInterp = samplerInterp.data[mCount];
                                if (pInterp === "LINEAR") {
                                    k.shape = enums.envelope.shape.LINE;
                                } else if (pInterp === "BEZIER") {
                                    if (!(hasInTangent || hasOutTangent)) {
                                        k.shape = enums.envelope.shape.LINEAR;
                                        k.continutity = 1.0;
                                    } else {
                                        k.shape = enums.envelope.shape.BEZ2;

                                        var itx = samplerInTangent.data[mCount][0],
                                            ity;
                                        var otx = samplerOutTangent.data[mCount][0],
                                            oty;

                                        if (controlTarget === enums.motion.ROT) {
                                            ity = samplerInTangent.data[mCount][1];
                                            oty = samplerOutTangent.data[mCount][1];

                                            //  k.value = k.value/10;
                                            //  mtn.rscale = 10;
                                            k.param[0] = itx - k.time;
                                            k.param[1] = ity - k.value + ofs;
                                            k.param[2] = otx - k.time;
                                            k.param[3] = oty - k.value + ofs;
                                        } else {
                                            ity = collada_tools.fixukaxis(clib.up_axis, controlTarget, ival, samplerInTangent.data[mCount][1]);
                                            oty = collada_tools.fixukaxis(clib.up_axis, controlTarget, ival, samplerOutTangent.data[mCount][1]);

                                            k.param[0] = itx - k.time;
                                            k.param[1] = ity - k.value;
                                            k.param[2] = otx - k.time;
                                            k.param[3] = oty - k.value;
                                        }

                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }



    var sceneRef = null;

    if (clib.scene) {
        sceneRef = scenesRef[clib.scene];
    } else {
        sceneRef = scenesRef.pop();
    }


    return sceneRef;
}

function GML(srcUrl) {
  this.strokes = [];
  this.bounds = [1, 1, 1];
  this.origin = [0, 0, 0];
  this.upvector = [0, 1, 0];
  this.viewvector = [0, 0, 1];
  this.manual_pos = 0;

  if (srcUrl === undef) {
    return;
  }

  var gml = util.getXML(srcUrl);

  var gml_header = gml.getElementsByTagName("header");

  if (!gml_header.length) {
    return null;
  }

  var header = gml_header[0];

  var gml_environment = gml.getElementsByTagName("environment");


  if (!gml_environment.length) {
    return null;
  }

  this.name = null;

  var gml_name = header.getElementsByTagName("name");

  if (gml_name.length) {
    this.name = util.collectTextNode(gml_name[0]);
  }

  var gml_screenbounds = gml_environment[0].getElementsByTagName("screenBounds");

  if (gml_screenbounds.length) {
    this.bounds = [
      parseFloat(util.collectTextNode(gml_screenbounds[0].getElementsByTagName("x")[0])),
      parseFloat(util.collectTextNode(gml_screenbounds[0].getElementsByTagName("y")[0])),
      parseFloat(util.collectTextNode(gml_screenbounds[0].getElementsByTagName("z")[0]))
      ];
  }

  var gml_origin = gml_environment[0].getElementsByTagName("origin");

  if (gml_origin.length) {
    this.origin = [
      parseFloat(util.collectTextNode(gml_origin[0].getElementsByTagName("x")[0])),
      parseFloat(util.collectTextNode(gml_origin[0].getElementsByTagName("y")[0])),
      parseFloat(util.collectTextNode(gml_origin[0].getElementsByTagName("z")[0]))
      ];
  }

  var gml_upvector = gml_environment[0].getElementsByTagName("up");

  if (gml_upvector.length) {
    this.upvector = [
      parseFloat(util.collectTextNode(gml_upvector[0].getElementsByTagName("x")[0])),
      parseFloat(util.collectTextNode(gml_upvector[0].getElementsByTagName("y")[0])),
      parseFloat(util.collectTextNode(gml_upvector[0].getElementsByTagName("z")[0]))
      ];
  }

  var gml_drawings = gml.getElementsByTagName("drawing");

  var drawings = [];

  for (var dCount = 0, dMax = gml_drawings.length; dCount < dMax; dCount++) {
    var drawing = gml_drawings[dCount];
    var gml_strokes = drawing.getElementsByTagName("stroke");

    var xm = 0,
      ym = 0,
      zm = 0,
      tm = 0;

    for (var sCount = 0, sMax = gml_strokes.length; sCount < sMax; sCount++) {
      var gml_stroke = gml_strokes[sCount];
      var gml_points = gml_stroke.getElementsByTagName("pt");
      var plen = gml_points.length;

      var points = new Array(plen);
      var px, py, pz, pt;
      
      for (var pCount = 0, pMax = plen; pCount < pMax; pCount++) {
        var gml_point = gml_points[pCount];

        px = parseFloat(util.collectTextNode(gml_point.getElementsByTagName("x")[0]));
        py = parseFloat(util.collectTextNode(gml_point.getElementsByTagName("y")[0]));
        pz = parseFloat(util.collectTextNode(gml_point.getElementsByTagName("z")[0]));
        pt = parseFloat(util.collectTextNode(gml_point.getElementsByTagName("time")[0]));

        if (this.upvector[0] === 1) {
          points[pCount] = [(py !== py) ? 0 : py, (px !== px) ? 0 : -px, (pz !== pz) ? 0 : pz, pt];
        } else if (this.upvector[1] === 1) {
          points[pCount] = [(px !== px) ? 0 : px, (py !== py) ? 0 : py, (pz !== pz) ? 0 : pz, pt];
        } else if (this.upvector[2] === 1) {
          points[pCount] = [(px !== px) ? 0 : px, (pz !== pz) ? 0 : -pz, (py !== py) ? 0 : py, pt];
        }

        if (xm < px) {
          xm = px;
        }
        if (ym < py) {
          ym = py;
        }
        if (zm < pz) {
          zm = pz;
        }
        if (tm < pt) {
          tm = pt;
        }
      }

      if (zm > tm) { // fix swapped Z/Time
        for (var i = 0, iMax = points.length; i < iMax; i++) {
          var t = points[i][3];
          points[i][3] = points[i][2];
          points[i][2] = t / this.bounds[2];
        }
      }

      this.strokes[sCount] = points;
    }
  }
}

GML.prototype.addStroke = function(points, tstep) {
  var pts = [];

  if (tstep === undef) {
    tstep = 0.1;
  }

  for (var i = 0, iMax = points.length; i < iMax; i++) {
    var ta = [points[i][0], points[i][1], points[i][2]];
    this.manual_pos += tstep;
    ta.push(this.manual_pos);
    pts.push(ta);
  }

  this.strokes.push(pts);
};


GML.prototype.recenter = function() {
  var min = [0, 0, 0];
  var max = [this.strokes[0][0][0], this.strokes[0][0][1], this.strokes[0][0][2]];

  var i, iMax, s, sMax;

  for (s = 0, sMax = this.strokes.length; s < sMax; s++) {
    for (i = 0, iMax = this.strokes[s].length; i < iMax; i++) {
      if (min[0] > this.strokes[s][i][0]) {
        min[0] = this.strokes[s][i][0];
      }
      if (min[1] > this.strokes[s][i][1]) {
        min[1] = this.strokes[s][i][1];
      }
      if (min[2] > this.strokes[s][i][2]) {
        min[2] = this.strokes[s][i][2];
      }

      if (max[0] < this.strokes[s][i][0]) {
        max[0] = this.strokes[s][i][0];
      }
      if (max[1] < this.strokes[s][i][1]) {
        max[1] = this.strokes[s][i][1];
      }
      if (max[2] < this.strokes[s][i][2]) {
        max[2] = this.strokes[s][i][2];
      }
    }
  }

  var center = vec3.multiply(vec3.subtract(max, min), 0.5);

  for (s = 0, sMax = this.strokes.length; s < sMax; s++) {
    for (i = 0, iMax = this.strokes[s].length; i < iMax; i++) {
      this.strokes[s][i][0] = this.strokes[s][i][0] - center[0];
      this.strokes[s][i][1] = this.strokes[s][i][1] - (this.upvector[1] ? center[1] : (-center[1]));
      this.strokes[s][i][2] = this.strokes[s][i][2] - center[2];
    }
  }
};

GML.prototype.generateObject = function(seg_mod, extrude_depth, pwidth, divsper, do_zmove) {
  if (seg_mod === undef) {
    seg_mod = 0;
  }
  if (extrude_depth === undef) {
    extrude_depth = 0;
  }
  if (do_zmove === undef) {
    do_zmove = false;
  }
  
  

  // temporary defaults
  var divs = 3;
//  var divsper = 0.02;

  if (divsper === undef) divsper = 0.02;
//  var pwidth = 0.015;

  if (pwidth === undef) pwidth = 0.015;

  var extrude = extrude_depth !== 0;

  var segCount = 0;
  var faceSegment = 0;

  var obj = new Mesh(this.name);

  var lx, ly, lz, lt;

  var i, iMax, pCount;

  for (var sCount = 0, sMax = this.strokes.length; sCount < sMax; sCount++) {
    var strokeEnvX = new Envelope();
    var strokeEnvY = new Envelope();
    var strokeEnvZ = new Envelope();

    var pMax = this.strokes[sCount].length;

    var d = 0;
    var len_set = [];
    var time_set = [];
    var start_time = 0;
    var strk = this.strokes[sCount];

    for (pCount = 0; pCount < pMax; pCount++) {
      var pt = strk[pCount];

      var k1 = strokeEnvX.addKey(pt[3], pt[0]);
      var k2 = strokeEnvY.addKey(pt[3], pt[1]);
      var k3;
      
      if (do_zmove) {
        k3 = strokeEnvZ.addKey(pt[3], pt[2]);
      }
      else {
        k3 = strokeEnvZ.addKey(pt[3], 0);
      }

      k1.tension = 0.5;
      k2.tension = 0.5;
      k3.tension = 0.5;

      if (pCount !== 0) {
        var dx = pt[0] - lx;
        var dy = pt[1] - ly;
        var dz = pt[2] - lz;
        var dt = pt[3] - lt;
        var dlen = Math.sqrt(dx * dx + dy * dy + dz * dz);

        d += dlen;

        len_set[pCount-1] = dlen;
        time_set[pCount-1] = dt;
      } else {
        start_time = pt[3];
      }

      lx = pt[0];
      ly = pt[1];
      lz = pt[2];
      lt = pt[3];
    }

    var dpos = start_time;
    var ptofs = obj.points.length;

    for (pCount = 0; pCount < len_set.length; pCount++) {
      var segLen = len_set[pCount];
      var segTime = time_set[pCount];
      var segNum = Math.ceil((segLen / divsper) * divs);

      for (var t = dpos, tMax = dpos + segTime, tInc = (segTime / segNum); t < (tMax - tInc); t += tInc) {
        if (t === dpos) {
          lx = strokeEnvX.evaluate(t);
          ly = strokeEnvY.evaluate(t);
          lz = strokeEnvZ.evaluate(t);
        }

        var px, py, pz;

        px = strokeEnvX.evaluate(t + tInc);
        py = strokeEnvY.evaluate(t + tInc);
        pz = strokeEnvZ.evaluate(t + tInc);

        var pdx = (px - lx),
          pdy = py - ly,
          pdz = pz - lz;
        var pd = Math.sqrt(pdx * pdx + pdy * pdy + pdz * pdz);
        var a;

        a = vec3.multiply(
        vec3.normalize(
        vec3.cross(this.viewvector, vec3.normalize([pdx, pdy, pdz]))), pwidth / 2.0);

        obj.addPoint([lx - a[0], -(ly - a[1]), (lz - a[2]) + (extrude ? (extrude_depth / 2.0) : 0)]);
        obj.addPoint([lx + a[0], -(ly + a[1]), (lz + a[2]) + (extrude ? (extrude_depth / 2.0) : 0)]);

        lx = px;
        ly = py;
        lz = pz;
      }

      dpos += segTime;
    }

    var ptlen = obj.points.length;

    if (extrude) {
      for (i = ptofs, iMax = ptlen; i < iMax; i++) {
        obj.addPoint([obj.points[i][0], obj.points[i][1], obj.points[i][2] - (extrude ? (extrude_depth / 2.0) : 0)]);
      }
    }

    for (i = 0, iMax = ptlen - ptofs; i <= iMax - 4; i += 2) {
      if (segCount % seg_mod === 0) {
        faceSegment++;
      }

      obj.setSegment(faceSegment);

      var arFace = [ptofs + i, ptofs + i + 1, ptofs + i + 3, ptofs + i + 2];
      // var ftest = vec3.dot(this.viewvector, triangle.normal(obj.points[arFace[0]], obj.points[arFace[1]], obj.points[arFace[2]]));

      var faceNum = obj.addFace(arFace);

      // if (ftest < 0) {
      //   this.faces[faceNum].flip();
      // }

      if (extrude) {
        var arFace2 = [arFace[3] + ptlen - ptofs, arFace[2] + ptlen - ptofs, arFace[1] + ptlen - ptofs, arFace[0] + ptlen - ptofs];
        faceNum = obj.addFace(arFace2);

        arFace2 = [ptofs + i, ptofs + i + 2, ptofs + i + 2 + ptlen - ptofs, ptofs + i + ptlen - ptofs];
        faceNum = obj.addFace(arFace2);

        arFace2 = [ptofs + i + 1 + ptlen - ptofs, ptofs + i + 3 + ptlen - ptofs, ptofs + i + 3, ptofs + i + 1];
        faceNum = obj.addFace(arFace2);

        if (i === 0) {
          arFace2 = [ptofs + i + ptlen - ptofs, ptofs + i + 1 + ptlen - ptofs, ptofs + i + 1, ptofs + i];
          faceNum = obj.addFace(arFace2);
        }
        if (i === iMax - 4) {
          arFace2 = [ptofs + i + 2, ptofs + i + 3, ptofs + i + 3 + ptlen - ptofs, ptofs + i + 2 + ptlen - ptofs];
          faceNum = obj.addFace(arFace2);
        }
      }

      segCount++;
    }
  }


  obj.calcFaceNormals();

  obj.triangulateQuads();
  obj.calcNormals();
  obj.compile();

  return obj;
};


/* Particle System */

function Particle(pos, start_time, life_time, velocity, accel) {
  this.startpos = new Float32Array(pos);
  this.pos = new Float32Array(pos);
  this.velocity = new Float32Array((velocity !== undef) ? velocity : [0, 0, 0]);
  this.accel = new Float32Array((accel !== undef) ? accel : [0, 0, 0]);
  this.start_time = (start_time !== undef) ? start_time : 0;
  this.life_time = (life_time !== undef) ? life_time : 0;
  this.color = null;
  this.nextParticle = null;
}


function ParticleSystem(maxPts, hasColor, pTex, vWidth, vHeight, alpha, alphaCut) {
  var gl = GLCore.gl;

  if (!maxPts) {
    return;
  }

  this.particles = null;
  this.last_particle = null;
  this.pTex = (pTex !== undef) ? pTex : null;
  this.vWidth = vWidth;
  this.vHeight = vHeight;
  this.alpha = (alpha !== undef) ? alpha : false;
  this.alphaCut = (alphaCut !== undef) ? alphaCut : 0;

  this.pfunc = function(p, time) {
    var tdelta = time - p.start_time;

    if (tdelta < 0) {
      return 0;
    }
    if (tdelta > p.life_time && p.life_time) {
      return -1;
    }

    p.pos[0] = p.startpos[0] + (tdelta * p.velocity[0]) + (tdelta * tdelta * p.accel[0]);
    p.pos[1] = p.startpos[1] + (tdelta * p.velocity[1]) + (tdelta * tdelta * p.accel[1]);
    p.pos[2] = p.startpos[2] + (tdelta * p.velocity[2]) + (tdelta * tdelta * p.accel[2]);

    if (this.pgov !== null) {
      this.pgov(p, time);
    }

    return 1;
  };

  this.pgov = null;

  if (hasColor === undef) {
    this.hasColor = false;
  } else {
    this.hasColor = hasColor;
  }

  //    gl.enable(gl.VERTEX_PROGRAM_POINT_SIZE);
  var hasTex = (this.pTex !== null);

  this.vs = [
    "#ifdef GL_ES",
    "precision highp float;",
    "#endif",
    "attribute vec3 aVertexPosition;",
    this.hasColor ? "attribute vec3 aColor;" : "",
    "uniform mat4 uMVMatrix;",
    "uniform mat4 uPMatrix;",
    "varying vec4 color;",
    "varying vec2 screenPos;",
    hasTex ? "varying float pSize;" : "",
    "void main(void) {",
      "vec4 position = uPMatrix * uMVMatrix * vec4(aVertexPosition,1.0);",
      hasTex ? "screenPos=vec2(position.x/position.w,position.y/position.w);" : "",
      "gl_Position = position;",
      this.hasColor ? "color = vec4(aColor.r,aColor.g,aColor.b,1.0);" : "color = vec4(1.0,1.0,1.0,1.0);",
      hasTex ? "pSize=200.0/position.z;" : "float pSize=200.0/position.z;",
      "gl_PointSize = pSize;",
    "}"].join("\n");

  this.fs = [
    "#ifdef GL_ES",
    "precision highp float;",
    "#endif",

    hasTex ? "uniform sampler2D pMap;" : "",


    "varying vec4 color;",
    hasTex ? "varying vec2 screenPos;" : "",
    hasTex ? "uniform vec3 screenDim;" : "",
    hasTex ? "varying float pSize;" : "",

    "void main(void) {",
      "vec4 c = color;",
      hasTex ? "vec2 screen=vec2((gl_FragCoord.x/screenDim.x-0.5)*2.0,(gl_FragCoord.y/screenDim.y-0.5)*2.0);" : "",
      hasTex ? "vec2 pointCoord=vec2( ((screen.x-screenPos.x)/(pSize/screenDim.x))/2.0+0.5,((screen.y-screenPos.y)/(pSize/screenDim.y))/2.0+0.5);" : "",
      hasTex ? "vec4 tc = texture2D(pMap,pointCoord); gl_FragColor = vec4(c.rgb*tc.rgb,1.0);" : "gl_FragColor = c;",
    "}"].join("\n");

  this.maxPoints = maxPts;
  this.numParticles = 0;
  this.arPoints = new Float32Array(maxPts * 3);
  this.glPoints = null;

  if (hasColor) {
    this.arColor = new Float32Array(maxPts * 3);
    this.glColor = null;
  }

  this.shader_particle = new Shader(this.vs, this.fs);
  this.shader_particle.use();
  this.shader_particle.addVertexArray("aVertexPosition");

  if (this.hasColor) {
    this.shader_particle.addVertexArray("aColor");
  }

  this.shader_particle.addMatrix("uMVMatrix");
  this.shader_particle.addMatrix("uPMatrix");

  if (this.pTex !== null) {
    this.shader_particle.addInt("pMap", 0);
    this.shader_particle.addVector("screenDim");
    this.shader_particle.setVector("screenDim", [vWidth, vHeight, 0]);
  }

  this.genBuffer();
}


ParticleSystem.prototype.resizeView = function(vWidth, vHeight) {
  this.vWidth = vWidth;
  this.vHeight = vHeight;

  if (this.pTex !== null) {
    this.shader_particle.addVector("screenDim");
    this.shader_particle.setVector("screenDim", [vWidth, vHeight, 0]);
  }
};


ParticleSystem.prototype.addParticle = function(p) {
  if (this.last_particle === null) {
    this.particles = p;
    this.last_particle = p;
  } else {
    this.last_particle.nextParticle = p;
    this.last_particle = p;
  }
};

ParticleSystem.prototype.genBuffer = function() {
  var gl = GLCore.gl;

  this.glPoints = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, this.glPoints);
  gl.bufferData(gl.ARRAY_BUFFER, this.arPoints, gl.DYNAMIC_DRAW);

  if (this.hasColor) {
    this.glColor = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.glColor);
    gl.bufferData(gl.ARRAY_BUFFER, this.arColor, gl.DYNAMIC_DRAW);
  }
};

ParticleSystem.prototype.updatePoints = function() {
  var gl = GLCore.gl;

  // buffer update
  gl.bindBuffer(gl.ARRAY_BUFFER, this.glPoints);
  gl.bufferData(gl.ARRAY_BUFFER, this.arPoints, gl.DYNAMIC_DRAW);
  // end buffer update
};

ParticleSystem.prototype.updateColors = function() {
  var gl = GLCore.gl;

  if (!this.hasColor) {
    return;
  }
  // buffer update
  gl.bindBuffer(gl.ARRAY_BUFFER, this.glColor);
  gl.bufferData(gl.ARRAY_BUFFER, this.arColor, gl.DYNAMIC_DRAW);
  // end buffer update
};

ParticleSystem.prototype.draw = function(modelViewMat, projectionMat, time) {
  var gl = GLCore.gl;

  this.shader_particle.use();

  if (this.pTex !== null) {
    this.pTex.use(gl.TEXTURE0);
  }

  this.shader_particle.setMatrix("uMVMatrix", modelViewMat);
  this.shader_particle.setMatrix("uPMatrix", projectionMat);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

  gl.bindBuffer(gl.ARRAY_BUFFER, this.glPoints);
  gl.vertexAttribPointer(this.shader_particle.uniforms["aVertexPosition"], 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(this.shader_particle.uniforms["aVertexPosition"]);

  if (this.hasColor) {
    gl.bindBuffer(gl.ARRAY_BUFFER, this.glColor);
    gl.vertexAttribPointer(this.shader_particle.uniforms["aColor"], 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.shader_particle.uniforms["aColor"]);
  }

  if (time === undef) {
    time = 0;
  }

  if (this.particles === null) {
    gl.disable(gl.BLEND);
    return;
  }

  var p = this.particles;
  var lp = null;


  this.numParticles = 0;

  var c = 0;

  while (p !== null) {
    var ofs = this.numParticles * 3;
    var pf = this.pfunc(p, time);

    if (pf === 1) {
      this.arPoints[ofs] = p.pos[0];
      this.arPoints[ofs + 1] = p.pos[1];
      this.arPoints[ofs + 2] = p.pos[2];

      if (p.color !== null && this.arColor !== undef) {
        this.arColor[ofs] = p.color[0];
        this.arColor[ofs + 1] = p.color[1];
        this.arColor[ofs + 2] = p.color[2];
      }

      this.numParticles++;
      c++;
      if (this.numParticles === this.maxPoints) {
        break;
      }
    } else if (pf === -1) // particle death
    {
      if (lp !== null) {
        lp.nextParticle = p.nextParticle;
      }
    }
    else if (pf === 0) {
      c++;
    }

    lp = p;
    p = p.nextParticle;
  }

  if (!c) {
    this.particles = null;
    this.last_particle = null;
  }

  this.updatePoints();
  if (this.hasColor) {
    this.updateColors();
  }

  if (this.alpha) {
    gl.enable(gl.BLEND);
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(0);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
  }

  gl.drawArrays(gl.POINTS, 0, this.numParticles);

  if (this.alpha) {
    // gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.depthMask(1);
    gl.blendFunc(gl.ONE, gl.ONE);
  }
  
  if (this.hasColor) {
    gl.disableVertexAttribArray(this.shader_particle.uniforms["aColor"]);
  }
};

/* SkyBox */

function SkyBox(in_obj) {
  var texture = in_obj.texture;
  var mapping = in_obj.mapping;

  var that = this;

  this.mapping = null;
  this.ready = false;
  this.texture = null;

  this.onready = function() {
    texture.onready = null;
    var tw = 1/Images[that.texture.tex_id].width;
    var th = 1/Images[that.texture.tex_id].height;
    if (that.mapping === null) {
      that.mapping = [[1/3, 0.5, 2/3-tw, 1],//top
                      [0, 0.5, 1/3, 1],        //bottom
                      [0, 0, 1/3-tw, 0.5],  //left
                      [2/3, 0, 1, 0.5],        //right
                      [2/3+tw, 0.5, 1, 1],  //front
                      [1/3, 0, 2/3, 0.5]];     //back
    } //if

    var mat = new Material("skybox");
    var obj = new Mesh();
    obj.sky_mapping = that.mapping;
    cubicvr_boxObject(obj, 1, mat);
    obj.calcNormals();
    var mat_map = new UVMapper();
    mat_map.projection_mode = enums.uv.projection.SKY;
    mat_map.scale = [1, 1, 1];
    mat_map.apply(obj, mat);
    obj.triangulateQuads();
    obj.compile();
    mat.setTexture(texture);
    that.scene_object = new SceneObject(obj);

    that.ready = true;
  } //onready

  if (texture) {
    if (typeof(texture) === "string") {
      texture = new Texture(texture, null, null, null, this.onready);
    }
    else if (!texture.loaded){
      texture.onready = this.onready;
    } //if
    this.texture = texture;

    if (mapping) {
      this.mapping = mapping;
      this.onready();
    } //if
  } //if
} //cubicvr_SkyBox::Constructor




function View(obj_init) {
  
  this.texture = obj_init.texture?obj_init.texture:null;
  this.width = obj_init.width?obj_init.width:128;
  this.height = obj_init.height?obj_init.height:128;
  this.x = obj_init.x?obj_init.x:0;
  this.y = obj_init.y?obj_init.y:0;
  this.blend = obj_init.blend?obj_init.blend:false;
  this.opacity = (typeof(obj_init.opacity)!=='undefined')?obj_init.opacity:1.0;
  this.tint = obj_init.tint?obj_init.tint:[1.0,1.0,1.0];
  
  this.type='view';
  
  this.superView = null;
  this.childViews = [];
  this.panel = null;
}

View.prototype.addSubview = function(view) {
  this.childViews.push(view);
//  this.superView.makePanel(view);
  view.superView = this;
}

View.prototype.makePanel = function(view) {
  return this.superView.makePanel(view);
}

function Layout(obj_init) {
  
  this.texture = obj_init.texture?obj_init.texture:null;
  this.width = obj_init.width?obj_init.width:128;
  this.height = obj_init.height?obj_init.height:128;
  this.x = obj_init.x?obj_init.x:0;
  this.y = obj_init.y?obj_init.y:0;
  this.blend = obj_init.blend?obj_init.blend:false;
  this.opacity = (typeof(obj_init.opacity)!=='undefined')?obj_init.opacity:1.0;
  this.tint = obj_init.tint?obj_init.tint:[1.0,1.0,1.0];

  this.type = 'root';

  this.superView = null;
  this.childViews = [];
  this.setupShader();

  this.panel = null;
  this.makePanel(this);
}

Layout.prototype.setupShader = function() {
  
  this.shader = new CubicVR.PostProcessShader({
    shader_vertex: ["attribute vec3 aVertex;",
                "attribute vec2 aTex;",
                "varying vec2 vTex;",
                "uniform vec3 screen;",
                "uniform vec3 position;",
                "uniform vec3 size;",
                "void main(void) {",
                  "vTex = aTex;",
                  "vec4 vPos = vec4(aVertex.xyz,1.0);",
                  "vPos.x *= size.x/screen.x;",
                  "vPos.y *= size.y/screen.y;",
                  "vPos.x += (size.x/screen.x);",
                  "vPos.y -= (size.y/screen.y);",
                  "vPos.x += (position.x/screen.x)*2.0 - 1.0;",
                  "vPos.y -= (position.y/screen.y)*2.0 - 1.0;",
                  "gl_Position = vPos;",
                "}"].join("\n"),
    shader_fragment: [
      "#ifdef GL_ES",
      "precision highp float;",
      "#endif",
      "uniform sampler2D srcTex;",
      "uniform vec3 tint;",
      "varying vec2 vTex;",
      "void main(void) {",
      "vec4 color = texture2D(srcTex, vTex)*vec4(tint,1.0);",
      // "if (color.a == 0.0) discard;",
        "gl_FragColor = color;",
      "}"].join("\n"),
      init: function(shader)
      {
        shader.setInt("srcTex",0);
        shader.addVector("screen");
        shader.addVector("position");
        shader.addVector("tint");
        shader.addVector("size");
      }
  });
}

Layout.prototype.addSubview = function(view) {
  this.childViews.push(view);
//  this.makePanel(view);
  view.superView = this;
}

Layout.prototype.makePanel = function(view) {
  var gl = CubicVR.GLCore.gl;
  var pQuad = {}; // intentional empty object

  pQuad.vbo_points = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0]);
  pQuad.vbo_uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1]);

  pQuad.gl_points = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pQuad.gl_points);
  gl.bufferData(gl.ARRAY_BUFFER, pQuad.vbo_points, gl.STATIC_DRAW);

  pQuad.gl_uvs = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, pQuad.gl_uvs);
  gl.bufferData(gl.ARRAY_BUFFER, pQuad.vbo_uvs, gl.STATIC_DRAW);

  view.panel = pQuad;
}


Layout.prototype.renderPanel = function(view,panel) {
  var gl = CubicVR.GLCore.gl;

  if (!view.texture) {
    return false;
  }

  view.texture.use(gl.TEXTURE0);
};


Layout.prototype.renderView = function(view) {
  if (!view.texture) return;

  var gl = CubicVR.GLCore.gl;

  var offsetLeft = view.offsetLeft;
  var offsetTop = view.offsetTop;
  
  if (!offsetLeft) offsetLeft = 0;
  if (!offsetTop) offsetTop = 0;
  
  var shader = this.shader.shader;

  shader.use();
  shader.setVector("screen",[this.width,this.height,0]);
  shader.setVector("position",[view.x+offsetLeft,view.y+offsetTop,0]);
  shader.setVector("size",[view.width,view.height,0]);
  shader.setVector("tint",view.tint);

  if (view.blend) {
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
  }
  
  view.texture.use(gl.TEXTURE0);
  
//  this.renderPanel(view,this.panel);        
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  if (view.blend) {
    gl.disable(gl.BLEND);
    gl.blendFunc(gl.ONE,gl.ZERO);
  }
}



Layout.prototype.render = function() {
  var gl = CubicVR.GLCore.gl;
  
  gl.disable(gl.DEPTH_TEST);
  
  if (this.texture) this.renderView(this);
  
  var stack = [];
  var framestack = [];

  this.offsetLeft = 0, this.offsetTop = 0;
  stack.push(this);


  shader = this.shader.shader;
  shader.use();

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, this.panel.gl_points);
  gl.vertexAttribPointer(shader.uniforms["aVertex"], 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(shader.uniforms["aVertex"]);
  
  gl.bindBuffer(gl.ARRAY_BUFFER, this.panel.gl_uvs);
  gl.vertexAttribPointer(shader.uniforms["aTex"], 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(shader.uniforms["aTex"]);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  
  while (stack.length) {
    var view = stack.pop();

    this.renderView(view);
    
    if (view.childViews.length) {
      for (var i = view.childViews.length-1, iMin = 0; i >= iMin; i--) {
      view.childViews[i].offsetLeft = view.x+view.offsetLeft;
      view.childViews[i].offsetTop = view.y+view.offsetTop;
      stack.push(view.childViews[i]);
      }
    }
    
  }


  gl.disableVertexAttribArray(shader.uniforms["aTex"]);

  gl.enable(gl.DEPTH_TEST); 
}


// Full-screen quad related
var fsQuad = {
  make:makeFSQuad,
  destroy:destroyFSQuad,
  render:renderFSQuad
};



// Extend CubicVR module by adding public methods and classes
var extend = {
  init: GLCore.init,
  enums: enums,
  vec2: vec2,
  vec3: vec3,
  mat4: mat4,
  util: util,
  fsQuad: fsQuad,
  IdentityMatrix: cubicvr_identity,
  GLCore: GLCore,
  Timer: Timer,
  MainLoop: MainLoop,
  MouseViewController: MouseViewController,
  setMainLoop: setMainLoop,
  Transform: Transform,
  Light: Light,
  Texture: Texture,
  PJSTexture: PJSTexture,
  CanvasTexture: CanvasTexture,
  TextTexture: TextTexture,
  UVMapper: UVMapper,
  Scene: Scene,
  SceneObject: SceneObject,
  Face: Face,
  Material: Material,
  Materials: Materials,
  Textures: Textures,
  Textures_obj: Textures_obj,
  Images: Images,
  Shader: Shader,
  Landscape: Landscape,
  Camera: Camera,
  GML: GML,
  SkyBox: SkyBox,
  Envelope: Envelope,
  Motion: Motion,
  RenderBuffer: RenderBuffer,
  PostProcessFX: PostProcessFX,
  PostProcessChain: PostProcessChain,
  PostProcessShader: PostProcessShader,
  NormalMapGen: NormalMapGen,
  Particle: Particle,
  ParticleSystem: ParticleSystem,
  Octree: Octree,
  OctreeWorker: OctreeWorkerProxy,
  Quaternion: Quaternion,
  AutoCamera: AutoCamera,
  Mesh: Mesh,
  MeshPool: MeshPool,
  genPlaneObject: cubicvr_planeObject,
  genBoxObject: cubicvr_boxObject,
  genLatheObject: cubicvr_latheObject,
  genTorusObject: cubicvr_torusObject,
  genConeObject: cubicvr_coneObject,
  genCylinderObject: cubicvr_cylinderObject,
  genSphereObject: cubicvr_sphereObject,
  primitives: primitives,
  renderObject: cubicvr_renderObject,
  globalAmbient: [0.1, 0.1, 0.1],
  setGlobalAmbient: function(c) {
    CubicVR.globalAmbient = c;
  },
  loadMesh: cubicvr_loadMesh,
  DeferredBin: DeferredBin,
  DeferredLoadTexture: DeferredLoadTexture,
  loadCollada: cubicvr_loadCollada,
  loadColladaWorker: cubicvr_loadColladaWorker,
  setGlobalDepthAlpha: GLCore.setDepthAlpha,
  setDefaultFilter: GLCore.setDefaultFilter,
  Worker: CubicVR_Worker,
  Layout: Layout,
  View: View
};

for (var ext in extend) {
  if (extend.hasOwnProperty(ext)) {
    this.CubicVR[ext] = extend[ext];
  }
}

Materials.push(new Material("(null)"));
}());


</script>
		<script type="text/javascript">
/* 
 *  DSP.js - a comprehensive digital signal processing  library for javascript
 * 
 *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.
 *  Copyright 2010 Corban Brook. All rights reserved.
 *
 */

////////////////////////////////////////////////////////////////////////////////
//                                  CONSTANTS                                 //
////////////////////////////////////////////////////////////////////////////////

/**
 * DSP is an object which contains general purpose utility functions and constants
 */
var DSP = {
  // Channels
  LEFT:           0,
  RIGHT:          1,
  MIX:            2,

  // Waveforms
  SINE:           1,
  TRIANGLE:       2,
  SAW:            3,
  SQUARE:         4,

  // Filters
  LOWPASS:        0,
  HIGHPASS:       1,
  BANDPASS:       2,
  NOTCH:          3,

  // Window functions
  BARTLETT:       1,
  BARTLETTHANN:   2,
  BLACKMAN:       3,
  COSINE:         4,
  GAUSS:          5,
  HAMMING:        6,
  HANN:           7,
  LANCZOS:        8,
  RECTANGULAR:    9,
  TRIANGULAR:     10,

  // Loop modes
  OFF:            0,
  FW:             1,
  BW:             2,
  FWBW:           3,

  // Math
  TWO_PI:         2*Math.PI
};

// Setup arrays for platforms which do not support byte arrays
function setupTypedArray(name, fallback) {
  // check if TypedArray exists
  // typeof on Minefield and Chrome return function, typeof on Webkit returns object.
  if (typeof this[name] !== "function" && typeof this[name] !== "object") {
    // nope.. check if WebGLArray exists
    if (typeof this[fallback] === "function" && typeof this[fallback] !== "object") {
      this[name] = this[fallback];
    } else {
      // nope.. set as Native JS array
      this[name] = function(obj) {
        if (obj instanceof Array) {
          return obj;
        } else if (typeof obj === "number") {
          return new Array(obj);
        }
      };
    }
  }
}

setupTypedArray("Float32Array", "WebGLFloatArray");
setupTypedArray("Int32Array",   "WebGLIntArray");
setupTypedArray("Uint16Array",  "WebGLUnsignedShortArray");
setupTypedArray("Uint8Array",   "WebGLUnsignedByteArray");


////////////////////////////////////////////////////////////////////////////////
//                            DSP UTILITY FUNCTIONS                           //
////////////////////////////////////////////////////////////////////////////////

/**
 * Inverts the phase of a signal
 *
 * @param {Array} buffer A sample buffer
 *
 * @returns The inverted sample buffer
 */
DSP.invert = function(buffer) {
  for (var i = 0, len = buffer.length; i < len; i++) {
    buffer[i] *= -1;
  }

  return buffer;
};

/**
 * Converts split-stereo (dual mono) sample buffers into a stereo interleaved sample buffer
 *
 * @param {Array} left  A sample buffer
 * @param {Array} right A sample buffer
 *
 * @returns The stereo interleaved buffer
 */
DSP.interleave = function(left, right) {
  if (left.length !== right.length) {
    throw "Can not interleave. Channel lengths differ.";
  }
 
  var stereoInterleaved = new Float32Array(left.length * 2);
 
  for (var i = 0, len = left.length; i < len; i++) {
    stereoInterleaved[2*i]   = left[i];
    stereoInterleaved[2*i+1] = right[i];
  }
 
  return stereoInterleaved;
};

/**
 * Converts a stereo-interleaved sample buffer into split-stereo (dual mono) sample buffers
 *
 * @param {Array} buffer A stereo-interleaved sample buffer
 *
 * @returns an Array containing left and right channels
 */
DSP.deinterleave = (function() {
  var left, right, mix; 

  return function(buffer) { 
    left  = left  || new Float32Array(buffer.length/2);
    right = right || new Float32Array(buffer.length/2);
    mix   = mix   || new Float32Array(buffer.length/2);

    if (buffer.length/2 !== left.length) {
      left  = new Float32Array(buffer.length/2);
      right = new Float32Array(buffer.length/2);
      mix   = new Float32Array(buffer.length/2);
    }

    for (var i = 0, len = buffer.length/2; i < len; i++) {
      left[i]  = buffer[2*i];
      right[i] = buffer[2*i+1];
      mix[i]   = (left[i] + right[i]) / 2;
      //mix[i] = (buffer[2*i] + buffer[2*i+1]) /2;
    }
   
    return [left, right, mix];
  };
}());

/**
 * Separates a channel from a stereo-interleaved sample buffer
 *
 * @param {Array}  buffer A stereo-interleaved sample buffer
 * @param {Number} channel A channel constant (LEFT, RIGHT, MIX)
 *
 * @returns an Array containing a signal mono sample buffer
 */
DSP.getChannel = function(channel, buffer) {
  return DSP.deinterleave(buffer)[channel];
};

/**
 * Helper method (for Reverb) to mix two (interleaved) samplebuffers. It's possible
 * to negate the second buffer while mixing and to perform a volume correction
 * on the final signal.
 *
 * @param {Array} sampleBuffer1 Array containing Float values or a Float32Array
 * @param {Array} sampleBuffer2 Array containing Float values or a Float32Array
 * @param {Boolean} negate When true inverts/flips the audio signal
 * @param {Number} volumeCorrection When you add multiple sample buffers, use this to tame your signal ;)
 *
 * @returns A new Float32Array interleaved buffer.
 */
DSP.mixSampleBuffers = function(sampleBuffer1, sampleBuffer2, negate, volumeCorrection){
  var outputSamples = new Float32Array(sampleBuffer1);

  for(var i = 0; i<sampleBuffer1.length; i++){
    outputSamples[i] += (negate ? -sampleBuffer2[i] : sampleBuffer2[i]) / volumeCorrection;
  }
 
  return outputSamples;
}; 

// Biquad filter types
DSP.LPF = 0;                // H(s) = 1 / (s^2 + s/Q + 1)
DSP.HPF = 1;                // H(s) = s^2 / (s^2 + s/Q + 1)
DSP.BPF_CONSTANT_SKIRT = 2; // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
DSP.BPF_CONSTANT_PEAK = 3;  // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
DSP.NOTCH = 4;              // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
DSP.APF = 5;                // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
DSP.PEAKING_EQ = 6;         // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
DSP.LOW_SHELF = 7;          // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
DSP.HIGH_SHELF = 8;         // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)

// Biquad filter parameter types
DSP.Q = 1;
DSP.BW = 2; // SHARED with BACKWARDS LOOP MODE
DSP.S = 3;

// Find RMS of signal
DSP.RMS = function(buffer) {
  var total = 0;
  
  for (var i = 0, n = buffer.length; i < n; i++) {
    total += buffer[i] * buffer[i];
  }
  
  return Math.sqrt(total / n);
};

// Find Peak of signal
DSP.Peak = function(buffer) {
  var peak = 0;
  
  for (var i = 0, n = buffer.length; i < n; i++) {
    peak = (Math.abs(buffer[i]) > peak) ? Math.abs(buffer[i]) : peak; 
  }
  
  return peak;
};

// Fourier Transform Module used by DFT, FFT, RFT
function FourierTransform(bufferSize, sampleRate) {
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.bandwidth  = 2 / bufferSize * sampleRate / 2;

  this.spectrum   = new Float32Array(bufferSize/2);
  this.real       = new Float32Array(bufferSize);
  this.imag       = new Float32Array(bufferSize);

  this.peakBand   = 0;
  this.peak       = 0;

  /**
   * Calculates the *middle* frequency of an FFT band.
   *
   * @param {Number} index The index of the FFT band.
   *
   * @returns The middle frequency in Hz.
   */
  this.getBandFrequency = function(index) {
    return this.bandwidth * index + this.bandwidth / 2;
  };

  this.calculateSpectrum = function() {
    var spectrum  = this.spectrum,
        real      = this.real,
        imag      = this.imag,
        bSi       = 2 / this.bufferSize,
        sqrt      = Math.sqrt,
        rval, 
        ival,
        mag;

    for (var i = 0, N = bufferSize/2; i < N; i++) {
      rval = real[i];
      ival = imag[i];
      mag = bSi * sqrt(rval * rval + ival * ival);

      if (mag > this.peak) {
        this.peakBand = i;
        this.peak = mag;
      }

      spectrum[i] = mag;
    }
  };
}

/**
 * DFT is a class for calculating the Discrete Fourier Transform of a signal.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function DFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  var N = bufferSize/2 * bufferSize;
  var TWO_PI = 2 * Math.PI;

  this.sinTable = new Float32Array(N);
  this.cosTable = new Float32Array(N);

  for (var i = 0; i < N; i++) {
    this.sinTable[i] = Math.sin(i * TWO_PI / bufferSize);
    this.cosTable[i] = Math.cos(i * TWO_PI / bufferSize);
  }
}

/**
 * Performs a forward tranform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer
 *
 * @returns The frequency spectrum array
 */
DFT.prototype.forward = function(buffer) {
  var real = this.real, 
      imag = this.imag,
      rval,
      ival;

  for (var k = 0; k < this.bufferSize/2; k++) {
    rval = 0.0;
    ival = 0.0;

    for (var n = 0; n < buffer.length; n++) {
      rval += this.cosTable[k*n] * buffer[n];
      ival += this.sinTable[k*n] * buffer[n];
    }

    real[k] = rval;
    imag[k] = ival;
  }

  return this.calculateSpectrum();
};


/**
 * FFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function FFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);
   
  this.reverseTable     = new Uint32Array(bufferSize);

  var limit = 1;
  var bit = bufferSize >> 1;

  var i;

  while (limit < bufferSize) {
    for (i = 0; i < limit; i++) {
      this.reverseTable[i + limit] = this.reverseTable[i] + bit;
    }

    limit = limit << 1;
    bit = bit >> 1;
  }

  this.sinTable = new Float32Array(bufferSize);
  this.cosTable = new Float32Array(bufferSize);

  for (i = 0; i < bufferSize; i++) {
    this.sinTable[i] = Math.sin(-Math.PI/i);
    this.cosTable[i] = Math.cos(-Math.PI/i);
  }
}

/**
 * Performs a forward tranform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer. Buffer Length must be power of 2
 *
 * @returns The frequency spectrum array
 */
FFT.prototype.forward = function(buffer) {
  // Locally scope variables for speed up
  var bufferSize      = this.bufferSize,
      cosTable        = this.cosTable,
      sinTable        = this.sinTable,
      reverseTable    = this.reverseTable,
      real            = this.real,
      imag            = this.imag,
      spectrum        = this.spectrum;

  var k = Math.floor(Math.log(bufferSize) / Math.LN2);
  if (Math.pow(2, k) !== bufferSize) { throw "Invalid buffer size, must be a power of 2."; }
  if (bufferSize !== buffer.length) { throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length; }

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    real[i] = buffer[reverseTable[i]];
    imag[i] = 0;
  }

  while (halfSize < bufferSize) {
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];
    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }

    halfSize = halfSize << 1;
  }

  return this.calculateSpectrum();
};

FFT.prototype.inverse = function(real, imag) {
  // Locally scope variables for speed up
  var bufferSize      = this.bufferSize,
      cosTable        = this.cosTable,
      sinTable        = this.sinTable,
      reverseTable    = this.reverseTable,
      spectrum        = this.spectrum;
     
      real = real || this.real;
      imag = imag || this.imag;

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    imag[i] *= -1;
  }

  var revReal = new Float32Array(bufferSize);
  var revImag = new Float32Array(bufferSize);
 
  for (i = 0; i < real.length; i++) {
    revReal[i] = real[reverseTable[i]];
    revImag[i] = imag[reverseTable[i]];
  }
 
  real = revReal;
  imag = revImag;

  while (halfSize < bufferSize) {
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];
    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }

    halfSize = halfSize << 1;
  }

  var buffer = new Float32Array(bufferSize); // this should be reused instead
  for (i = 0; i < bufferSize; i++) {
    buffer[i] = real[i] / bufferSize;
  }

  return buffer;
};

/**
 * RFFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * This method currently only contains a forward transform but is highly optimized.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */

// lookup tables don't really gain us any speed, but they do increase
// cache footprint, so don't use them in here

// also we don't use sepearate arrays for real/imaginary parts

// this one a little more than twice as fast as the one in FFT
// however I only did the forward transform

// the rest of this was translated from C, see http://www.jjj.de/fxt/
// this is the real split radix FFT

function RFFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.trans = new Float32Array(bufferSize);

  // don't use a lookup table to do the permute, use this instead
  this.reverseBinPermute = function (d, s) {
    var nh = d.length >>> 1, nm1 = d.length - 1, x = 1, r = 0, h;

    d[0] = s[0];

    do {
      r = r + nh;
      //swap(a[x], a[r]);
      d[x] = s[r];
      d[r] = s[x];

      x++;
   
      h = nh;

      while (!((r ^= h) & h)) { 
        h = h >> 1;
      } 
      
      if (r >= x) { //swap(a[x], a[r]);
        d[x] = s[r]; 
        d[r] = s[x];
        d[nm1-x] = s[nm1-r]; 
        d[nm1-r] = s[nm1-x];
      }
      x++;
    } while (x < nh);
    d[nm1] = s[nm1];
  };
}


// Ordering of output:
//
// trans[0]     = re[0] (==zero frequency, purely real)
// trans[1]     = re[1]
//             ...
// trans[n/2-1] = re[n/2-1]
// trans[n/2]   = re[n/2]    (==nyquist frequency, purely real)
//
// trans[n/2+1] = im[n/2-1]
// trans[n/2+2] = im[n/2-2]
//             ...
// trans[n-1]   = im[1] 

RFFT.prototype.forward = function(buffer) {
  var n         = this.bufferSize, 
      spectrum  = this.spectrum,
      x         = this.trans, 
      TWO_PI    = 2*Math.PI,
      sqrt      = Math.sqrt,
      i         = n >>> 1,
      bSi       = 2 / n,
      n2, n4, n8, nn, 
      t1, t2, t3, t4, 
      i1, i2, i3, i4, i5, i6, i7, i8, 
      st1, cc1, ss1, cc3, ss3,
      e, 
      a,
      rval, ival, mag; 

  this.reverseBinPermute(x, buffer);

  for (var ix = 0, id = 4; ix < n; id *= 4) {
    for (var i0 = ix; i0 < n; i0 += id) {
      //sumdiff(x[i0], x[i0+1]); // {a, b}  <--| {a+b, a-b}
      st1 = x[i0] - x[i0+1];
      x[i0] += x[i0+1];
      x[i0+1] = st1;
    } 
    ix = 2*(id-1);
  }

  n2 = 2;
  nn = n >>> 1;

  while((nn = nn >>> 1)) {
    ix = 0;
    n2 = n2 << 1;
    id = n2 << 1;
    n4 = n2 >>> 2;
    n8 = n2 >>> 3;
    do {
      if(n4 !== 1) {
        for(i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;
     
          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4];
          x[i4] -= x[i3];
          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1; 
          x[i1] += t1;
     
          i1 += n8;
          i2 += n8;
          i3 += n8;
          i4 += n8;
         
          //sumdiff(x[i3], x[i4], t1, t2); // {s, d}  <--| {a+b, a-b}
          t1 = x[i3] + x[i4];
          t2 = x[i3] - x[i4];
         
          t1 = -t1 * Math.SQRT1_2;
          t2 *= Math.SQRT1_2;
     
          // sumdiff(t1, x[i2], x[i4], x[i3]); // {s, d}  <--| {a+b, a-b}
          st1 = x[i2];
          x[i4] = t1 + st1; 
          x[i3] = t1 - st1;
          
          //sumdiff3(x[i1], t2, x[i2]); // {a, b, d} <--| {a+b, b, a-b}
          x[i2] = x[i1] - t2;
          x[i1] += t2;
        }
      } else {
        for(i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;
     
          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4]; 
          x[i4] -= x[i3];
          
          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1; 
          x[i1] += t1;
        }
      }
   
      ix = (id << 1) - n2;
      id = id << 2;
    } while (ix < n);
 
    e = TWO_PI / n2;

    for (var j = 1; j < n8; j++) {
      a = j * e;
      ss1 = Math.sin(a);
      cc1 = Math.cos(a);
      
      //ss3 = sin(3*a); cc3 = cos(3*a);
      cc3 = 4*cc1*(cc1*cc1-0.75);
      ss3 = 4*ss1*(0.75-ss1*ss1);
   
      ix = 0; id = n2 << 1;
      do {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0 + j;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;
       
          i5 = i0 + n4 - j;
          i6 = i5 + n4;
          i7 = i6 + n4;
          i8 = i7 + n4;
       
          //cmult(c, s, x, y, &u, &v)
          //cmult(cc1, ss1, x[i7], x[i3], t2, t1); // {u,v} <--| {x*c-y*s, x*s+y*c}
          t2 = x[i7]*cc1 - x[i3]*ss1; 
          t1 = x[i7]*ss1 + x[i3]*cc1;
          
          //cmult(cc3, ss3, x[i8], x[i4], t4, t3);
          t4 = x[i8]*cc3 - x[i4]*ss3; 
          t3 = x[i8]*ss3 + x[i4]*cc3;
       
          //sumdiff(t2, t4);   // {a, b} <--| {a+b, a-b}
          st1 = t2 - t4;
          t2 += t4;
          t4 = st1;
          
          //sumdiff(t2, x[i6], x[i8], x[i3]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i6]; x[i8] = t2 + st1; x[i3] = t2 - st1;
          x[i8] = t2 + x[i6]; 
          x[i3] = t2 - x[i6];
         
          //sumdiff_r(t1, t3); // {a, b} <--| {a+b, b-a}
          st1 = t3 - t1;
          t1 += t3;
          t3 = st1;
          
          //sumdiff(t3, x[i2], x[i4], x[i7]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i2]; x[i4] = t3 + st1; x[i7] = t3 - st1;
          x[i4] = t3 + x[i2]; 
          x[i7] = t3 - x[i2];
         
          //sumdiff3(x[i1], t1, x[i6]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i6] = x[i1] - t1; 
          x[i1] += t1;
          
          //diffsum3_r(t4, x[i5], x[i2]); // {a, b, s} <--| {a, b-a, a+b}
          x[i2] = t4 + x[i5]; 
          x[i5] -= t4;
        }
     
        ix = id << 1 - n2;
        id = id << 2;
   
      } while (ix < n);
    }
  }

  while (--i) {
    rval = x[i];
    ival = x[n-i-1];
    mag = bSi * sqrt(rval * rval + ival * ival);

    if (mag > this.peak) {
      this.peakBand = i;
      this.peak = mag;
    }

    spectrum[i] = mag;
  }

  spectrum[0] = bSi * x[0];

  return spectrum;
};

function Sampler(file, bufferSize, sampleRate, playStart, playEnd, loopStart, loopEnd, loopMode) {
  this.file = file;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.playStart  = playStart || 0; // 0%
  this.playEnd    = playEnd   || 1; // 100%
  this.loopStart  = loopStart || 0;
  this.loopEnd    = loopEnd   || 1;
  this.loopMode   = loopMode  || DSP.OFF;
  this.loaded     = false;
  this.samples    = [];
  this.signal     = new Float32Array(bufferSize);
  this.frameCount = 0;
  this.envelope   = null;
  this.amplitude  = 1;
  this.rootFrequency = 110; // A2 110
  this.frequency  = 550;
  this.step       = this.frequency / this.rootFrequency;
  this.duration   = 0;
  this.samplesProcessed = 0;
  this.playhead   = 0;
 
  var audio = /* new Audio();*/ document.createElement("AUDIO");
  var self = this;
 
  this.loadSamples = function(event) {
    var buffer = DSP.getChannel(DSP.MIX, event.frameBuffer);
    for ( var i = 0; i < buffer.length; i++) {
      self.samples.push(buffer[i]);
    }
  };
 
  this.loadComplete = function() {
    // convert flexible js array into a fast typed array
    self.samples = new Float32Array(self.samples);
    self.loaded = true;
  };
 
  this.loadMetaData = function() {
    self.duration = audio.duration;
  };
 
  audio.addEventListener("MozAudioAvailable", this.loadSamples, false);
  audio.addEventListener("loadedmetadata", this.loadMetaData, false);
  audio.addEventListener("ended", this.loadComplete, false);
  audio.muted = true;
  audio.src = file;
  audio.play();
}

Sampler.prototype.applyEnvelope = function() {
  this.envelope.process(this.signal);
  return this.signal;
};

Sampler.prototype.generate = function() {
  var frameOffset = this.frameCount * this.bufferSize;
 
  var loopWidth = this.playEnd * this.samples.length - this.playStart * this.samples.length;
  var playStartSamples = this.playStart * this.samples.length; // ie 0.5 -> 50% of the length
  var playEndSamples = this.playEnd * this.samples.length; // ie 0.5 -> 50% of the length
  var offset;

  for ( var i = 0; i < this.bufferSize; i++ ) {
    switch (this.loopMode) {
      case DSP.OFF:
        this.playhead = Math.round(this.samplesProcessed * this.step + playStartSamples);
        if (this.playhead < (this.playEnd * this.samples.length) ) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        } else {
          this.signal[i] = 0;
        }
        break;
     
      case DSP.FW:
        this.playhead = Math.round((this.samplesProcessed * this.step) % loopWidth + playStartSamples);
        if (this.playhead < (this.playEnd * this.samples.length) ) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;
       
      case DSP.BW:
        this.playhead = playEndSamples - Math.round((this.samplesProcessed * this.step) % loopWidth);
        if (this.playhead < (this.playEnd * this.samples.length) ) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;
       
      case DSP.FWBW:
        if ( Math.floor(this.samplesProcessed * this.step / loopWidth) % 2 === 0 ) {
          this.playhead = Math.round((this.samplesProcessed * this.step) % loopWidth + playStartSamples);
        } else {
          this.playhead = playEndSamples - Math.round((this.samplesProcessed * this.step) % loopWidth);
        }  
        if (this.playhead < (this.playEnd * this.samples.length) ) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;
    }
    this.samplesProcessed++;
  }

  this.frameCount++;

  return this.signal;
};

Sampler.prototype.setFreq = function(frequency) {
  this.frequency = frequency;
  this.step = this.frequency / this.rootFrequency;
};

Sampler.prototype.reset = function() {
  this.samplesProcessed = 0;
  this.playhead = 0;
};

/**
 * Oscillator class for generating and modifying signals
 *
 * @param {Number} type       A waveform constant (eg. DSP.SINE)
 * @param {Number} frequency  Initial frequency of the signal
 * @param {Number} amplitude  Initial amplitude of the signal
 * @param {Number} bufferSize Size of the sample buffer to generate
 * @param {Number} sampleRate The sample rate of the signal
 *
 * @contructor
 */
function Oscillator(type, frequency, amplitude, bufferSize, sampleRate) {
  this.frequency  = frequency;
  this.amplitude  = amplitude;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  //this.pulseWidth = pulseWidth;
  this.frameCount = 0;
 
  this.waveTableLength = 2048;

  this.cyclesPerSample = frequency / sampleRate;

  this.signal = new Float32Array(bufferSize);
  this.envelope = null;

  switch(parseInt(type, 10)) {
    case DSP.TRIANGLE:
      this.func = Oscillator.Triangle;
      break;

    case DSP.SAW:
      this.func = Oscillator.Saw;
      break;

    case DSP.SQUARE:
      this.func = Oscillator.Square;
      break;

    default:
    case DSP.SINE:
      this.func = Oscillator.Sine;
      break;
  }

  this.generateWaveTable = function() {
    Oscillator.waveTable[this.func] = new Float32Array(2048);
    var waveTableTime = this.waveTableLength / this.sampleRate;
    var waveTableHz = 1 / waveTableTime;

    for (var i = 0; i < this.waveTableLength; i++) {
      Oscillator.waveTable[this.func][i] = this.func(i * waveTableHz/this.sampleRate);
    }
  };

  if ( typeof Oscillator.waveTable === 'undefined' ) {
    Oscillator.waveTable = {};
  }

  if ( typeof Oscillator.waveTable[this.func] === 'undefined' ) {
    this.generateWaveTable();
  }
 
  this.waveTable = Oscillator.waveTable[this.func];
}

/**
 * Set the amplitude of the signal
 *
 * @param {Number} amplitude The amplitude of the signal (between 0 and 1)
 */
Oscillator.prototype.setAmp = function(amplitude) {
  if (amplitude >= 0 && amplitude <= 1) {
    this.amplitude = amplitude;
  } else {
    throw "Amplitude out of range (0..1).";
  }
};
  
/**
 * Set the frequency of the signal
 *
 * @param {Number} frequency The frequency of the signal
 */  
Oscillator.prototype.setFreq = function(frequency) {
  this.frequency = frequency;
  this.cyclesPerSample = frequency / this.sampleRate;
};
     
// Add an oscillator
Oscillator.prototype.add = function(oscillator) {
  for ( var i = 0; i < this.bufferSize; i++ ) {
    //this.signal[i] += oscillator.valueAt(i);
    this.signal[i] += oscillator.signal[i];
  }
 
  return this.signal;
};
     
// Add a signal to the current generated osc signal
Oscillator.prototype.addSignal = function(signal) {
  for ( var i = 0; i < signal.length; i++ ) {
    if ( i >= this.bufferSize ) {
      break;
    }
    this.signal[i] += signal[i];
   
    /*
    // Constrain amplitude
    if ( this.signal[i] > 1 ) {
      this.signal[i] = 1;
    } else if ( this.signal[i] < -1 ) {
      this.signal[i] = -1;
    }
    */
  }
  return this.signal;
};
     
// Add an envelope to the oscillator
Oscillator.prototype.addEnvelope = function(envelope) {
  this.envelope = envelope;
};

Oscillator.prototype.applyEnvelope = function() {
  this.envelope.process(this.signal);
};
     
Oscillator.prototype.valueAt = function(offset) {
  return this.waveTable[offset % this.waveTableLength];
};
     
Oscillator.prototype.generate = function() {
  var frameOffset = this.frameCount * this.bufferSize;
  var step = this.waveTableLength * this.frequency / this.sampleRate;
  var offset;

  for ( var i = 0; i < this.bufferSize; i++ ) {
    //var step = (frameOffset + i) * this.cyclesPerSample % 1;
    //this.signal[i] = this.func(step) * this.amplitude;
    //this.signal[i] = this.valueAt(Math.round((frameOffset + i) * step)) * this.amplitude;
    offset = Math.round((frameOffset + i) * step);
    this.signal[i] = this.waveTable[offset % this.waveTableLength] * this.amplitude;
  }

  this.frameCount++;

  return this.signal;
};

Oscillator.Sine = function(step) {
  return Math.sin(DSP.TWO_PI * step);
};

Oscillator.Square = function(step) {
  return step < 0.5 ? 1 : -1;
};

Oscillator.Saw = function(step) {
  return 2 * (step - Math.round(step));
};

Oscillator.Triangle = function(step) {
  return 1 - 4 * Math.abs(Math.round(step) - step);
};

Oscillator.Pulse = function(step) {
  // stub
};
 
function ADSR(attackLength, decayLength, sustainLevel, sustainLength, releaseLength, sampleRate) {
  this.sampleRate = sampleRate;
  // Length in seconds
  this.attackLength  = attackLength;
  this.decayLength   = decayLength;
  this.sustainLevel  = sustainLevel;
  this.sustainLength = sustainLength;
  this.releaseLength = releaseLength;
  this.sampleRate    = sampleRate;
 
  // Length in samples
  this.attackSamples  = attackLength  * sampleRate;
  this.decaySamples   = decayLength   * sampleRate;
  this.sustainSamples = sustainLength * sampleRate;
  this.releaseSamples = releaseLength * sampleRate;
 
  // Updates the envelope sample positions
  this.update = function() {
    this.attack         =                this.attackSamples;
    this.decay          = this.attack  + this.decaySamples;
    this.sustain        = this.decay   + this.sustainSamples;
    this.release        = this.sustain + this.releaseSamples;
  };
 
  this.update();
 
  this.samplesProcessed = 0;
}

ADSR.prototype.noteOn = function() {
  this.samplesProcessed = 0;
  this.sustainSamples = this.sustainLength * this.sampleRate;
  this.update();
};

// Send a note off when using a sustain of infinity to let the envelope enter the release phase
ADSR.prototype.noteOff = function() {
  this.sustainSamples = this.samplesProcessed - this.decaySamples;
  this.update();
};

ADSR.prototype.processSample = function(sample) {
  var amplitude = 0;

  if ( this.samplesProcessed <= this.attack ) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if ( this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay ) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if ( this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain ) {
    amplitude = this.sustainLevel;
  } else if ( this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release ) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }
 
  return sample * amplitude;
};

ADSR.prototype.value = function() {
  var amplitude = 0;

  if ( this.samplesProcessed <= this.attack ) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if ( this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay ) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if ( this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain ) {
    amplitude = this.sustainLevel;
  } else if ( this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release ) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }
 
  return amplitude;
};
     
ADSR.prototype.process = function(buffer) {
  for ( var i = 0; i < buffer.length; i++ ) {
    buffer[i] *= this.value();

    this.samplesProcessed++;
  }
 
  return buffer;
};
     
     
ADSR.prototype.isActive = function() {
  if ( this.samplesProcessed > this.release || this.samplesProcessed === -1 ) {
    return false;
  } else {
    return true;
  }
};

ADSR.prototype.disable = function() {
  this.samplesProcessed = -1;
};
 
function IIRFilter(type, cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;

  switch(type) {
    case DSP.LOWPASS:
    case DSP.LP12:
      this.func = new IIRFilter.LP12(cutoff, resonance, sampleRate);
      break;
  }
}

IIRFilter.prototype.__defineGetter__('cutoff',
  function() {
    return this.func.cutoff;
  }
);

IIRFilter.prototype.__defineGetter__('resonance',
  function() {
    return this.func.resonance;
  }
);

IIRFilter.prototype.set = function(cutoff, resonance) {
  this.func.calcCoeff(cutoff, resonance);
};

IIRFilter.prototype.process = function(buffer) {
  this.func.process(buffer);
};

// Add an envelope to the filter
IIRFilter.prototype.addEnvelope = function(envelope) {
  if ( envelope instanceof ADSR ) {
    this.func.addEnvelope(envelope);
  } else {
    throw "Not an envelope.";
  }
};

IIRFilter.LP12 = function(cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;
  this.vibraPos   = 0;
  this.vibraSpeed = 0;
  this.envelope = false;
 
  this.calcCoeff = function(cutoff, resonance) {
    this.w = 2.0 * Math.PI * cutoff / this.sampleRate;
    this.q = 1.0 - this.w / (2.0 * (resonance + 0.5 / (1.0 + this.w)) + this.w - 2.0);
    this.r = this.q * this.q;
    this.c = this.r + 1.0 - 2.0 * Math.cos(this.w) * this.q;
   
    this.cutoff = cutoff;
    this.resonance = resonance;
  };

  this.calcCoeff(cutoff, resonance);

  this.process = function(buffer) {
    for ( var i = 0; i < buffer.length; i++ ) {
      this.vibraSpeed += (buffer[i] - this.vibraPos) * this.c;
      this.vibraPos   += this.vibraSpeed;
      this.vibraSpeed *= this.r;
   
      /*
      var temp = this.vibraPos;
     
      if ( temp > 1.0 ) {
        temp = 1.0;
      } else if ( temp < -1.0 ) {
        temp = -1.0;
      } else if ( temp != temp ) {
        temp = 1;
      }
     
      buffer[i] = temp;
      */

      if (this.envelope) {
        buffer[i] = (buffer[i] * (1 - this.envelope.value())) + (this.vibraPos * this.envelope.value());
        this.envelope.samplesProcessed++;
      } else {
        buffer[i] = this.vibraPos;
      }
    }
  };
}; 

IIRFilter.LP12.prototype.addEnvelope = function(envelope) {
  this.envelope = envelope;
};

function IIRFilter2(type, cutoff, resonance, sampleRate) {
  this.type = type;
  this.cutoff = cutoff;
  this.resonance = resonance;
  this.sampleRate = sampleRate;

  this.f = Float32Array(4);
  this.f[0] = 0.0; // lp
  this.f[1] = 0.0; // hp
  this.f[2] = 0.0; // bp
  this.f[3] = 0.0; // br 
 
  this.calcCoeff = function(cutoff, resonance) {
    this.freq = 2 * Math.sin(Math.PI * Math.min(0.25, cutoff/(this.sampleRate*2)));  
    this.damp = Math.min(2 * (1 - Math.pow(resonance, 0.25)), Math.min(2, 2/this.freq - this.freq * 0.5));
  };

  this.calcCoeff(cutoff, resonance);
}

IIRFilter2.prototype.process = function(buffer) {
  var input, output;
  var f = this.f;

  for ( var i = 0; i < buffer.length; i++ ) {
    input = buffer[i];

    // first pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output = 0.5 * f[this.type];

    // second pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output += 0.5 * f[this.type];

    if (this.envelope) {
      buffer[i] = (buffer[i] * (1 - this.envelope.value())) + (output * this.envelope.value());
      this.envelope.samplesProcessed++;
    } else {
      buffer[i] = output;
    }
  }
};

IIRFilter2.prototype.addEnvelope = function(envelope) {
  if ( envelope instanceof ADSR ) {
    this.envelope = envelope;
  } else {
    throw "This is not an envelope.";
  }
};

IIRFilter2.prototype.set = function(cutoff, resonance) {
  this.calcCoeff(cutoff, resonance);
};



function WindowFunction(type, alpha) {
  this.alpha = alpha;
 
  switch(type) {
    case DSP.BARTLETT:
      this.func = WindowFunction.Bartlett;
      break;
     
    case DSP.BARTLETTHANN:
      this.func = WindowFunction.BartlettHann;
      break;
     
    case DSP.BLACKMAN:
      this.func = WindowFunction.Blackman;
      this.alpha = this.alpha || 0.16;
      break;
   
    case DSP.COSINE:
      this.func = WindowFunction.Cosine;
      break;
     
    case DSP.GAUSS:
      this.func = WindowFunction.Gauss;
      this.alpha = this.alpha || 0.25;
      break;
     
    case DSP.HAMMING:
      this.func = WindowFunction.Hamming;
      break;
     
    case DSP.HANN:
      this.func = WindowFunction.Hann;
      break;
   
    case DSP.LANCZOS:
      this.func = WindowFunction.Lanczoz;
      break;
     
    case DSP.RECTANGULAR:
      this.func = WindowFunction.Rectangular;
      break;
     
    case DSP.TRIANGULAR:
      this.func = WindowFunction.Triangular;
      break;
  }
}

WindowFunction.prototype.process = function(buffer) {
  var length = buffer.length;
  for ( var i = 0; i < length; i++ ) {
    buffer[i] *= this.func(length, i, this.alpha);
  }
  return buffer;
};

WindowFunction.Bartlett = function(length, index) {
  return 2 / (length - 1) * ((length - 1) / 2 - Math.abs(index - (length - 1) / 2));
};

WindowFunction.BartlettHann = function(length, index) {
  return 0.62 - 0.48 * Math.abs(index / (length - 1) - 0.5) - 0.38 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Blackman = function(length, index, alpha) {
  var a0 = (1 - alpha) / 2;
  var a1 = 0.5;
  var a2 = alpha / 2;

  return a0 - a1 * Math.cos(DSP.TWO_PI * index / (length - 1)) + a2 * Math.cos(4 * Math.PI * index / (length - 1));
};

WindowFunction.Cosine = function(length, index) {
  return Math.cos(Math.PI * index / (length - 1) - Math.PI / 2);
};

WindowFunction.Gauss = function(length, index, alpha) {
  return Math.pow(Math.E, -0.5 * Math.pow((index - (length - 1) / 2) / (alpha * (length - 1) / 2), 2));
};

WindowFunction.Hamming = function(length, index) {
  return 0.54 - 0.46 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Hann = function(length, index) {
  return 0.5 * (1 - Math.cos(DSP.TWO_PI * index / (length - 1)));
};

WindowFunction.Lanczos = function(length, index) {
  var x = 2 * index / (length - 1) - 1;
  return Math.sin(Math.PI * x) / (Math.PI * x);
};

WindowFunction.Rectangular = function(length, index) {
  return 1;
};

WindowFunction.Triangular = function(length, index) {
  return 2 / length * (length / 2 - Math.abs(index - (length - 1) / 2));
};

function sinh (arg) {
  // Returns the hyperbolic sine of the number, defined as (exp(number) - exp(-number))/2 
  //
  // version: 1004.2314
  // discuss at: http://phpjs.org/functions/sinh    // +   original by: Onno Marsman
  // *     example 1: sinh(-0.9834330348825909);
  // *     returns 1: -1.1497971402636502
  return (Math.exp(arg) - Math.exp(-arg))/2;
}

/* 
 *  Biquad filter
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
// Implementation based on:
// http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
function Biquad(type, sampleRate) {
  this.Fs = sampleRate;
  this.type = type;  // type of the filter
  this.parameterType = DSP.Q; // type of the parameter

  this.x_1_l = 0;
  this.x_2_l = 0;
  this.y_1_l = 0;
  this.y_2_l = 0;

  this.x_1_r = 0;
  this.x_2_r = 0;
  this.y_1_r = 0;
  this.y_2_r = 0;

  this.b0 = 1;
  this.a0 = 1;

  this.b1 = 0;
  this.a1 = 0;

  this.b2 = 0;
  this.a2 = 0;

  this.b0a0 = this.b0 / this.a0;
  this.b1a0 = this.b1 / this.a0;
  this.b2a0 = this.b2 / this.a0;
  this.a1a0 = this.a1 / this.a0;
  this.a2a0 = this.a2 / this.a0;

  this.f0 = 3000;   // "wherever it's happenin', man."  Center Frequency or
                    // Corner Frequency, or shelf midpoint frequency, depending
                    // on which filter type.  The "significant frequency".

  this.dBgain = 12; // used only for peaking and shelving filters

  this.Q = 1;       // the EE kind of definition, except for peakingEQ in which A*Q is
                    // the classic EE Q.  That adjustment in definition was made so that
                    // a boost of N dB followed by a cut of N dB for identical Q and
                    // f0/Fs results in a precisely flat unity gain filter or "wire".

  this.BW = -3;     // the bandwidth in octaves (between -3 dB frequencies for BPF
                    // and notch or between midpoint (dBgain/2) gain frequencies for
                    // peaking EQ

  this.S = 1;       // a "shelf slope" parameter (for shelving EQ only).  When S = 1,
                    // the shelf slope is as steep as it can be and remain monotonically
                    // increasing or decreasing gain with frequency.  The shelf slope, in
                    // dB/octave, remains proportional to S for all other values for a
                    // fixed f0/Fs and dBgain.

  this.coefficients = function() {
    var b = [this.b0, this.b1, this.b2];
    var a = [this.a0, this.a1, this.a2];
    return {b: b, a:a};
  };

  this.setFilterType = function(type) {
    this.type = type;
    this.recalculateCoefficients();
  };

  this.setSampleRate = function(rate) {
    this.Fs = rate;
    this.recalculateCoefficients();
  };

  this.setQ = function(q) {
    this.parameterType = DSP.Q;
    this.Q = Math.max(Math.min(q, 115.0), 0.001);
    this.recalculateCoefficients();
  };

  this.setBW = function(bw) {
    this.parameterType = DSP.BW;
    this.BW = bw;
    this.recalculateCoefficients();
  };

  this.setS = function(s) {
    this.parameterType = DSP.S;
    this.S = Math.max(Math.min(s, 5.0), 0.0001);
    this.recalculateCoefficients();
  };

  this.setF0 = function(freq) {
    this.f0 = freq;
    this.recalculateCoefficients();
  }; 
 
  this.setDbGain = function(g) {
    this.dBgain = g;
    this.recalculateCoefficients();
  };

  this.recalculateCoefficients = function() {
    var A;
    if (type === DSP.PEAKING_EQ || type === DSP.LOW_SHELF || type === DSP.HIGH_SHELF ) {
      A = Math.pow(10, (this.dBgain/40));  // for peaking and shelving EQ filters only
    } else {
      A  = Math.sqrt( Math.pow(10, (this.dBgain/20)) );   
    }

    var w0 = DSP.TWO_PI * this.f0 / this.Fs;

    var cosw0 = Math.cos(w0);
    var sinw0 = Math.sin(w0);

    var alpha = 0;
   
    switch (this.parameterType) {
      case DSP.Q:
        alpha = sinw0/(2*this.Q);
        break;
           
      case DSP.BW:
        alpha = sinw0 * sinh( Math.LN2/2 * this.BW * w0/sinw0 );
        break;

      case DSP.S:
        alpha = sinw0/2 * Math.sqrt( (A + 1/A)*(1/this.S - 1) + 2 );
        break;
    }

    /**
        FYI: The relationship between bandwidth and Q is
             1/Q = 2*sinh(ln(2)/2*BW*w0/sin(w0))     (digital filter w BLT)
        or   1/Q = 2*sinh(ln(2)/2*BW)             (analog filter prototype)

        The relationship between shelf slope and Q is
             1/Q = sqrt((A + 1/A)*(1/S - 1) + 2)
    */

    var coeff;

    switch (this.type) {
      case DSP.LPF:       // H(s) = 1 / (s^2 + s/Q + 1)
        this.b0 =  (1 - cosw0)/2;
        this.b1 =   1 - cosw0;
        this.b2 =  (1 - cosw0)/2;
        this.a0 =   1 + alpha;
        this.a1 =  -2 * cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.HPF:       // H(s) = s^2 / (s^2 + s/Q + 1)
        this.b0 =  (1 + cosw0)/2;
        this.b1 = -(1 + cosw0);
        this.b2 =  (1 + cosw0)/2;
        this.a0 =   1 + alpha;
        this.a1 =  -2 * cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.BPF_CONSTANT_SKIRT:       // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
        this.b0 =   sinw0/2;
        this.b1 =   0;
        this.b2 =  -sinw0/2;
        this.a0 =   1 + alpha;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.BPF_CONSTANT_PEAK:       // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
        this.b0 =   alpha;
        this.b1 =   0;
        this.b2 =  -alpha;
        this.a0 =   1 + alpha;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.NOTCH:     // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
        this.b0 =   1;
        this.b1 =  -2*cosw0;
        this.b2 =   1;
        this.a0 =   1 + alpha;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.APF:       // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
        this.b0 =   1 - alpha;
        this.b1 =  -2*cosw0;
        this.b2 =   1 + alpha;
        this.a0 =   1 + alpha;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha;
        break;

      case DSP.PEAKING_EQ:  // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
        this.b0 =   1 + alpha*A;
        this.b1 =  -2*cosw0;
        this.b2 =   1 - alpha*A;
        this.a0 =   1 + alpha/A;
        this.a1 =  -2*cosw0;
        this.a2 =   1 - alpha/A;
        break;

      case DSP.LOW_SHELF:   // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
        coeff = sinw0 * Math.sqrt( (A^2 + 1)*(1/this.S - 1) + 2*A );
        this.b0 =    A*((A+1) - (A-1)*cosw0 + coeff);
        this.b1 =  2*A*((A-1) - (A+1)*cosw0);
        this.b2 =    A*((A+1) - (A-1)*cosw0 - coeff);
        this.a0 =       (A+1) + (A-1)*cosw0 + coeff;
        this.a1 =   -2*((A-1) + (A+1)*cosw0);
        this.a2 =       (A+1) + (A-1)*cosw0 - coeff;
        break;

      case DSP.HIGH_SHELF:   // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)
        coeff = sinw0 * Math.sqrt( (A^2 + 1)*(1/this.S - 1) + 2*A );
        this.b0 =    A*((A+1) + (A-1)*cosw0 + coeff);
        this.b1 = -2*A*((A-1) + (A+1)*cosw0);
        this.b2 =    A*((A+1) + (A-1)*cosw0 - coeff);
        this.a0 =       (A+1) - (A-1)*cosw0 + coeff;
        this.a1 =    2*((A-1) - (A+1)*cosw0);
        this.a2 =       (A+1) - (A-1)*cosw0 - coeff;
        break;
    }
   
    this.b0a0 = this.b0/this.a0;
    this.b1a0 = this.b1/this.a0;
    this.b2a0 = this.b2/this.a0;
    this.a1a0 = this.a1/this.a0;
    this.a2a0 = this.a2/this.a0;
  };

  this.process = function(buffer) {
      //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
      //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

      var len = buffer.length;
      var output = new Float32Array(len);

      for ( var i=0; i<buffer.length; i++ ) {
        output[i] = this.b0a0*buffer[i] + this.b1a0*this.x_1_l + this.b2a0*this.x_2_l - this.a1a0*this.y_1_l - this.a2a0*this.y_2_l;
        this.y_2_l = this.y_1_l;
        this.y_1_l = output[i];
        this.x_2_l = this.x_1_l;
        this.x_1_l = buffer[i];
      }

      return output;
  };

  this.processStereo = function(buffer) {
      //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
      //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

      var len = buffer.length;
      var output = new Float32Array(len);
     
      for (var i = 0; i < len/2; i++) {
        output[2*i] = this.b0a0*buffer[2*i] + this.b1a0*this.x_1_l + this.b2a0*this.x_2_l - this.a1a0*this.y_1_l - this.a2a0*this.y_2_l;
        this.y_2_l = this.y_1_l;
        this.y_1_l = output[2*i];
        this.x_2_l = this.x_1_l;
        this.x_1_l = buffer[2*i];

        output[2*i+1] = this.b0a0*buffer[2*i+1] + this.b1a0*this.x_1_r + this.b2a0*this.x_2_r - this.a1a0*this.y_1_r - this.a2a0*this.y_2_r;
        this.y_2_r = this.y_1_r;
        this.y_1_r = output[2*i+1];
        this.x_2_r = this.x_1_r;
        this.x_1_r = buffer[2*i+1];
      }

      return output;
  };
}

/* 
 *  Magnitude to decibels
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  @buffer array of magnitudes to convert to decibels
 *
 *  @returns the array in decibels
 *
 */
DSP.mag2db = function(buffer) {
  var minDb = -120;
  var minMag = Math.pow(10.0, minDb / 20.0);

  var log = Math.log;
  var max = Math.max;
 
  var result = Float32Array(buffer.length);
  for (var i=0; i<buffer.length; i++) {
    result[i] = 20.0*log(max(buffer[i], minMag));
  }

  return result;
};

/* 
 *  Frequency response
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  Calculates the frequency response at the given points.
 *
 *  @b b coefficients of the filter
 *  @a a coefficients of the filter
 *  @w w points (normally between -PI and PI) where to calculate the frequency response
 *
 *  @returns the frequency response in magnitude
 *
 */
DSP.freqz = function(b, a, w) {
  var i, j;

  if (!w) {
    w = Float32Array(200);
    for (i=0;i<w.length; i++) {
      w[i] = DSP.TWO_PI/w.length * i - Math.PI;
    }
  }

  var result = Float32Array(w.length);
 
  var sqrt = Math.sqrt;
  var cos = Math.cos;
  var sin = Math.sin;
 
  for (i=0; i<w.length; i++) {
    var numerator = {real:0.0, imag:0.0};
    for (j=0; j<b.length; j++) {
      numerator.real += b[j] * cos(-j*w[i]);
      numerator.imag += b[j] * sin(-j*w[i]);
    }

    var denominator = {real:0.0, imag:0.0};
    for (j=0; j<a.length; j++) {
      denominator.real += a[j] * cos(-j*w[i]);
      denominator.imag += a[j] * sin(-j*w[i]);
    }
 
    result[i] =  sqrt(numerator.real*numerator.real + numerator.imag*numerator.imag) / sqrt(denominator.real*denominator.real + denominator.imag*denominator.imag);
  }

  return result;
};

/* 
 *  Graphical Equalizer
 *
 *  Implementation of a graphic equalizer with a configurable bands-per-octave
 *  and minimum and maximum frequencies
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
function GraphicalEq(sampleRate) {
  this.FS = sampleRate;
  this.minFreq = 40.0;
  this.maxFreq = 16000.0;

  this.bandsPerOctave = 1.0;

  this.filters = [];
  this.freqzs = [];

  this.calculateFreqzs = true;

  this.recalculateFilters = function() {
    var bandCount = Math.round(Math.log(this.maxFreq/this.minFreq) * this.bandsPerOctave/ Math.LN2);

    this.filters = [];
    for (var i=0; i<bandCount; i++) {
      var freq = this.minFreq*(Math.pow(2, i/this.bandsPerOctave));
      var newFilter = new Biquad(DSP.PEAKING_EQ, this.FS);
      newFilter.setDbGain(0);
      newFilter.setBW(1/this.bandsPerOctave);
      newFilter.setF0(freq);
      this.filters[i] = newFilter;
      this.recalculateFreqz(i);
    }
  };

  this.setMinimumFrequency = function(freq) {
    this.minFreq = freq;
    this.recalculateFilters();
  };

  this.setMaximumFrequency = function(freq) {
    this.maxFreq = freq;
    this.recalculateFilters();
  };

  this.setBandsPerOctave = function(bands) {
    this.bandsPerOctave = bands;
    this.recalculateFilters();
  };

  this.setBandGain = function(bandIndex, gain) {
    if (bandIndex < 0 || bandIndex > (this.filters.length-1)) {
      throw "The band index of the graphical equalizer is out of bounds.";
    }

    if (!gain) {
      throw "A gain must be passed.";
    }
   
    this.filters[bandIndex].setDbGain(gain);
    this.recalculateFreqz(bandIndex);
  };
 
  this.recalculateFreqz = function(bandIndex) {
    if (!this.calculateFreqzs) {
      return;
    }

    if (bandIndex < 0 || bandIndex > (this.filters.length-1)) {
      throw "The band index of the graphical equalizer is out of bounds. " + bandIndex + " is out of [" + 0 + ", " + this.filters.length-1 + "]";
    }
       
    if (!this.w) {
      this.w = Float32Array(400);
      for (var i=0; i<this.w.length; i++) {
         this.w[i] = Math.PI/this.w.length * i;
      }
    }
   
    var b = [this.filters[bandIndex].b0, this.filters[bandIndex].b1, this.filters[bandIndex].b2];
    var a = [this.filters[bandIndex].a0, this.filters[bandIndex].a1, this.filters[bandIndex].a2];

    this.freqzs[bandIndex] = DSP.mag2db(DSP.freqz(b, a, this.w));
  };

  this.process = function(buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].process(output);
    }

    return output;
  };

  this.processStereo = function(buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].processStereo(output);
    }

    return output;
  };
}

/**
 * MultiDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/delay-firefox-audio-api/
 *
 * This is a delay that feeds it's own delayed signal back into its circular
 * buffer. Also known as a CombFilter.
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */
function MultiDelay(maxDelayInSamplesSize, delayInSamples, masterVolume, delayVolume) {
  this.delayBufferSamples   = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer     = delayInSamples;
  this.delayOutputPointer   = 0;
 
  this.delayInSamples   = delayInSamples;
  this.masterVolume     = masterVolume;
  this.delayVolume     = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
MultiDelay.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;
 
  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length; 
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setMasterVolume = function(masterVolume) {
  this.masterVolume = masterVolume;
};

/**
 * Change the delay feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setDelayVolume = function(delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and adds the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
MultiDelay.prototype.process = function(samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i=0; i<samples.length; i++) {
    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = (this.delayBufferSamples[this.delayOutputPointer] === null ? 0.0 : this.delayBufferSamples[this.delayOutputPointer]);
   
    // Mix normal audio data with delayed audio
    var sample = (delaySample * this.delayVolume) + samples[i];
   
    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = sample;
   
    // Return the audio with delay mix
    outputSamples[i] = sample * this.masterVolume;
   
    // Manage circulair delay buffer pointers
    this.delayInputPointer++;
    if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
      this.delayInputPointer = 0;
    }
     
    this.delayOutputPointer++;
    if (this.delayOutputPointer >= this.delayBufferSamples.length-1) {
      this.delayOutputPointer = 0; 
    } 
  }
 
  return outputSamples;
};

/**
 * SingleDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: See usage in Reverb class
 *
 * This is a delay that does NOT feeds it's own delayed signal back into its 
 * circular buffer, neither does it return the original signal. Also known as
 * an AllPassFilter(?).
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */

function SingleDelay(maxDelayInSamplesSize, delayInSamples, delayVolume) {
  this.delayBufferSamples = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer  = delayInSamples;
  this.delayOutputPointer = 0;
 
  this.delayInSamples     = delayInSamples;
  this.delayVolume        = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
SingleDelay.prototype.setDelayInSamples = function(delayInSamples) {
  this.delayInSamples = delayInSamples;
  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length; 
  }
};

/**
 * Change the return signal volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
SingleDelay.prototype.setDelayVolume = function(delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and
 * returns the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
SingleDelay.prototype.process = function(samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i=0; i<samples.length; i++) {

    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = samples[i];
   
    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = this.delayBufferSamples[this.delayOutputPointer];

    // Return the audio with delay mix
    outputSamples[i] = delaySample * this.delayVolume;

    // Manage circulair delay buffer pointers
    this.delayInputPointer++;

    if (this.delayInputPointer >= this.delayBufferSamples.length-1) {
      this.delayInputPointer = 0;
    }
     
    this.delayOutputPointer++;

    if (this.delayOutputPointer >= this.delayBufferSamples.length-1) {
      this.delayOutputPointer = 0; 
    } 
  }
 
  return outputSamples;
};

/**
 * Reverb effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/reverb-firefox-audio-api/
 *
 * This reverb consists of 6 SingleDelays, 6 MultiDelays and an IIRFilter2
 * for each of the two stereo channels.
 *
 * Compatible with interleaved stereo buffers only!
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffers)
 * @param {Number} delayInSamples Initial delay in samples for internal (Single/Multi)delays
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} mixVolume Initial reverb signal mix volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume for internal (Single/Multi)delays. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} dampFrequency Initial low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 *
 * @constructor
 */
function Reverb(maxDelayInSamplesSize, delayInSamples, masterVolume, mixVolume, delayVolume, dampFrequency) {
  this.delayInSamples   = delayInSamples;
  this.masterVolume     = masterVolume;
  this.mixVolume       = mixVolume;
  this.delayVolume     = delayVolume;
  this.dampFrequency     = dampFrequency;
 
  this.NR_OF_MULTIDELAYS = 6;
  this.NR_OF_SINGLEDELAYS = 6;
 
  this.LOWPASSL = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);
  this.LOWPASSR = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);
 
  this.singleDelays = [];
  
  var i, delayMultiply;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + (i/7.0); // 1.0, 1.1, 1.2...
    this.singleDelays[i] = new SingleDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.delayVolume);
  }
 
  this.multiDelays = [];

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + (i/10.0); // 1.0, 1.1, 1.2... 
    this.multiDelays[i] = new MultiDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.masterVolume, this.delayVolume);
  }
}

/**
 * Change the delay time in samples as a base for all delays.
 *
 * @param {Number} delayInSamples Delay in samples
 */
Reverb.prototype.setDelayInSamples = function (delayInSamples){
  this.delayInSamples = delayInSamples;

  var i, delayMultiply;
 
  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + (i/7.0); // 1.0, 1.1, 1.2...
    this.singleDelays[i].setDelayInSamples( Math.round(this.delayInSamples * delayMultiply) );
  }
   
  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + (i/10.0); // 1.0, 1.1, 1.2...
    this.multiDelays[i].setDelayInSamples( Math.round(this.delayInSamples * delayMultiply) );
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMasterVolume = function (masterVolume){
  this.masterVolume = masterVolume;
};

/**
 * Change the reverb signal mix level.
 *
 * @param {Number} mixVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMixVolume = function (mixVolume){
  this.mixVolume = mixVolume;
};

/**
 * Change all delays feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setDelayVolume = function (delayVolume){
  this.delayVolume = delayVolume;
 
  var i;

  for (i = 0; i<this.NR_OF_SINGLEDELAYS; i++) {
    this.singleDelays[i].setDelayVolume(this.delayVolume);
  } 
 
  for (i = 0; i<this.NR_OF_MULTIDELAYS; i++) {
    this.multiDelays[i].setDelayVolume(this.delayVolume);
  } 
};

/**
 * Change the Low Pass filter frequency.
 *
 * @param {Number} dampFrequency low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 */
Reverb.prototype.setDampFrequency = function (dampFrequency){
  this.dampFrequency = dampFrequency;
 
  this.LOWPASSL.set(dampFrequency, 0);
  this.LOWPASSR.set(dampFrequency, 0); 
};

/**
 * Process a given interleaved float value Array and copies and adds the reverb signal.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved buffer.
 */
Reverb.prototype.process = function (interleavedSamples){ 
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(interleavedSamples.length);
 
  // Perform low pass on the input samples to mimick damp
  var leftRightMix = DSP.deinterleave(interleavedSamples);
  this.LOWPASSL.process( leftRightMix[DSP.LEFT] );
  this.LOWPASSR.process( leftRightMix[DSP.RIGHT] ); 
  var filteredSamples = DSP.interleave(leftRightMix[DSP.LEFT], leftRightMix[DSP.RIGHT]);

  var i;

  // Process MultiDelays in parallel
  for (i = 0; i<this.NR_OF_MULTIDELAYS; i++) {
    // Invert the signal of every even multiDelay
    outputSamples = DSP.mixSampleBuffers(outputSamples, this.multiDelays[i].process(filteredSamples), 2%i === 0, this.NR_OF_MULTIDELAYS);
  }
 
  // Process SingleDelays in series
  var singleDelaySamples = new Float32Array(outputSamples.length);
  for (i = 0; i<this.NR_OF_SINGLEDELAYS; i++) {
    // Invert the signal of every even singleDelay
    singleDelaySamples = DSP.mixSampleBuffers(singleDelaySamples, this.singleDelays[i].process(outputSamples), 2%i === 0, 1);
  }

  // Apply the volume of the reverb signal
  for (i = 0; i<singleDelaySamples.length; i++) {
    singleDelaySamples[i] *= this.mixVolume;
  }
 
  // Mix the original signal with the reverb signal
  outputSamples = DSP.mixSampleBuffers(singleDelaySamples, interleavedSamples, 0, 1);

  // Apply the master volume to the complete signal
  for (i = 0; i<outputSamples.length; i++) {
    outputSamples[i] *= this.masterVolume;
  }
   
  return outputSamples;
};


</script>
		<script type="text/javascript">
(function(global, document) {

  //  Cache refs to speed up calls to native utils
  var
  forEach = Array.prototype.forEach,
  hasOwn = Object.prototype.hasOwnProperty,
  slice = Array.prototype.slice,
  toString = Object.prototype.toString,

  //  ID string matching
  rIdExp  = /^(#([\w\-\_\.]+))$/,

  //  Ready fn cache
  readyStack = [],
  readyBound = false,
  readyFired = false,


  //  Declare constructor
  //  Returns an instance object.
  Popcorn = function( entity, options ) {
    //  Return new Popcorn object
    return new Popcorn.p.init( entity, options || null );
  };

  //  Instance caching
  Popcorn.instances = [];
  Popcorn.instanceIds = {};

  Popcorn.removeInstance = function( instance ) {
    //  If called prior to any instances being created
    //  Return early to avoid splicing on nothing
    if ( !Popcorn.instances.length ) {
      return;
    }

    //  Remove instance from Popcorn.instances
    Popcorn.instances.splice( Popcorn.instanceIds[ instance.id ], 1 );

    //  Delete the instance id key
    delete Popcorn.instanceIds[ instance.id ];

    //  Return current modified instances
    return Popcorn.instances;
  };

  //  Addes a Popcorn instance to the Popcorn instance array
  Popcorn.addInstance = function( instance ) {

    var instanceLen = Popcorn.instances.length,
        instanceId = instance.media.id && instance.media.id;

    //  If the media element has its own `id` use it, otherwise provide one
    //  Ensure that instances have unique ids and unique entries
    //  Uses `in` operator to avoid false positives on 0
    instance.id = !( instanceId in Popcorn.instanceIds ) && instanceId ||
                      "__popcorn" + instanceLen;

    //  Create a reference entry for this instance
    Popcorn.instanceIds[ instance.id ] = instanceLen;

    //  Add this instance to the cache
    Popcorn.instances.push( instance );

    //  Return the current modified instances
    return Popcorn.instances;
  };

  //  Request Popcorn object instance by id
  Popcorn.getInstanceById = function( id ) {
    return Popcorn.instances[ Popcorn.instanceIds[ id ] ];
  };

  //  Remove Popcorn object instance by id
  Popcorn.removeInstanceById = function( id ) {
    return Popcorn.removeInstance( Popcorn.instances[ Popcorn.instanceIds[ id ] ] );
  };

  //  Declare a shortcut (Popcorn.p) to and a definition of
  //  the new prototype for our Popcorn constructor
  Popcorn.p = Popcorn.prototype = {

    init: function( entity, options ) {

      var matches;

      //  Supports Popcorn(function () { /../ })
      //  Originally proposed by Daniel Brooks

      if ( typeof entity === "function" ) {

        //  If document ready has already fired
        if ( document.readyState === "interactive" || document.readyState === "complete" ) {

          entity(document, Popcorn);

          return;
        }
        //  Add `entity` fn to ready stack
        readyStack.push( entity );

        //  This process should happen once per page load
        if ( !readyBound ) {

          //  set readyBound flag
          readyBound = true;

          var DOMContentLoaded  = function () {

            readyFired = true;

            //  Remove global DOM ready listener
            document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );

            //  Execute all ready function in the stack
            for ( var i = 0; i < readyStack.length; i++ ) {

              readyStack[i].call( document, Popcorn );

            }
            //  GC readyStack
            readyStack = null;
          };

          //  Register global DOM ready listener
          document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false);
        }

        return;
      }

      //  Check if entity is a valid string id
      matches = rIdExp.exec( entity );

      //  Get media element by id or object reference
      this.media = matches && matches.length && matches[ 2 ] ?
                    document.getElementById( matches[ 2 ] ) :
                    entity;

      //  Create an audio or video element property reference
      this[ ( this.media.tagName && this.media.tagName.toLowerCase() ) || "video" ] = this.media;

      //  Register new instance
      Popcorn.addInstance( this );

      this.options = options || { };
      this.data = {
        history: [],
        events: {},
        trackEvents: {
          byStart: [{
            start: -1,
            end: -1
          }],
          byEnd:   [{
            start: -1,
            end: -1
          }],
          startIndex: 0,
          endIndex:   0,
          previousUpdateTime: 0
        }
      };

      //  Wrap true ready check
      var isReady = function( that ) {

        if ( that.media.readyState >= 2 ) {
          //  Adding padding to the front and end of the arrays
          //  this is so we do not fall off either end

          var duration = that.media.duration,
              //  Check for no duration info (NaN)
              videoDurationPlus = duration != duration ? Number.MAX_VALUE : duration + 1;

          Popcorn.addTrackEvent( that, {
            start: videoDurationPlus,
            end: videoDurationPlus
          });

          that.media.addEventListener( "timeupdate", function( event ) {

            var currentTime    = this.currentTime,
                previousTime   = that.data.trackEvents.previousUpdateTime,
                tracks         = that.data.trackEvents,
                tracksByEnd    = tracks.byEnd,
                tracksByStart  = tracks.byStart;

            //  Playbar advancing
            if ( previousTime < currentTime ) {

              while ( tracksByEnd[ tracks.endIndex ] && tracksByEnd[ tracks.endIndex ].end <= currentTime ) {
                //  If plugin does not exist on this instance, remove it
                if ( !tracksByEnd[ tracks.endIndex ]._natives || !!that[ tracksByEnd[ tracks.endIndex ]._natives.type ] ) {
                  if ( tracksByEnd[ tracks.endIndex ]._running === true ) {
                    tracksByEnd[ tracks.endIndex ]._running = false;
                    tracksByEnd[ tracks.endIndex ]._natives.end.call( that, event, tracksByEnd[ tracks.endIndex ] );
                  }
                  tracks.endIndex++;
                } else {
                  // remove track event
                  Popcorn.removeTrackEvent( that, tracksByEnd[ tracks.endIndex ]._id );
                  return;
                }
              }

              while ( tracksByStart[ tracks.startIndex ] && tracksByStart[ tracks.startIndex ].start <= currentTime ) {
                //  If plugin does not exist on this instance, remove it
                if ( !tracksByStart[ tracks.startIndex ]._natives || !!that[ tracksByStart[ tracks.startIndex ]._natives.type ] ) {
                  if ( tracksByStart[ tracks.startIndex ].end > currentTime && tracksByStart[ tracks.startIndex ]._running === false ) {
                    tracksByStart[ tracks.startIndex ]._running = true;
                    tracksByStart[ tracks.startIndex ]._natives.start.call( that, event, tracksByStart[ tracks.startIndex ] );
                  }
                  tracks.startIndex++;
                } else {
                  // remove track event
                  Popcorn.removeTrackEvent( that, tracksByStart[ tracks.startIndex ]._id );
                  return;
                }
              }

            // Playbar receding
            } else if ( previousTime > currentTime ) {

              while ( tracksByStart[ tracks.startIndex ] && tracksByStart[ tracks.startIndex ].start > currentTime ) {
                // if plugin does not exist on this instance, remove it
                if ( !tracksByStart[ tracks.startIndex ]._natives || !!that[ tracksByStart[ tracks.startIndex ]._natives.type ] ) {
                  if ( tracksByStart[ tracks.startIndex ]._running === true ) {
                    tracksByStart[ tracks.startIndex ]._running = false;
                    tracksByStart[ tracks.startIndex ]._natives.end.call( that, event, tracksByStart[ tracks.startIndex ] );
                  }
                  tracks.startIndex--;
                } else {
                  // remove track event
                  Popcorn.removeTrackEvent( that, tracksByStart[ tracks.startIndex ]._id );
                  return;
                }
              }

              while ( tracksByEnd[ tracks.endIndex ] && tracksByEnd[ tracks.endIndex ].end > currentTime ) {
                // if plugin does not exist on this instance, remove it
                if ( !tracksByEnd[ tracks.endIndex ]._natives || !!that[ tracksByEnd[ tracks.endIndex ]._natives.type ] ) {
                  if ( tracksByEnd[ tracks.endIndex ].start <= currentTime && tracksByEnd[ tracks.endIndex ]._running === false ) {
                    tracksByEnd[ tracks.endIndex ]._running = true;
                    tracksByEnd[ tracks.endIndex ]._natives.start.call( that, event, tracksByEnd[tracks.endIndex] );
                  }
                  tracks.endIndex--;
                } else {
                  // remove track event
                  Popcorn.removeTrackEvent( that, tracksByEnd[ tracks.endIndex ]._id );
                  return;
                }
              }
            }

            tracks.previousUpdateTime = currentTime;

          }, false);
        } else {
          global.setTimeout( function() {
            isReady( that );
          }, 1);
        }
      };

      isReady( this );

      return this;
    }
  };

  //  Extend constructor prototype to instance prototype
  //  Allows chaining methods to instances
  Popcorn.p.init.prototype = Popcorn.p;

  Popcorn.forEach = function( obj, fn, context ) {

    if ( !obj || !fn ) {
      return {};
    }

    context = context || this;
    // Use native whenever possible
    if ( forEach && obj.forEach === forEach ) {
      return obj.forEach(fn, context);
    }

    for ( var key in obj ) {
      if ( hasOwn.call(obj, key) ) {
        fn.call(context, obj[key], key, obj);
      }
    }

    return obj;
  };

  Popcorn.extend = function( obj ) {
    var dest = obj, src = slice.call(arguments, 1);

    Popcorn.forEach( src, function( copy ) {
      for ( var prop in copy ) {
        dest[prop] = copy[prop];
      }
    });
    return dest;
  };


  // A Few reusable utils, memoized onto Popcorn
  Popcorn.extend( Popcorn, {
    error: function( msg ) {
      throw new Error( msg );
    },
    guid: function( prefix ) {
      Popcorn.guid.counter++;
      return  ( prefix ? prefix : "" ) + ( +new Date() + Popcorn.guid.counter );
    },
    sizeOf: function ( obj ) {
      var size = 0;

      for ( var prop in obj  ) {
        size++;
      }

      return size;
    },
    isArray: Array.isArray || function( array ) {
      return toString.call( array ) === "[object Array]";
    }, 

    nop: function () {},

    position: function( elem ) {

      var clientRect = elem.getBoundingClientRect(),
          bounds = {}, 
          doc = elem.ownerDocument,
          docElem = document.documentElement,
          body = document.body,
          clientTop, clientLeft, scrollTop, scrollLeft, top, left;

      //  Determine correct clientTop/Left
      clientTop  = docElem.clientTop  || body.clientTop  || 0;
      clientLeft = docElem.clientLeft || body.clientLeft || 0;

      //  Determine correct scrollTop/Left
      scrollTop  = ( global.pageYOffset && docElem.scrollTop || body.scrollTop );
      scrollLeft = ( global.pageXOffset && docElem.scrollLeft || body.scrollLeft );

      //  Temp top/left
      top  = Math.ceil( clientRect.top  + scrollTop - clientTop );
      left = Math.ceil( clientRect.left + scrollLeft - clientLeft );

      for ( var p in clientRect ) {
        bounds[ p ] = Math.round( clientRect[ p ] );
      }

      return Popcorn.extend({}, bounds, { top: top, left: left });     
    }
  });

  //  Memoized GUID Counter
  Popcorn.guid.counter  = 1;

  //  Factory to implement getters, setters and controllers
  //  as Popcorn instance methods. The IIFE will create and return
  //  an object with defined methods
  Popcorn.extend(Popcorn.p, (function () {

      var methods = "load play pause currentTime playbackRate mute volume duration",
          ret = {};


      //  Build methods, store in object that is returned and passed to extend
      Popcorn.forEach( methods.split(/\s+/g), function( name ) {

        ret[ name ] = function( arg ) {

          if ( typeof this.media[name] === "function" ) {
            this.media[ name ]();

            return this;
          }


          if ( arg !== false && arg !== null && typeof arg !== "undefined" ) {

            this.media[ name ] = arg;

            return this;
          }

          return this.media[ name ];
        };
      });

      return ret;

    })()
  );

  Popcorn.extend(Popcorn.p, {

    //  Rounded currentTime
    roundTime: function () {
      return -~this.media.currentTime;
    },

    //  Attach an event to a single point in time
    exec: function ( time, fn ) {

      //  Creating a one second track event with an empty end
      Popcorn.addTrackEvent( this, {
        start: time,
        end: time + 1,
        _running: false,
        _natives: {
          start: fn || Popcorn.nop,
          end: Popcorn.nop,
          type: "exec"
        }
      });

      return this;
    },
    position: function() {
      return Popcorn.position( this.media );
    }
  });

  Popcorn.Events  = {
    UIEvents: "blur focus focusin focusout load resize scroll unload  ",
    MouseEvents: "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave click dblclick",
    Events: "loadstart progress suspend emptied stalled play pause " +
           "loadedmetadata loadeddata waiting playing canplay canplaythrough " +
           "seeking seeked timeupdate ended ratechange durationchange volumechange"
  };

  Popcorn.Events.Natives = Popcorn.Events.UIEvents + " " +
                            Popcorn.Events.MouseEvents + " " +
                              Popcorn.Events.Events;

  Popcorn.events  = {


    isNative: function( type ) {

      var checks = Popcorn.Events.Natives.split( /\s+/g );

      for ( var i = 0; i < checks.length; i++ ) {
        if ( checks[i] === type ) {
          return true;
        }
      }

      return false;
    },
    getInterface: function( type ) {

      if ( !Popcorn.events.isNative( type ) ) {
        return false;
      }

      var natives = Popcorn.Events,
          proto;

      for ( var p in natives ) {
        if ( p !== "Natives" && natives[ p ].indexOf( type ) > -1 ) {
          proto = p;
        }
      }

      return proto;
    },
    //  Compile all native events to single array
    all: Popcorn.Events.Natives.split(/\s+/g),
    //  Defines all Event handling static functions
    fn: {
      trigger: function ( type, data ) {

        //  setup checks for custom event system
        if ( this.data.events[ type ] && Popcorn.sizeOf( this.data.events[ type ] ) ) {

          var eventInterface  = Popcorn.events.getInterface( type );

          if ( eventInterface ) {

            var evt = document.createEvent( eventInterface );
                evt.initEvent(type, true, true, global, 1);

            this.media.dispatchEvent(evt);

            return this;
          }

          //  Custom events
          Popcorn.forEach(this.data.events[ type ], function ( obj, key ) {

            obj.call( this, data );

          }, this);

        }

        return this;
      },
      listen: function ( type, fn ) {

        var self = this, hasEvents = true;

        if ( !this.data.events[type] ) {
          this.data.events[type] = {};
          hasEvents = false;
        }

        //  Register
        this.data.events[ type ][ fn.name || ( fn.toString() + Popcorn.guid() ) ] = fn;

        // only attach one event of any type
        if ( !hasEvents && Popcorn.events.all.indexOf( type ) > -1 ) {

          this.media.addEventListener( type, function( event ) {

            Popcorn.forEach( self.data.events[type], function ( obj, key ) {
              if ( typeof obj === "function" ) {
                obj.call(self, event);
              }

            });

            //fn.call( self, event );

          }, false);
        }
        return this;
      },
      unlisten: function( type, fn ) {

        if ( this.data.events[type] && this.data.events[type][fn] ) {

          delete this.data.events[type][ fn ];

          return this;
        }

        this.data.events[type] = null;

        return this;
      }
    }
  };

  //  Extend Popcorn.events.fns (listen, unlisten, trigger) to all Popcorn instances
  Popcorn.forEach( ["trigger", "listen", "unlisten"], function ( key ) {
    Popcorn.p[ key ] = Popcorn.events.fn[ key ];
  });
  //  Protected API methods
  Popcorn.protect = {
    natives: "load play pause currentTime playbackRate mute volume duration removePlugin roundTime trigger listen unlisten".toLowerCase().split(/\s+/)
  };

  //  Internal Only
  Popcorn.addTrackEvent = function( obj, track ) {

    if ( track._natives ) {
      //  Supports user defined track event id
      track._id = !track.id ? Popcorn.guid( track._natives.type ) : track.id;

      //  Push track event ids into the history
      obj.data.history.push( track._id );

      track._natives.start = track._natives.start || Popcorn.nop;
      track._natives.end = track._natives.end || Popcorn.nop;
    }

    track.start = Popcorn.util.toSeconds( track.start, obj.options.framerate );
    track.end = Popcorn.util.toSeconds( track.end, obj.options.framerate );

    //  Store this definition in an array sorted by times
    obj.data.trackEvents.byStart.push( track );
    obj.data.trackEvents.byEnd.push( track );
    obj.data.trackEvents.byStart.sort( function( a, b ){
      return ( a.start - b.start );
    });
    obj.data.trackEvents.byEnd.sort( function( a, b ){
      return ( a.end - b.end );
    });

  };

  //  removePlugin( type ) removes all tracks of that from all instances of popcorn
  //  removePlugin( obj, type ) removes all tracks of type from obj, where obj is a single instance of popcorn
  Popcorn.removePlugin = function( obj, name ) {

    //  Check if we are removing plugin from an instance or from all of Popcorn
    if ( !name ) {

      //  Fix the order
      name = obj;
      obj = Popcorn.p;

      var registryLen = Popcorn.registry.length,
          registryIdx;

      // remove plugin reference from registry
      for ( registryIdx = 0; registryIdx < registryLen; registryIdx++ ) {
        if ( Popcorn.registry[ registryIdx ].name === name ) {
          Popcorn.registry.splice( registryIdx, 1 );
          delete Popcorn.registryByName[ name ];

          // delete the plugin
          delete obj[ name ];

          // plugin found and removed, stop checking, we are done
          return;
        }
      }

    }

    var byStart = obj.data.trackEvents.byStart,
        byEnd = obj.data.trackEvents.byEnd,
        idx, sl;

    // remove all trackEvents
    for ( idx = 0, sl = byStart.length; idx < sl; idx++ ) {

      if ( ( byStart[ idx ] && byStart[ idx ]._natives && byStart[ idx ]._natives.type === name ) &&
                ( byEnd[ idx ] && byEnd[ idx ]._natives && byEnd[ idx ]._natives.type === name ) ) {

        byStart.splice( idx, 1 );
        byEnd.splice( idx, 1 );

        // update for loop if something removed, but keep checking
        idx--; sl--;
        if ( obj.data.trackEvents.startIndex <= idx ) {
          obj.data.trackEvents.startIndex--;
          obj.data.trackEvents.endIndex--;
        }
      }
    }
  };

  Popcorn.removeTrackEvent  = function( obj, trackId ) {

    var historyLen = obj.data.history.length,
        indexWasAt = 0,
        byStart = [],
        byEnd = [],
        history = [];


    Popcorn.forEach( obj.data.trackEvents.byStart, function( o, i, context ) {
      // Preserve the original start/end trackEvents
      if ( !o._id ) {
        byStart.push( obj.data.trackEvents.byStart[i] );
        byEnd.push( obj.data.trackEvents.byEnd[i] );
      }

      // Filter for user track events (vs system track events)
      if ( o._id ) {

        // Filter for the trackevent to remove
        if ( o._id !== trackId ) {
          byStart.push( obj.data.trackEvents.byStart[i] );
          byEnd.push( obj.data.trackEvents.byEnd[i] );
        }

        //  Capture the position of the track being removed.
        if ( o._id === trackId ) {
          indexWasAt = i;
          o._natives._teardown && o._natives._teardown.call( obj, o );
        }
      }
    });


    //  Update
    if ( indexWasAt <= obj.data.trackEvents.startIndex ) {
      obj.data.trackEvents.startIndex--;
    }

    if ( indexWasAt <= obj.data.trackEvents.endIndex ) {
      obj.data.trackEvents.endIndex--;
    }


    obj.data.trackEvents.byStart = byStart;
    obj.data.trackEvents.byEnd = byEnd;


    for ( var i = 0; i < historyLen; i++ ) {
      if ( obj.data.history[i] !== trackId ) {
        history.push( obj.data.history[i] );
      }
    }

    obj.data.history = history;

  };

  Popcorn.getTrackEvents = function( obj ) {

    var trackevents = [];

    Popcorn.forEach( obj.data.trackEvents.byStart, function( o, i, context ) {
      if ( o._id ) {
        trackevents.push(o);
      }
    });

    return trackevents;
  };


  Popcorn.getLastTrackEventId = function( obj ) {
    return obj.data.history[ obj.data.history.length - 1 ];
  };

  //  Map and Extend TrackEvent functions to all Popcorn instances
  Popcorn.extend( Popcorn.p, {

    getTrackEvents: function() {
      return Popcorn.getTrackEvents.call( null, this );
    },

    getLastTrackEventId: function() {
      return Popcorn.getLastTrackEventId.call( null, this );
    },

    removeTrackEvent: function( id ) {
      Popcorn.removeTrackEvent.call( null, this, id );
      return this;
    },

    removePlugin: function( name ) {
      Popcorn.removePlugin.call( null, this, name );
      return this;
    }

  });

  //  Plugin manifests
  Popcorn.manifest = {};
  //  Plugins are registered
  Popcorn.registry = [];
  Popcorn.registryByName = {};
  //  An interface for extending Popcorn
  //  with plugin functionality
  Popcorn.plugin = function( name, definition, manifest ) {

    if ( Popcorn.protect.natives.indexOf( name.toLowerCase() ) >= 0 ) {
      Popcorn.error("'" + name + "' is a protected function name");
      return;
    }

    //  Provides some sugar, but ultimately extends
    //  the definition into Popcorn.p
    var reserved = [ "start", "end" ],
        plugin = {},
        setup,
        isfn = typeof definition === "function";

    //  If `manifest` arg is undefined, check for manifest within the `definition` object
    //  If no `definition.manifest`, an empty object is a sufficient fallback
    if ( !manifest ) {
      manifest = definition.manifest || {};
    }

    var pluginFn = function( setup, options ) {

      if ( !options ) {
        return this;
      }

      //  Storing the plugin natives
      options._natives = setup;
      options._natives.type = name;
      options._running = false;

      //  Ensure a manifest object, an empty object is a sufficient fallback
      options._natives.manifest = manifest;

      //  Checks for expected properties
      if ( !( "start" in options ) ) {
        options.start = 0;
      }

      if ( !( "end" in options ) ) {
        options.end = this.duration();
      }

      //  If a _setup was declared, then call it before
      //  the events commence
      if ( "_setup" in setup && typeof setup._setup === "function" ) {

        // Resolves 239, 241, 242
        if ( !options.target ) {

          //  Sometimes the manifest may be missing entirely
          //  or it has an options object that doesn't have a `target` property

          var manifestopts = "options" in manifest && manifest.options;

          options.target = manifestopts && "target" in manifestopts && manifestopts.target;
        }

        setup._setup.call( this, options );
      }

      Popcorn.addTrackEvent( this, options );

      //  Future support for plugin event definitions
      //  for all of the native events
      Popcorn.forEach( setup, function ( callback, type ) {

        if ( type !== "type" ) {

          if ( reserved.indexOf( type ) === -1 ) {

            this.listen( type, callback );
          }
        }

      }, this);

      return this;
    };

    //  Augment the manifest object
    if ( manifest || ( "manifest" in definition ) ) {
      Popcorn.manifest[ name ] = manifest || definition.manifest;
    }

    //  Assign new named definition
    plugin[ name ] = function( options ) {
      return pluginFn.call( this, isfn ? definition.call( this, options ) : definition,
                                  options );
    };

    //  Extend Popcorn.p with new named definition
    Popcorn.extend( Popcorn.p, plugin );

    //  Push into the registry
    var entry = {
      fn: plugin[ name ],
      definition: definition,
      base: definition,
      parents: [],
      name: name
    };
    Popcorn.registry.push(
       Popcorn.extend( plugin, entry, {
        type: name
      })
    );
    Popcorn.registryByName[ name ] = entry;

    return plugin;
  };

  //  Popcorn Plugin Inheritance Helper Methods
  //  Internal use only
  Popcorn.plugin.getDefinition = function( name ) {

    var registry = Popcorn.registryByName;
    
    if ( registry[ name ] ) {
      return registry[ name ];
    }

    Popcorn.error( "Cannot inherit from "+ name +"; Object does not exist" );
  };

  //  Internal use only
  Popcorn.plugin.delegate = function( instance, name, plugins ) {

    return function() {
      var args = arguments;
      plugins.forEach( function( plugin ) {
        // The new plugin simply calls the delegated methods on
        // all of its parents in the order they were specified.
        plugin[ name ] && plugin[ name ].apply( instance, args );
      });
    };
  };

  //  Plugin inheritance
  Popcorn.plugin.inherit = function( name, parents, definition, manifest ) {


    // Get the names of all of the ancestor classes, in the order that
    // we will be calling them. The override is for the class we're
    // currently defining, since it's not in the registry yet.
    var ancestors = [], 
        pluginFn, entry;

    function getAncestors( name, override ) {
      var parents = override || Popcorn.plugin.getDefinition( name ).parents;
      for ( var i in parents ) {
        if ( hasOwn.call( parents, i ) ) {
          var p = parents[ i ];
          getAncestors( p );
          if ( ancestors.indexOf( p ) === -1 ) {
            ancestors.push( p );
          }
        }
      }
    }

    getAncestors( name, Popcorn.isArray( parents ) ? parents : [ parents ] );
    ancestors.push( name );

    // Now create the requested plugin under the reqested name.
    pluginFn = Popcorn.plugin( name, function( options ) {

      var self = this, 
          plugins;

      function instantiate( definition ) {
        return definition.call && definition.call( self, options ) || definition;
      }

      // When the newly-defined plugin is instantiated, it must
      // explicitly instantiate all of its ancestors.
      plugins = ancestors.map( function( name ) {
        return instantiate( Popcorn.plugin.getDefinition( name ).base );
      });

      return {
        _setup: Popcorn.plugin.delegate( self, "_setup", plugins ),
        start: Popcorn.plugin.delegate( self, "start", plugins ),
        end: Popcorn.plugin.delegate( self, "end", plugins )
      };
      
    }, manifest || definition.manifest );

    entry = Popcorn.plugin.getDefinition( name );
    entry.base = definition;
    entry.parents = parents;

    return pluginFn;
  };

  // Augment Popcorn; 
  Popcorn.inherit = Popcorn.plugin.inherit;

  // stores parsers keyed on filetype
  Popcorn.parsers = {};

  // An interface for extending Popcorn
  // with parser functionality
  Popcorn.parser = function( name, type, definition ) {

    if ( Popcorn.protect.natives.indexOf( name.toLowerCase() ) >= 0 ) {
      Popcorn.error("'" + name + "' is a protected function name");
      return;
    }

    // fixes parameters for overloaded function call
    if ( typeof type === "function" && !definition ) {
      definition = type;
      type = "";
    }

    if ( typeof definition !== "function" || typeof type !== "string" ) {
      return;
    }

    // Provides some sugar, but ultimately extends
    // the definition into Popcorn.p

    var natives = Popcorn.events.all,
        parseFn,
        parser = {};

    parseFn = function ( filename, callback ) {

      if ( !filename ) {
        return this;
      }

      var that = this;

      Popcorn.xhr({
        url: filename,
        dataType: type,
        success: function( data ) {

          var tracksObject = definition( data ),
              tracksData,
              tracksDataLen,
              tracksDef,
              idx = 0;

          tracksData = tracksObject.data || [];
          tracksDataLen = tracksData.length;
          tracksDef = null;

          //  If no tracks to process, return immediately
          if ( !tracksDataLen ) {
            return;
          }

          //  Create tracks out of parsed object
          for ( ; idx < tracksDataLen; idx++ ) {

            tracksDef = tracksData[ idx ];

            for ( var key in tracksDef ) {

              if ( hasOwn.call( tracksDef, key ) && !!that[ key ] ) {

                that[ key ]( tracksDef[ key ] );
              }
            }
          }
          if ( callback ) {
            callback();
          }
        }
      });

      return this;
    };

    // Assign new named definition
    parser[ name ] = parseFn;

    // Extend Popcorn.p with new named definition
    Popcorn.extend( Popcorn.p, parser );

    // keys the function name by filetype extension
    //Popcorn.parsers[ name ] = true;

    return parser;
  };


  //  Cache references to reused RegExps
  var rparams = /\?/,
  //  XHR Setup object
  setup = {
    url: '',
    data: '',
    dataType: '',
    success: Popcorn.nop,
    type: 'GET',
    async: true,
    xhr: function()  {
      return new global.XMLHttpRequest();
    }
  };

  Popcorn.xhr = function ( options ) {

    options.dataType = options.dataType && options.dataType.toLowerCase() || null;
    
    if ( options.dataType &&
            ( options.dataType === "jsonp" ||
                options.dataType === "script" ) ) {

      Popcorn.xhr.getJSONP(
        options.url,
        options.success,
        options.dataType === "script"
      );
      return;
    }

    var settings = Popcorn.extend( {}, setup, options );

    //  Create new XMLHttpRequest object
    settings.ajax  = settings.xhr();

    if ( settings.ajax ) {

      if ( settings.type === "GET" && settings.data ) {

        //  append query string
        settings.url += ( rparams.test( settings.url ) ? "&" : "?" ) + settings.data;

        //  Garbage collect and reset settings.data
        settings.data = null;
      }


      settings.ajax.open( settings.type, settings.url, settings.async );
      settings.ajax.send( settings.data || null );

      return Popcorn.xhr.httpData( settings );
    }
  };


  Popcorn.xhr.httpData = function ( settings ) {

    var data, json = null;

    settings.ajax.onreadystatechange = function() {

      if ( settings.ajax.readyState === 4 ) {

        try {
          json = JSON.parse(settings.ajax.responseText);
        } catch(e) {
          //suppress
        }

        data = {
          xml: settings.ajax.responseXML,
          text: settings.ajax.responseText,
          json: json
        };

        //  If a dataType was specified, return that type of data
        if ( settings.dataType ) {
          data = data[ settings.dataType ];
        }


        settings.success.call( settings.ajax, data );

      }
    };
    return data;
  };

  Popcorn.xhr.getJSONP = function ( url, success, isScript ) {

    //  If this is a script request, ensure that we do not call something that has already been loaded
    if ( isScript ) {

      var scripts = document.querySelectorAll('script[src="' + url + '"]');

      //  If there are scripts with this url loaded, early return
      if ( scripts.length ) {

        //  Execute success callback and pass "exists" flag
        success && success( true );

        return;
      }
    }

    var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement,
      script = document.createElement("script"),
      paramStr = url.split("?")[1],
      isFired = false,
      params = [],
      callback, parts, callparam;

    if ( paramStr && !isScript ) {
      params = paramStr.split("&");
    }

    if ( params.length ) {
      parts = params[ params.length - 1 ].split("=");
    }

    callback = params.length ? ( parts[1] ? parts[1] : parts[0]  ) : "jsonp";

    if ( !paramStr && !isScript ) {
      url += "?callback=" + callback;
    }

    if ( callback && !isScript ) {

      //  If a callback name already exists
      if ( !!window[ callback ] ) {

        //  Create a new unique callback name
        callback = Popcorn.guid( callback );
      }

      //  Define the JSONP success callback globally
      window[ callback ] = function ( data ) {

        success && success( data );
        isFired = true;

      };

      //  Replace callback param and callback name
      url = url.replace( parts.join("="), parts[0] + "=" + callback );

    }

    script.onload = script.onreadystatechange = function() {

      if ( !script.readyState || /loaded|complete/.test( script.readyState ) ) {

        //  Handling remote script loading callbacks
        if ( isScript ) {

          //  getScript
          success && success();
        }

        //  Executing for JSONP requests
        if ( isFired ) {

          //  Garbage collect the callback
          delete window[ callback ];

          //  Garbage collect the script resource
          head.removeChild( script );
        }
      }
    };

    script.src = url;

    head.insertBefore( script, head.firstChild );

    return;
  };

  Popcorn.getJSONP = Popcorn.xhr.getJSONP;

  Popcorn.getScript = Popcorn.xhr.getScript = function( url, success ) {

    return Popcorn.xhr.getJSONP( url, success, true );
  };

  Popcorn.util = {
    // Simple function to parse a timestamp into seconds
    // Acceptable formats are:
    // HH:MM:SS.MMM
    // HH:MM:SS;FF
    // Hours and minutes are optional. They default to 0
    toSeconds: function( timeStr, framerate ) {
        //Hours and minutes are optional
        //Seconds must be specified
        //Seconds can be followed by milliseconds OR by the frame information
        var validTimeFormat = /^([0-9]+:){0,2}[0-9]+([.;][0-9]+)?$/,
            errorMessage = "Invalid time format";

        if ( typeof timeStr === "number" ) {
          return timeStr;
        } else if ( typeof timeStr === "string" ) {
          if ( ! validTimeFormat.test( timeStr ) ) {
            Popcorn.error( errorMessage );
          }
        } else {
          Popcorn.error( errorMessage );
        }

        var t = timeStr.split( ":" ),
            lastIndex = t.length - 1,
            lastElement = t[ lastIndex ];

        //Fix last element:
        if ( lastElement.indexOf( ";" ) > -1 ) {
          var frameInfo = lastElement.split( ";" ),
              frameTime = 0;

          if ( framerate && ( typeof framerate === "number" ) ) {
              frameTime = parseFloat( frameInfo[ 1 ], 10 ) / framerate;
          }

          t[ lastIndex ] =
            parseInt( frameInfo[ 0 ], 10 ) + frameTime;
        }

        if ( t.length === 1 ) {
          return parseFloat( t[ 0 ], 10 );
        } else if ( t.length === 2 ) {
          return ( parseInt( t[ 0 ], 10 ) * 60 ) + parseFloat( t[ 1 ], 10 );
        } else if ( t.length === 3 ) {
          return ( parseInt( t[ 0 ], 10 ) * 3600 ) +
                 ( parseInt( t[ 1 ], 10 ) * 60 ) +
                 parseFloat( t[ 2 ], 10 );
        }
    }
  };

  //  Exposes Popcorn to global context
  global.Popcorn = Popcorn;

  document.addEventListener( "DOMContentLoaded", function() {

    //  Supports non-specific elements
    var dataAttr = "data-timeline-sources",
        medias = document.querySelectorAll( "[" + dataAttr + "]" );

    Popcorn.forEach( medias, function( idx, key ) {

      var media = medias[ key ],
          hasDataSources = false,
          dataSources, data, popcornMedia;

      //  Ensure that the DOM has an id
      if ( !media.id ) {

        media.id = Popcorn.guid( "__popcorn" );

      }

      //  Ensure we're looking at a dom node
      if ( media.nodeType && media.nodeType === 1 ) {

        popcornMedia = Popcorn( "#" + media.id );

        dataSources = ( media.getAttribute( dataAttr ) || "" ).split(",");

        if ( dataSources[ 0 ] ) {

          Popcorn.forEach( dataSources, function( source ) {

            // split the parser and data as parser:file
            data = source.split( ":" );

            // if no parser is defined for the file, assume "parse" + file extension
            if ( data.length === 1 ) {

              data = source.split( "." );
              data[ 0 ] = "parse" + data[ data.length - 1 ].toUpperCase();
              data[ 1 ] = source;

            }

            //  If the media has data sources and the correct parser is registered, continue to load
            if ( dataSources[ 0 ] && popcornMedia[ data[ 0 ] ] ) {

              //  Set up the media and load in the datasources
              popcornMedia[ data[ 0 ] ]( data[ 1 ] );

            }
          });

        }

        //  Only play the media if it was specified to do so
        if ( !!popcornMedia.autoplay ) {
          popcornMedia.play();
        }

      }
    });
  }, false );

})(window, window.document);


</script>
		<script type="text/javascript">
(function( global, doc ) {
  Popcorn.baseplayer = function() {
    return new Popcorn.baseplayer.init();
  };

  Popcorn.baseplayer.init = function() {
    this.readyState = 0;
    this.currentTime = 0;
    this.duration = 0;
    this.paused = 1;
    this.ended = 0;
    this.volume = 1;
    this.muted = 0;
    this.playbackRate = 1;

    // These are considered to be "on" by being defined. Initialize to undefined
    this.autoplay;
    this.loop;
    
    // List of events
    this._events = {};
    
    // The underlying player resource. May be <canvas>, <iframe>, <object>, array, etc
    this._resource;
    // The container div of the resource
    this._container;
    
    this.offsetWidth = this.width = 0;
    this.offsetHeight = this.height = 0;
    this.offsetLeft = 0;
    this.offsetTop = 0;
    this.offsetParent;
  };

  Popcorn.baseplayer.init.prototype = {
    load: function() {},
    
    play: function() {
      this.paused = 0;
      this.timeupdate();
    },
    
    pause: function() {
      this.paused = 1;
    },
    
    timeupdate: function() {
      // The player was paused since the last time update
      if ( this.paused ) {
        return;
      }

      // So we can refer to the instance when setTimeout is run
      var self = this;
      this.currentTime += 0.015;
      
      this.dispatchEvent( "timeupdate" );
      setTimeout( function() {
        self.timeupdate.call( self );
      }, 15 );
    },
    
    // By default, assumes this.resource is a DOM Element
    // Changing the type of this.resource requires this method to be overridden
    getBoundingClientRect: function() {
      var b,
          self = this;
          
      if ( this._resource ) {
        b = this._resource.getBoundingClientRect();
        
        return {
          bottom: Math.ceil( b.bottom ),
          left: Math.ceil( b.left ),
          right: Math.ceil( b.right ),
          top: Math.ceil( b.top ),
          
          //  These not guaranteed to be in there
          width: b.width || ( b.right - b.left ),
          height: b.height || ( b.bottom - b.top )
        };
      } else {
        b = this._container.getBoundingClientRect();
        
        // Update bottom, right for expected values once the container loads
        return {
          left: b.left,
          top: b.top,
          width: self.offsetWidth,
          height: self.offsetHeight,
          bottom: b.top + this.width,
          right: b.top + this.height
        };
      }
    },
    
    // Add an event listener to the object
    addEventListener: function( evtName, fn ) {
      if ( !this._events[evtName] ) {
        this._events[evtName] = [];
      }
      
      this._events[evtName].push( fn );
      return fn;
    },
    
    // Can take event object or simple string
    dispatchEvent: function( oEvent ) {
      var evt,
          self = this,
          eventInterface,
          eventName = oEvent.type;
          
      // A string was passed, create event object
      if ( !eventName ) {
        eventName = oEvent;
        eventInterface  = Popcorn.events.getInterface( eventName );
        
        if ( eventInterface ) {
          evt = document.createEvent( eventInterface );
          evt.initEvent( eventName, true, true, window, 1 );
        }
      }
      
      Popcorn.forEach( this._events[eventName], function( val ) {
        val.call( self, evt, self );
      });
    },
    
    // Extracts values from container onto this object
    extractContainerValues: function( id ) {
      this._container = document.getElementById( id );
      
      if ( !this._container ) {
        return;
      }
      
      var bounds = this._container.getBoundingClientRect();
      
      this.offsetWidth = this.width = container.getAttribute( "width" ) || getStyle( "width" ) || 0;
      this.offsetHeight = this.height = container.getAttribute( "height" ) || getStyle( "height" ) || 0;
      this.offsetLeft = bounds.left;
      this.offsetTop = bound.top;
      this.offsetParent = this._container.offsetParent;
      
      return this._container;
    },
    
    // By default, assumes this.resource is a DOM Element
    // Changing the type of this.resource requires this method to be overridden
    // Returns the computed value for CSS style 'prop' as computed by the browser
    getStyle: function( prop ) {
      var elem = this._resource;
      
      if ( elem.currentStyle ) {
        // IE syntax
        return elem.currentStyle[prop];
      } else if ( global.getComputedStyle ) {
        // Firefox, Chrome et. al
        return doc.defaultView.getComputedStyle( elem, null ).getPropertyValue( prop );
      } else {
        // Fallback, just in case
        return elem.style[prop];
      }
    }
  };
})( window, document );

</script>
		<script type="text/javascript">
// PLUGIN: Code

(function (Popcorn) {

  /**
   * Code Popcorn Plug-in
   *
   * Adds the ability to run arbitrary code (JavaScript functions) according to video timing.
   *
   * @param {Object} options
   *
   * Required parameters: start, end, template, data, and target.
   * Optional parameter: static.
   *
   *   start: the time in seconds when the mustache template should be rendered
   *          in the target div.
   *
   *   end: the time in seconds when the rendered mustache template should be
   *        removed from the target div.
   *
   *   onStart: the function to be run when the start time is reached.
   *
   *   onFrame: [optional] a function to be run on each paint call
   *            (e.g., called ~60 times per second) between the start and end times.
   *
   *   onEnd: [optional] a function to be run when the end time is reached.
   *
   * Example:
     var p = Popcorn('#video')

        // onStart function only
        .code({
          start: 1,
          end: 4,
          onStart: function( options ) {
            // called on start
          }
        })

        // onStart + onEnd only
        .code({
          start: 6,
          end: 8,
          onStart: function( options ) {
            // called on start
          },
          onEnd: function ( options ) {
            // called on end
          }
        })

        // onStart, onEnd, onFrame
        .code({
          start: 10,
          end: 14,
          onStart: function( options ) {
            // called on start
          },
          onFrame: function ( options ) {
            // called on every paint frame between start and end.
            // uses mozRequestAnimationFrame, webkitRequestAnimationFrame,
            // or setTimeout with 16ms window.
          },
          onEnd: function ( options ) {
            // called on end
          }
        });
  *
  */

  Popcorn.plugin( 'code' , function(options) {
    var running = false;
  
    // Setup a proper frame interval function (60fps), favouring paint events.
    var step = ( function() {
    
      var buildFrameRunner = function( runner ) {
        return function( f, options ) {
    
          var _f = function() {
            f();
            if ( running ) {
              runner( _f );
            }
          };
    
          _f();
        };
      };
    
      // Figure out which level of browser support we have for this
      if ( window.webkitRequestAnimationFrame ) {
        return buildFrameRunner( window.webkitRequestAnimationFrame );
      } else if ( window.mozRequestAnimationFrame ) {
        return buildFrameRunner( window.mozRequestAnimationFrame );
      } else {
        return buildFrameRunner( function( f ) {
          window.setTimeout( f, 16 );
        } );
      }
    
    } )();

    if ( !options.onStart || typeof options.onStart !== 'function' ) {
      throw 'Popcorn Code Plugin Error: onStart must be a function.';
    }

    if ( options.onEnd && typeof options.onEnd !== 'function' ) {
      throw 'Popcorn Code Plugin Error: onEnd  must be a function.';
    }

    if ( options.onFrame && typeof options.onFrame !== 'function' ) {
      throw 'Popcorn Code Plugin Error: onFrame  must be a function.';
    }

    return {
      start: function( event, options ) {
        options.onStart( options );

        if ( options.onFrame ) {
          running = true;
          step( options.onFrame, options );
        }
      },

      end: function( event, options ) {
        if ( options.onFrame ) {
          running = false;
        }

        if ( options.onEnd ) {
          options.onEnd( options );
        }
      }
    };
  },
  {
    about: {
      name: 'Popcorn Code Plugin',
      version: '0.1',
      author: 'David Humphrey (@humphd)',
      website: 'http://vocamus.net/dave'
    },
    options: {
      start: {elem:'input', type:'text', label:'In'},
      end: {elem:'input', type:'text', label:'Out'},
      // TODO: how to deal with functions, eval strings?
      onStart: {elem:'input', type:'text', label:'onStart'},
      onFrame: {elem:'input', type:'text', label:'onFrame'},
      onEnd: {elem:'input', type:'text', label:'onEnd'}
    }
  });
})( Popcorn );

</script>
    <script type="text/javascript">
function AudioEngine ( updateFunction ) {

  var modPlayer;
  var playing = false;
  var channels = 2;	//stereo
  var sampleRate = 44100;
  var bufferSize = 2048 * channels; 
  var prebufferSize = 12 * channels * 1024; // defines the latency
  var outputAudio = new Audio();
  var currentWritePosition = 0;
  var lastSampleOffset = 0;

  this.audioObject = outputAudio;

  function play() {
    playing = true;
  }; //play

  function stop() {
    playing = false;
  }; //stop

  function writeAudio() {
    if (!playing) { return; }
    var currentSampleOffset = outputAudio.mozCurrentSampleOffset();
    var playHasStopped = currentSampleOffset == lastSampleOffset; // if audio stopped playing, just send data to trigger it to play again.
    while (currentSampleOffset + prebufferSize >= currentWritePosition || playHasStopped ) {
      // generate audio
      var audioData = modPlayer.getSamples(bufferSize);

      // write audio	
      var written = outputAudio.mozWriteAudio(audioData);
      currentWritePosition += written;	//portionSize;
      currentSampleOffset = outputAudio.mozCurrentSampleOffset();
      playHasStopped = 0;
      updateFunction(audioData);
      if (written < audioData.length) { // firefox buffer is full, stop writing
        return;
      }
    }
    lastSampleOffset = outputAudio.mozCurrentSampleOffset();

  }; //writeAudio

  function loadRemote(path) {
    var fetch = new XMLHttpRequest();
    fetch.open('GET', path);
    fetch.overrideMimeType("text/plain; charset=x-user-defined");
    fetch.onreadystatechange = function() {
      if(this.readyState == 4) {
        /* munge response into a binary string */
        var t = this.responseText || "" ;
        var ff = [];
        var mx = t.length;
        var scc= String.fromCharCode;
        for (var z = 0; z < mx; z++) {
          ff[z] = scc(t.charCodeAt(z) & 255);
        }
        var binString = ff.join("");
      
        var modFile = new ModFile(binString);
        modPlayer = new ModPlayer(modFile, 44100);
        play();
      }
    }
    fetch.send();
  }; //loadRemote

  this.playMod = function (modFileName) {
    if (outputAudio.mozSetup) {
      outputAudio.mozSetup(2, sampleRate);
      writeAudio();
      var writeInterval = Math.floor(1000 * bufferSize / sampleRate);
      setInterval(writeAudio, writeInterval);
    } //if
    loadRemote(modFileName);
  };

}; //ModPlayer

</script>
    <script type="text/javascript">
/*
 *  bitFont.js
 *  vis_testbed
 *
 *  Created by Charles J. Cliffe on 2002-6-22.
 *  Copyright 2009 Cubic Productions. All rights reserved.
 *
 *  Ported to javascript by Corban Brook 2010-06-07
 *
 */

var NULL_CHAR = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

// [256][64]
var bitFont = [
	NULL_CHAR, // 0
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 5
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 10
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 15
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 20
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //25
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR,//30
	NULL_CHAR,
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], //SPACE
	
	[
		0,0,1,0,0,0,0,0,
		0,1,1,1,0,0,0,0,
		0,1,1,1,0,0,0,0,
		0,1,1,1,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,0,0,0,0,0
	], // !
	
	[
		0,0,1,0,1,0,0,0,
		0,0,1,0,1,0,0,0,
		0,0,1,0,1,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // "
	
	[
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0,
		0,1,1,1,1,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,0,0,1,0,0
	], // #			//35
	
	[
		0,0,0,1,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,0,1,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,0,1,0,0,
		0,0,0,1,0,1,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,0,0,0,0
	], // $
	
	[
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,1,0,0,
		0,0,0,0,1,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,0,0,1,1,0,
		0,1,0,0,0,1,1,0,
		0,0,0,0,0,0,0,0
	], // %
	
	[
		0,0,0,1,0,0,0,0,
		0,0,1,0,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,0,0,1,0,0,0,
		0,1,0,0,1,1,1,0,
		0,1,0,0,1,0,0,1,
		0,0,1,1,0,0,0,0
	], // &
	
	[
		0,1,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,1,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // '
	
	[
		0,0,0,0,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,0,1,0,0,0
	], // (			//40
	
	[
		0,1,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,0,0,0,0,0,0
	], // )
	
	[
		0,1,0,1,0,1,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,1,1,1,0,0,0,
		0,1,0,1,0,1,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // *
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // +
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // ,
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // -			//45
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // .
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,1,
		0,0,0,0,0,0,1,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,1,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,1,0,0,0,0,0,0
	], // /
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,1,0,0,1,1,0,
		0,0,1,0,1,0,1,0,
		0,0,1,0,1,0,1,0,
		0,0,1,1,0,0,1,0,
		0,0,1,1,0,1,1,0,
		0,0,0,1,1,1,0,0
	], // 0
	
	[
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,1,1,0
	], // 1
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,1,1,1,1,0,
		0,0,1,1,1,1,1,0
	], // 2			//50
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,0,1,1,1,0,0
	], // 3
	
	[
		0,0,0,0,1,1,0,0,
		0,0,1,0,1,1,0,0,
		0,0,1,0,1,1,0,0,
		0,0,1,0,1,1,0,0,
		0,0,1,0,1,1,0,0,
		0,0,1,1,1,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0
	], // 4
	
	[
		0,0,1,1,1,1,1,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,1,0,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,0,1,1,1,0,0
	], // 5
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,0,1,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,0,1,0,
		0,0,1,1,0,0,1,0,
		0,0,1,1,0,0,1,0,
		0,0,0,1,1,1,0,0
	], // 6
	
	[
		0,0,1,1,1,1,1,0,
		0,0,1,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // 7			//55
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // 8
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // 9
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // :
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,0,0,0,0,0
	], // ;
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,1,0,0
	], // <			//60
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,0,0,0,0,0
	], // =
	
	[
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // >
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0
	], // ?
	
	[
		0,0,1,1,1,1,0,0,
		0,1,0,0,0,0,1,0,
		0,1,0,1,1,0,1,0,
		0,1,1,0,1,0,1,0,
		0,1,1,0,1,0,1,0,
		0,1,0,1,1,1,0,0,
		0,1,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0
	], // @
	
	[
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // A			//65
	
	[
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0
	], // B
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // C
	
	[
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0
	], // D
	
	[
		0,1,1,1,1,1,1,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,1,1,1,1,0
	], // E
	
	[
		0,1,1,1,1,1,1,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // F			//70
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // G
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // H
	
	[
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0
	], // I
	
	[
		0,1,1,1,1,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,0,0,0
	], // J
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,1,1,0,0,
		0,1,1,1,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // K			//75
	
	[
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,1,0,
		0,1,1,1,1,1,1,0
	], // L
	
	[
		0,1,1,0,0,0,1,1,
		0,1,1,1,0,1,1,1,
		0,1,1,1,0,1,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,0,0,0,1,1,
		0,1,1,0,0,0,1,1,
		0,1,1,0,0,0,1,1
	], // M
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,0,1,1,0,
		0,1,1,1,0,1,1,0,
		0,1,1,1,1,1,1,0,
		0,1,1,0,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // N
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // O
	
	[
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // P			//80
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,1,1,1,0,
		0,1,1,0,0,1,0,0,
		0,0,1,1,1,0,1,0
	], // Q
	
	[
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // R
	
	[
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,1,0,0,
		0,0,0,0,1,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // S
	
	[
		0,1,1,1,1,1,1,0,
		0,1,1,1,1,1,1,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // T
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,1,1,1,1,0,
		0,0,1,1,1,1,0,0
	], // U			//85
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // V
	
	[
		0,1,1,0,0,0,1,1,
		0,1,1,0,0,0,1,1,
		0,1,1,0,0,0,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,0,1,0,1,1,
		0,1,1,1,0,1,1,1,
		0,0,1,1,0,1,1,0
	], // W
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0
	], // X
	
	[
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // Y
	
	[
		0,1,1,1,1,1,1,0,
		0,1,0,0,0,1,1,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,0,0,0,1,0,
		0,1,1,1,1,1,1,0
	], // Z			//90
	
	[
		0,0,1,1,1,1,1,0,
		0,0,1,1,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,1,1,0
	], // [
	
	[
		0,1,0,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,0,1,1,0,
		0,0,0,0,0,0,1,0
	], 
	
	[
		0,1,1,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,1,1,0,0,
		0,1,1,1,1,1,0,0
	], // ]
	
	[
		0,0,0,0,1,0,0,0,
		0,0,0,1,0,1,0,0,
		0,0,1,0,0,0,1,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // ^
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,1,1
	], // 0			//95
	
	[
		0,0,0,0,1,1,1,0,
		0,0,0,0,1,1,1,0,
		0,0,0,0,0,0,1,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // '
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,0,0,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0
	], // a
	
	[
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // b
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,1,1,0,0
	], // c 
	
	[
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0
	], // d			//100
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,1,0,0,0
	], // e
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,1,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,1,1,0,0,0
	], // f
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,1,1,1,0,0,0
	], // g
	
	[
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0
	], // h
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0 
	], // i			//105
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,0,0,0,0
	], // j
	
	[
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0
	], // k
	
	[
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0
	], // l
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,1,1,0,1,0,1,0,
		0,1,1,0,1,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0
	], // m
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,1,0,0,
	], // n			//110
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0
	], // o
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,0,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0
	], // p
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,1,0
	], // q
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,0,0,1,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0
	], // r
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,1,1,1,0,0,0
	], // s			//115
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,1,1,1,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,0,1,1,1,0,0,0
	], // t
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,1,0
	], // u
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,0,0,0,
		0,0,0,1,0,0,0,0
	], // v
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,0,0,1,0,
		0,1,1,0,1,0,1,0,
		0,1,1,0,1,0,1,0,
		0,0,1,1,1,1,0,0
	], // w
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,0,1,1,0,
		0,0,1,1,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,1,1,1,1,0,0,
		0,1,1,0,0,1,1,0
	], // x			//120
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,1,1,0,1,1,0,0,
		0,0,1,1,1,0,0,0
	], // y
	
	[
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,1,1,1,1,1,0,0,
		0,0,0,1,1,1,0,0,
		0,0,1,1,1,0,0,0,
		0,0,1,1,1,0,0,0,
		0,1,1,1,0,0,0,0,
		0,1,1,1,1,1,0,0
	], // z
	
	[
		0,0,0,1,1,1,0,0,
		0,0,1,0,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,1,1,0,0,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,1,0,0,0,0,0,
		0,0,0,1,1,1,0,0
	], // [
	
	[
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,0,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,1,1,0,0,0
	], // |
	
	[
		0,1,1,1,0,0,0,0,
		0,0,0,0,1,0,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,0,1,1,0,0,
		0,0,0,1,1,0,0,0,
		0,0,0,0,1,0,0,0,
		0,1,1,1,0,0,0,0
	], // ]			//125
	
	[
		0,0,0,0,0,0,0,0,
		0,0,1,1,0,0,0,0,
		0,1,0,0,1,0,1,0,
		0,0,0,0,0,1,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0
	], // ~
	
	NULL_CHAR, //	127
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 130
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 135
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 140
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 145
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 150
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 155
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 160
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 165
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 170
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 175
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 180
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //185
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //190
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 195
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 200
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 205
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, // 210
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //215
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //220
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //225
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //230
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //235
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //240
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //245
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, //250
	
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR, 
	NULL_CHAR //255
];

</script>
    <script type="text/javascript">
function bitFont3D(elementSource_in,material,uvmapper) {
  this.element_size = 1.0/8.0;
  this.elementSource = null;
  this.trans = new CubicVR.Transform();
  this.chars = [];
  this.material = new CubicVR.Material();
  
  this.genString = function (str_in) {
      var letters = [];
      var strlen = str_in.length;
      var spacing = 0.75;
      var ofs = -strlen / 2.0 * spacing;

      textObj = new CubicVR.SceneObject(null);

      for (var i = 0; i < strlen; i++) {
          var fontObj = new CubicVR.SceneObject({
              mesh: this.chars[str_in.charCodeAt(i)],
              position: [ofs + i * spacing, 0, 0],
              scale: [1, 1, 1]
          });

          textObj.bindChild(fontObj);
      }

      return textObj;
  }
  
  
  this.getElementSize = function() {
    return this.element_size;
  };
  
  this.setElementSource = function(obj_in) {
    this.elementSource = obj_in;
  }
  
  this.setElement = function(type_str,material,uvmapper,undef) {
    if (type_str === "box") {
      this.elementSource =  CubicVR.primitives.box({size:this.element_size,material:material?material:this.material,uvmapper:uvmapper?uvmapper:undef});
    } else if (type_str === "sphere") {
      this.elementSource =  CubicVR.primitives.sphere({radius:this.element_size/2.0,lon:10,lat:5,material:material?material:this.material,uvmapper:uvmapper?uvmapper:undef});
    } else {
      alert("unknown bf3d element type: "+type_str);
    }
  }
  
  this.genLetterMesh = function(lnum) {
    var bf = bitFont[lnum];
    trans = this.trans;

    var c = 0;
    for (var i = 0; i<64; i++) { c+=bf[i]; }
    if (!c) {
      return null;
    }

    var dest = new CubicVR.Mesh();

    for (var i = 0; i<8; i++) {
      for (var j = 0; j<8; j++) {
        var idx = j*8+i;

        if (bf[idx]===1) {
          trans.clearStack();
          trans.translate([-this.element_size*4.0+i*this.element_size,-this.element_size*4.0+(8-j)*this.element_size,0]);

          dest.booleanAdd(this.elementSource,trans);
        }
      }
    }

    return dest;
  }

  this.loadFont = function() {
    for (var i = 0; i < 255; i++) {
      this.chars[i] = this.genLetterMesh(i);
      
      // apply any material stuff here..
      
      if (this.chars[i]) {
        this.chars[i].triangulateQuads().calcNormals().compile().clean();
      }
    }
  }

  // if (typeof(elementSource_in) === 'object') {
  //   this.elementSource = elementSource_in;
  // } else if (typeof(elementSource_in) === 'string') {
    elementSource_in = this.setElement(elementSource_in,material,uvmapper);
  // }
}


</script>
    <script type="text/javascript">
function AnimationKit() {

    this.transition = function (start_time, distance, totaltime, sceneObj, anim_method, in_out) {

        if (!in_out) in_out = "in";
        if (!sceneObj.children) return;

        var nchild = sceneObj.children.length;

        if (anim_method === "spiral") {            
            for (var j = 0; j < nchild; j++) {
                if (!sceneObj.children[j].motion) sceneObj.children[j].motion = new CubicVR.Motion();
                var mot = sceneObj.children[j].motion;
                var spintotal = 360.0 * 1.5;
                var spinstep = (360.0 / 5.0);
                var spincount = (spintotal / spinstep);
                var ystep = distance / spincount;
                var ypos = distance;

                var t;
                var tofs = 0.1 * j;
                var c = 0;
                
                if (in_out == "in") {
                  for (i = 0; i < spintotal - spinstep; i += spinstep) {
                      t = (c / spincount) * totaltime + start_time + tofs;

                      mot.setKey(0, 0, t, distance * (1.0 - c / spincount) * Math.sin(i * (180.0 / M_PI)));
                      mot.setKey(0, 1, t, ypos);
                      mot.setKey(0, 2, t, distance * (1.0 - c / spincount) * Math.cos(i * (180.0 / M_PI)));

                      mot.setKey(1, 0, t, i + tofs);
                      mot.setKey(1, 2, t, -i + tofs);
                      ypos -= ystep;
                      c++;
                  }

                  t = start_time + totaltime + tofs;

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;
                } 
                else { // end: if in
                  mot.setKey(0, 0, start_time, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, start_time, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, start_time, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, start_time, 0).tension=1.0;
                  mot.setKey(1, 2, start_time, 0).tension=1.0;

                  ypos = 0;

                  for (i = spinstep; i < spintotal; i += spinstep) {
                      t = 1.0+(c / spincount) * totaltime + start_time + tofs;

                      mot.setKey(0, 0, t, distance * (c / spincount) * Math.sin(i+90 * (180.0 / M_PI)));
                      mot.setKey(0, 1, t, ypos);
                      mot.setKey(0, 2, t, distance * (c / spincount) * Math.cos(i+90 * (180.0 / M_PI)));

                      mot.setKey(1, 0, t, i + tofs);
                      mot.setKey(1, 2, t, -i + tofs);
                      ypos += ystep;
                      c++;
                  }
                } // end: if out
            } // end: for (j)

        } // end: anim method 'spiral'
        if (anim_method === "spiral2") {            
            for (var j = 0; j < nchild; j++) {
                if (!sceneObj.children[j].motion) sceneObj.children[j].motion = new CubicVR.Motion();
                var mot = sceneObj.children[j].motion;
                var spintotal = 360.0 * 1.5;
                var spinstep = (360.0 / 5.0);
                var spincount = (spintotal / spinstep);
                var ystep = distance / spincount;
                var ypos = distance;

                var t;
                var tofs = 0.05 * j;
                var c = 0;
                
                if (in_out == "in") {
                  for (i = 0; i < spintotal - spinstep; i += spinstep) {
                      t = (c / spincount) * totaltime + start_time + tofs;

                      mot.setKey(0, 0, t, (1.0 - c / spincount)*sceneObj.children[j].position[0]+distance * (1.2 - c / spincount) * Math.sin(i * (180.0 / M_PI)));
                      mot.setKey(0, 1, t, (1.0 - c / spincount)*sceneObj.children[j].position[1]+ypos);
                      mot.setKey(0, 2, t, (1.0 - c / spincount)*sceneObj.children[j].position[2]+distance * (1.2 - c / spincount) * Math.cos(i * (180.0 / M_PI)));

                      mot.setKey(1, 0, t, i + tofs);
                      mot.setKey(1, 2, t, -i + tofs);
                      ypos -= ystep;
                      c++;
                  }

                  t = start_time + totaltime + tofs;

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;
                } 
                else { // end: if in
                  mot.setKey(0, 0, start_time, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, start_time, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, start_time, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, start_time, 0).tension=1.0;
                  mot.setKey(1, 2, start_time, 0).tension=1.0;

                  ypos = 0;

                  for (i = spinstep; i < spintotal; i += spinstep) {
                      t = 1.0+(c / spincount) * totaltime + start_time + tofs;

                      mot.setKey(0, 0, t, (1.0 - c / spincount)*sceneObj.children[j].position[0]+distance * (c / spincount) * Math.sin(i+90 * (180.0 / M_PI)));
                      mot.setKey(0, 1, t, (1.0 - c / spincount)*sceneObj.children[j].position[1]+ypos);
                      mot.setKey(0, 2, t, (1.0 - c / spincount)*sceneObj.children[j].position[2]+distance * (c / spincount) * Math.cos(i+90 * (180.0 / M_PI)));

                      mot.setKey(1, 0, t, i + tofs);
                      mot.setKey(1, 2, t, -i + tofs);
                      ypos += ystep;
                      c++;
                  }
                } // end: if out
            } // end: for (j)

        } // end: anim method 'spiral2'        
        if (anim_method === "random") {
            for (var j = 0; j < nchild; j++) {
                if (!sceneObj.children[j].motion) sceneObj.children[j].motion = new CubicVR.Motion();
                var mot = sceneObj.children[j].motion;
               var t;
                
                if (in_out==="in") {
                  for (i = 0; i < totaltime-totaltime / 5.0; i += totaltime / 5.0) {
                      t = start_time + i;

                      mot.setKey(0, 0, t, (Math.random() - 0.5) * distance);
                      mot.setKey(0, 1, t, (Math.random() - 0.5) * distance);
                      mot.setKey(0, 2, t, (Math.random() - 0.5) * distance);

                      mot.setKey(1, 0, t, (Math.random()) * 360);
                      mot.setKey(1, 2, t, (Math.random()) * 360);
                  }

                  t = start_time + totaltime

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;
                } else {  // end: if 'in'
                  
                  mot.setKey(0, 0, start_time, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, start_time, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, start_time, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, start_time, 0).tension=1.0;
                  mot.setKey(1, 2, start_time, 0).tension=1.0;

                  for (i = 1; i < totaltime; i += totaltime / 5.0) {
                      t = start_time + i;

                      mot.setKey(0, 0, t, (Math.random() - 0.5) * distance);
                      mot.setKey(0, 1, t, (Math.random() - 0.5) * distance);
                      mot.setKey(0, 2, t, (Math.random() - 0.5) * distance);

                      mot.setKey(1, 0, t, (Math.random()) * 360);
                      mot.setKey(1, 2, t, (Math.random()) * 360);
                  }
                  
                  t = start_time+totaltime+totaltime/5.0;

                  var r = CubicVR.vec3.normalize([(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0]);
                  mot.setKey(0, 0, t, distance*r[0]);
                  mot.setKey(0, 1, t, distance*r[1]);
                  mot.setKey(0, 2, t, distance*r[2]);
                  mot.setKey(1, 0, t, Math.random()*360.0);
                  mot.setKey(1, 2, t, Math.random()*360.0);

                } // end: if 'out'
            } // end: for (j)
        } // end: anim method 'random'
        if (anim_method === "explode") {
            for (var j = 0; j < nchild; j++) {
                if (!sceneObj.children[j].motion) sceneObj.children[j].motion = new CubicVR.Motion();
                var mot = sceneObj.children[j].motion;
               var t;
                
                if (in_out==="in") {
                  t = start_time;

                  var r = CubicVR.vec3.normalize([(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0]);
                  mot.setKey(0, 0, t, distance*r[0]);
                  mot.setKey(0, 1, t, distance*r[1]);
                  mot.setKey(0, 2, t, distance*r[2]);

                  mot.setKey(1, 0, t, (Math.random()) * 360);
                  mot.setKey(1, 2, t, (Math.random()) * 360);

                  mot.setKey(1, 0, start_time+totaltime/2.0, (Math.random()) * 360);
                  mot.setKey(1, 2, start_time+totaltime/2.0, (Math.random()) * 360);

                  t = start_time + totaltime

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;

                } else {  // end: if 'in'
                  t = start_time;

                  mot.setKey(0, 0, t, sceneObj.children[j].position[0]).tension=1.0;
                  mot.setKey(0, 1, t, sceneObj.children[j].position[1]).tension=1.0;
                  mot.setKey(0, 2, t, sceneObj.children[j].position[2]).tension=1.0;
                  mot.setKey(1, 0, t, 0).tension=1.0;
                  mot.setKey(1, 2, t, 0).tension=1.0;

                  mot.setKey(1, 0, start_time+totaltime/2.0, Math.random()*360.0);
                  mot.setKey(1, 2, start_time+totaltime/2.0, Math.random()*360.0);

                  t = start_time+totaltime;

                  var r = CubicVR.vec3.normalize([(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0,(Math.random()-0.5)*2.0]);
                  mot.setKey(0, 0, t, distance*r[0]);
                  mot.setKey(0, 1, t, distance*r[1]);
                  mot.setKey(0, 2, t, distance*r[2]);
                  mot.setKey(1, 0, t, Math.random()*360.0);
                  mot.setKey(1, 2, t, Math.random()*360.0);

                } // end: if 'out'
            } // end: for (j)
        } // end: anim method 'explode'
 
    }
}

</script>
    <script type="text/javascript">
function Segment (options) {
  this.active = false;
  this.startTime = options.startTime || 0;
  this.update = options.update || function (timer) {};
  this.updateFunction = function (timer) {
    if (this.active) {
      this.update(timer);
    } //if
  };
  this.prepare = options.prepare || function (prepareOptions) {};
  this.load = options.load || function () {};
  this.unload = options.unload || function () {};
}; //Segment

var SegmentList = new function () {
  this.segments = [];
  this.currentSegment = undefined;

  this.addSegment = function (segment) {
    this.segments.push(segment);
  };

  this.updateSegments = function (timer) {
    for (var i=0, l=this.segments.length; i<l; ++i) {
      this.segments[i].updateFunction(timer);
    } //for
  };

  this.prepareSegments = function (options) {
    for (var i=0, l=this.segments.length; i<l; ++i) {
      this.segments[i].prepare(options);
    } //for
  };

  this.nextSegment = function (lastSceneTimeout) {
    lastSegment = this.currentSegment;

    if (this.currentSegment === undefined) {
      this.currentSegment = this.segments[0];
    }
    else {
      this.currentSegment = this.segments[this.segments.indexOf(this.currentSegment)+1];
    } //if

    this.currentSegment.load();
    this.currentSegment.active = true;

    if (lastSegment) {
      var time = lastSceneTimeout || 0;
      setTimeout(function () {
        lastSegment.active = false;
        lastSegment.unload();
      }, time);
    } //if
  };

}; //SegmentList

</script>
    <script type="text/javascript">
SegmentList.addSegment(function () {

  var audioEngine, audioBuffer, fft, popcorn;
  var scene, animKit, bf3d, bfMaterial, targetFOV = 80;
  var dateTextObjects = [], dirLight, spotLights = [];

  function makeCylinderLathe(mesh, height, inner_radius, outer_radius, res, material, uvmapper) {
    var pointList = new Array();
    var thick = outer_radius-inner_radius;
    var radius = inner_radius+(thick)/2.0;
    var transform;

    pointList.push([inner_radius, 0, 0]);
    pointList.push([inner_radius+thick, 0, 0]);
    pointList.push([inner_radius+thick, height, 0]);
    pointList.push([inner_radius, height, 0]);
    pointList.push([inner_radius, 0, 0]);

    CubicVR.genLatheObject(mesh, pointList, res, material, transform, uvmapper);
  };

  var floorUV = {
    projectionMode: CubicVR.enums.uv.projection.SPHERICAL,
    projectionAxis: CubicVR.enums.uv.axis.Y,
    scale: [1, 1, 1]
  };
  
  var SOUND_FLOOR_RINGS = 25,
      SOUND_FLOOR_Y = -5,
      SOUND_FLOOR_H = 2.0,
      SOUND_FLOOR_SPACING = 0.35,
      MAX_WIDTH = 45;

  var soundFloorRings = [];
  var soundFloorRingParent = new CubicVR.SceneObject(new CubicVR.Mesh());

  var floorBumpTexture, floorNormalTexture, floorMaterial,
      floorShapeMode = 0, floorColorMode = 0,
      currentSeconds;

  function updateSoundFloor(seconds) {
    for (var i=0; i<SOUND_FLOOR_RINGS; ++i) {
      var ring = soundFloorRings[i];
      var v = ring.material.color[0];
      if (floorShapeMode === 0) {
        var newY = ring.baseY + fft.spectrum[2*(i)] * 40;
        if (ring.targetY < newY) {
          ring.targetY = newY;
          v = fft.spectrum[2*i] * 50;
        } //if
        ring.targetY = Math.max(ring.targetY - 0.1, ring.baseY);
      } //if
      if (floorColorMode === 0) {
        v = Math.min(0.5, v-0.05);
      }
      else if (floorColorMode === 1) {
        v = Math.max(0.5, v-0.05);
      }
      else if (floorColorMode === 2) {
        v = 1.0;
      } //if

      ring.position[1] -= (ring.position[1] - ring.targetY)*.25;
      ring.material.color = [Math.min(1, v*(Math.sin(seconds)*.5 + 1)*.9), Math.min(1, v*(Math.sin(seconds-1)*.5 + 1)*.9), Math.min(1, v*(Math.sin(seconds-2)*.5 + 1)*.9)];
      if (floorShapeMode === 0) {
        ring.rotation[1] = Math.sin(seconds + (SOUND_FLOOR_RINGS-i)*0.1)*120;
      }
      else {
        ring.rotation[1] = seconds * 100 + 30*i;
      } //if
    } //for
    if (floorShapeMode === 1) {
      floorBumpTexture.update();
      floorNormalTexture.update();
    } //if
  }; //updateSoundFloor

  return new Segment({
    prepare: function (options) {

      audioEngine = options.audioEngine;
      popcorn = options.popcorn;
      scene = options.scene;
      animKit = new AnimationKit();

      var spotLight;

      spotLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.SPOT_SHADOW,
        specular: [0.4,0.4,0.4],
        diffuse: [1,1,1],
        intensity: .2,
        distance: 100,
        cutoff: 50,
        map_res: 1024,
        position: [-7,10,-5]
      });

      spotLight.lookat([0,0,0]);
      scene.bindLight(spotLight);
      spotLights.push(spotLight);

      spotLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.SPOT_SHADOW,
        specular: [0.4,0.4,0.4],
        diffuse: [1,1,1],
        intensity: .3,
        distance: 100,
        cutoff: 300,
        map_res: 1024,
        position: [0, 8, 0],
      });

      spotLight.lookat([-2, 0, -4]);
      scene.bindLight(spotLight);
      spotLights.push(spotLight);


      dateTextObjects[0] = new CubicVR.SceneObject(CubicVR.primitives.plane({
        size: 8.0,
        material: new CubicVR.Material({
          textures: {
            color: new CubicVR.TextTexture('June', {font:'200pt Arial'}),
          }
        }),
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.PLANAR,
          projectionAxis: CubicVR.enums.uv.axis.Z,
          scale: [1.2, 1.2, 1.2],
        },
      }).triangulateQuads().compile().clean());

      dateTextObjects[1] = new CubicVR.SceneObject(CubicVR.primitives.plane({
        size: 8.0,
        material: new CubicVR.Material({
          textures: {
            color: new CubicVR.TextTexture('18', {font:'200pt Arial'}),
          }
        }),
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.PLANAR,
          projectionAxis: CubicVR.enums.uv.axis.Z,
          scale: [1.2, 1.2, 1.2],
        },
      }).triangulateQuads().compile().clean());

      bfMaterial = new CubicVR.Material({
        color: [0.8,0.3,0.2],
        specular: [1, 5, 0],
        shininess: 0.9,
        textures: {
          envsphere: new CubicVR.CanvasTexture(document.getElementById("img/fract_reflections.jpg"))
        }
      });
        
      var bfUV = new CubicVR.UVMapper({
        projectionMode: CubicVR.enums.uv.projection.CUBIC,
        scale: [1, 1, 1]
      });

      bf3d = new bitFont3D("box", bfMaterial, bfUV);
      bf3d.loadFont();

      floorBumpTexture = new CubicVR.CanvasTexture({
        update: function (canvas, ctx) {
          for (var i=0; i<10; ++i) {
            var radius = Math.round(Math.random()*3);
            ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#000000';
            ctx.beginPath();
            ctx.arc(Math.floor(Math.random()*256), Math.floor(Math.random()*256), radius, 0, Math.PI*2, true);
            ctx.fill();
          } //for
        },
        width: 256,
        height: 256,
      });

      floorNormalTexture = new CubicVR.NormalMapGen(floorBumpTexture, 256, 256);

      floorMaterial = new CubicVR.Material({
        color: [0.3, 0.3, 0.3],
        textures: {
          bump: floorBumpTexture,
          normal: floorNormalTexture,
        },
        opacity: 1,
      });

      for (var i=0; i<SOUND_FLOOR_RINGS; ++i) {
        var floorMaterial = new CubicVR.Material({
          color: [0.3, 0.3, 0.3],
          textures: {
            bump: floorBumpTexture,
            normal: floorNormalTexture,
          },
          opacity: 1,
        });
        var soundFloorMesh = new CubicVR.Mesh();
        makeCylinderLathe(soundFloorMesh, SOUND_FLOOR_H, i*MAX_WIDTH/SOUND_FLOOR_RINGS, (i+1)*MAX_WIDTH/SOUND_FLOOR_RINGS-SOUND_FLOOR_SPACING, 3, floorMaterial, floorUV);
        soundFloorMesh.triangulateQuads().compile().clean();
        var soundFloorObject = new CubicVR.SceneObject(soundFloorMesh);
        soundFloorRingParent.bindChild(soundFloorObject);
        soundFloorRings.push(soundFloorObject);
        soundFloorObject.targetY = SOUND_FLOOR_Y + i/3;
        soundFloorObject.baseY = SOUND_FLOOR_Y + i/3;
        soundFloorObject.rotation[1] = 3*i;
        soundFloorObject.material = floorMaterial;
      } //for

      popcorn.code({
        start: 1,
        end: 13,
        onStart: function (options) {
          var bfStr = bf3d.genString("#audio welcomes you");
          animKit.transition(currentSeconds, 5, 3, bfStr, "spiral");
          options.bfStr = bfStr;
          scene.bindSceneObject(bfStr);
        },
        onEnd: function (options) {
          animKit.transition(currentSeconds, 20, 3, options.bfStr, 'explode', 'out');
          setTimeout(function(){
            scene.removeSceneObject(options.bfStr);
          }, 3000);
        },
      });

      popcorn.code({
        start: 9,
        end: 24,
        onStart: function (options) {
          var bfStr = bf3d.genString("to flameparty!!");
          animKit.transition(currentSeconds, 5, 3, bfStr, "spiral");
          options.bfStr = bfStr;
          scene.bindSceneObject(bfStr);
        },
        onEnd: function (options) {
          animKit.transition(currentSeconds, 20, 3, options.bfStr, 'random', 'out');
          setTimeout(function(){
            scene.removeSceneObject(options.bfStr);
          }, 3000);
        },
      });

      popcorn.code({
        start: 15,
        end: 25,
        onStart: function (options) {
          var bfStr = bf3d.genString("Helsinki");
          animKit.transition(currentSeconds, 5, 3, bfStr, 'explode', 'in');
          options.bfStr = bfStr;
          bfStr.scale = [3, 3, 3];
          bfStr.position = [6, 2.8, -8];
          bfStr.rotation[1] = -45;
          scene.bindSceneObject(bfStr);
        },
        onEnd: function (options) {
          animKit.transition(currentSeconds, 20, 3, options.bfStr, 'random', 'out');
          setTimeout(function(){
            scene.removeSceneObject(options.bfStr);
          }, 3000);
        },
      });

      popcorn.code({
        start: 18,
        end: 28,
        onStart: function (options) {
          var bfStr = bf3d.genString("Finland");
          animKit.transition(currentSeconds, 5, 3, bfStr, 'explode', 'in');
          options.bfStr = bfStr;
          bfStr.scale = [3, 3, 3];
          bfStr.position = [-5, 3.8, -7];
          bfStr.rotation[1] = 45;
          scene.bindSceneObject(bfStr);
          spotLights[1].lookat(bfStr.position);
        },
        onEnd: function (options) {
          animKit.transition(currentSeconds, 20, 3, options.bfStr, 'explode', 'out');
          setTimeout(function(){
            scene.removeSceneObject(options.bfStr);
          }, 3000);
        },
      });

      popcorn.code({
        start: 9,
        end: 11,
        onStart: function (options) {
          floorColorMode = 1;
        },
      });

      popcorn.code({
        start: 28,
        end: 36,
        onStart: function (options) {
          for (var i=0; i<soundFloorRings.length; ++i) {
            var ring = soundFloorRings[i];
            ring.targetY = 1-i*1.5;
          } //for
          floorShapeMode = 1;
          floorColorMode = 2;

          spotLights[0].position = [2, 2, 35];
          spotLights[1].position = [-1, 10, 35];
          spotLights[0].lookat([1, 0, 0]);
          spotLights[1].lookat([0, 0, 0]);
          spotLights[0].cutoff = 400;
          spotLights[1].cutoff = 400;
          spotLights[0].intensity = .2;
          spotLights[1].intensity = .2;

          dateTextObjects[0].scale = [50, 40, 1];
          dateTextObjects[0].rotation[1] = 180;
          dateTextObjects[0].position = [-15, -2, -10];

          dateTextObjects[1].scale = [80, 100, 1];
          dateTextObjects[1].rotation[1] = 180;
          dateTextObjects[1].position = [30, -12, -15];

          var mot = dateTextObjects[1].motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, currentSeconds, dateTextObjects[0].position[1]).tension=1;
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, currentSeconds+25, dateTextObjects[0].position[1]-60).tension=1;
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, currentSeconds+26, dateTextObjects[0].position[1]-420).tension=1;

          var mot = dateTextObjects[0].motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, currentSeconds, dateTextObjects[1].position[2]).tension=1;
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, currentSeconds+25, dateTextObjects[1].position[2]-60).tension=1;
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, currentSeconds+26, dateTextObjects[1].position[2]-420).tension=1;

          scene.bindSceneObject(dateTextObjects[0]);
          scene.bindSceneObject(dateTextObjects[1]);

        },
        onEnd: function (options) {
          targetFOV = 65;
        },
      });

      function curveLetters(bfStr) {
        var tilt = 70/bfStr.children.length;
        for (var i=0; i<bfStr.children.length; ++i) {
          var letter = bfStr.children[i];
          var xofs = letter.position[0];
          letter.position[2] = bfStr.children.length/2+Math.cos(xofs/2);
          letter.rotation[1] = xofs * tilt;
        } //for
      }; //curveLetters

      function setupLettersMotion(bfStr, startTime, endTime, offset) {
        offset = offset || [0,0,0];
        bfStr.position = [0, -20, 0];
        var mot = bfStr.motion = new CubicVR.Motion();
        mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, startTime, -20+offset[1]);
        mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, startTime+.5, 0+offset[1]);
        mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, startTime, -180).tension = 1;
        mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, startTime+.5, 0).tension = 1;
        mot.setBehavior(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);

        mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, endTime, 0+offset[1]);
        mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, endTime+.5, -20+offset[1]);
        mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, endTime, 0).tension = 1;
        mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, endTime+.5, 180).tension = 1;
        mot.setBehavior(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
 
      }; //setupLettersMotion

      var words = [
        [bf3d.genString('starring')],
        [bf3d.genString('secret'),bf3d.genString('robotron')],
        [bf3d.genString('ccliffe')],
        [bf3d.genString('humph')],
        [bf3d.genString('corban')],
        [bf3d.genString('cubicvr')],
        [bf3d.genString('popcorn')],
      ];

      for (var i=0; i<words.length; ++i) {
        (function (bfStrs) {
          popcorn.code({
            start: 36+i*3,
            end: 40+i*3,
            onStart: function (options) {
              for (var j=0; j<bfStrs.length; ++j) {
                var bfStr = bfStrs[j];
                curveLetters(bfStr);
                options.bfStr = bfStr;
                setupLettersMotion(bfStr, currentSeconds, currentSeconds+3, [0, -3*j, 0]);
                bfStr.scale = [3, 3, 3];
                scene.bindSceneObject(bfStr);
              } //for
            },
            onEnd: function (options) {
              for (var j=0; j<bfStrs.length; ++j) {
                scene.removeSceneObject(bfStrs[j]);
              } //for
            },
          });
        })(words[i]);
      } //for

      var FINISH_FLOOR = 40 + words.length*3;

      var mot = soundFloorRingParent.motion = new CubicVR.Motion();
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, FINISH_FLOOR, 0);
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, FINISH_FLOOR + .2, 0.6).tension = 1;
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, FINISH_FLOOR + 2, -100).tension = 1;
      mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);

      popcorn.code({
        start: FINISH_FLOOR+5,
        end: FINISH_FLOOR+6,
        onStart: function (options) {
          soundFloorRingParent.visible = false;
        }
      });

      dirLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.DIRECTIONAL,
        specular: [1,1,1],
        intensity: .4,
        direction: CubicVR.vec3.normalize([0.5,-1,0.5])
      });
      scene.bindLight(dirLight);

    },
    load: function () {
      shaders['quarterbloom'].enabled = false;
      shaders['halfbloom'].enabled = true;
      shaders['dof'].enabled = false;
      shaders['ssao'].enabled = true;
      scene.bindSceneObject(soundFloorRingParent);
    },
    unload: function () {
      scene.removeLight(dirLight);
      scene.removeLight(spotLights[0]);
      scene.removeLight(spotLights[1]);
      scene.removeSceneObject(soundFloorRingParent);
      for (var i=0; i<dateTextObjects.length; ++i) {
        scene.removeSceneObject(dateTextObjects[i]);
      } //for
    },
    update: function (timer) {
      audioBuffer = audioEngine.audioBuffer;
      fft = audioEngine.fft;
      currentSeconds = timer.getSeconds();

      if (audioBuffer) {
        updateSoundFloor(currentSeconds);
      } //if
      if (floorShapeMode === 0) {
        scene.camera.position[0] = 3 + 4 * Math.sin(currentSeconds/1.2) + Math.cos(currentSeconds/2) * 1.5;
        scene.camera.position[2] = 3 + Math.sin(currentSeconds/5) + Math.cos(currentSeconds/2) * 1.5;
      }
      else if (floorShapeMode === 1) {
        scene.camera.position[0] -= (scene.camera.position[0] - 0)*.85;
        scene.camera.position[1] -= (scene.camera.position[1] - 0)*.85;
        scene.camera.position[2] -= (scene.camera.position[2] - 22)*.85;
        scene.camera.setFOV(scene.camera.fov - (scene.camera.fov - targetFOV)*.15);
      } //if

    },
  });
}());

</script>
    <script type="text/javascript">
SegmentList.addSegment(function () {
  var START_TIME = 65;

  var audioEngine;
  var audioBuffer, fft;
  var popcorn;
  var scene, animkit, bf3d;

  var spotLight, pointLight;

  var cameraTarget = [0,0,0],
      cameraMode = 0,
      cameraPosition = [0,0,0];

  var boxRotation = 0;

  function makeWireBoxObject(boxObject,boxSize,boxMesh) {
    for (var i = 1; i <= boxSize; i++) {
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2+i,boxSize/2,boxSize/2],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2+i,-boxSize/2,boxSize/2],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2+i,boxSize/2,-boxSize/2],mesh:boxMesh}));                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2+i,-boxSize/2,-boxSize/2],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,boxSize/2,-boxSize/2+i],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,-boxSize/2,-boxSize/2+i],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[boxSize/2,boxSize/2,-boxSize/2+i],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[boxSize/2,-boxSize/2,-boxSize/2+i],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[boxSize/2,-boxSize/2+i,boxSize/2],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[boxSize/2,-boxSize/2+i,-boxSize/2],mesh:boxMesh}));
                 
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,-boxSize/2+i,boxSize/2],mesh:boxMesh}));
      boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,-boxSize/2+i,-boxSize/2],mesh:boxMesh}));
    }

    boxObject.bindChild(new CubicVR.SceneObject({position:[-boxSize/2,-boxSize/2,-boxSize/2],mesh:boxMesh}));
  }; //makeWireBoxObject

  var boxObject;

  return new Segment({
    startTime: START_TIME,

    prepare: function (options) {
      audioEngine = options.audioEngine;
      popcorn = options.popcorn;
      scene = options.scene;
      animkit = new AnimationKit();

      bfMaterial = new CubicVR.Material({
        color: [0.8,0.3,0.2],
        specular: [1, 5, 0],
        shininess: 0.9,
        textures: {
          envsphere: new CubicVR.CanvasTexture(document.getElementById("img/fract_reflections.jpg"))
        }
      });
        
      var bfUV = new CubicVR.UVMapper({
        projectionMode: CubicVR.enums.uv.projection.CUBIC,
        scale: [1, 1, 1]
      });

      bf3d = new bitFont3D("box", bfMaterial, bfUV);
      bf3d.loadFont();

      var boxMaterial = new CubicVR.Material({
        color: [0.3,0.4,0.9],
        specular: [1,1,1],
        shininess: 0.9,
        textures: {
          envsphere: new CubicVR.CanvasTexture(document.getElementById("img/fract_reflections.jpg"))
        }
      });

      var boxMesh = CubicVR.primitives.box({
        size: 1.0,
        material: boxMaterial,
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.CUBIC,
          scale: [1,1,1]
        }
      });

      boxMesh.triangulateQuads().compile().clean();

      boxObject = new CubicVR.SceneObject(null);

      makeWireBoxObject(boxObject,7,boxMesh);
      makeWireBoxObject(boxObject,3,boxMesh);

      animkit.transition(START_TIME+0, 10, 2, boxObject, "spiral2");
      animkit.transition(START_TIME+15, 40, 2, boxObject, "explode","out");
      animkit.transition(START_TIME+20, 10, 2, boxObject, "random");
      animkit.transition(START_TIME+28, 50, 2, boxObject, "spiral2","out");
      animkit.transition(START_TIME+48, 40, 2, boxObject, "explode");

      spotLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.SPOT,
        specular: [0.4,0.4,0.4],
        diffuse: [1,1,1],
        intensity: .3,
        distance: 200,
        cutoff: 400,
        //map_res: 1024,
        position: [0, 8, -8],
      });

      pointLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.POINT,
        specular: [1,1,1],
        intensity: .5,
        distance: 100,
        position: [0, 2, 0],
      });

      spotLight.lookat([0, 0, 0]);

      var words = [
        bf3d.genString('Moz Labs'),
        bf3d.genString('Alternative Party'),
        bf3d.genString('& DOT'),
        bf3d.genString('Present:'),
      ];

      for (var j=0; j<words.length; ++j) {
        (function (bfStr, i) {
          popcorn.code({
            start: START_TIME+21+i/2,
            end: START_TIME+43+i/2,
            onStart: function (options) {
              bfStr.position = [-3+5*i, 3-i, -8];
              var startTime = START_TIME + 20;
              var mot = bfStr.motion = new CubicVR.Motion();
              mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, startTime, bfStr.position[0]);
              mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, startTime+3, bfStr.position[0]+2);
              mot.setBehavior(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
              options.bfStr = bfStr;
              animkit.transition(START_TIME+40+i/2, 40, 2, bfStr, "explode", 'out');
              scene.bindSceneObject(bfStr);
            },
            onEnd: function (options) {
              scene.removeSceneObject(options.bfStr);
            },
          });

          popcorn.code({
            start: START_TIME+27+i*2,
            end: START_TIME+27.5+i*2,
            onStart: function (options) {
              cameraTarget = bfStr.position;
              cameraPosition = [bfStr.position[0]+2, bfStr.position[1]-1.3, bfStr.position[2]+2.5];
            },
          });
        })(words[j], j);
      } //for

      popcorn.code({
        start: START_TIME+25.5,
        end: START_TIME+26,
        onStart: function (options) {
          cameraMode = 1;
          cameraPosition = [4, 2, 5];
        },
      });

      popcorn.code({
        start: START_TIME+35,
        end: START_TIME+50,
        onStart: function (options) {
          spotLight.position = [0, 8, 0];
          cameraPosition = [2, 5, -9];
          cameraTarget = [0, 3, 8];
          var bfStrs = [
            bf3d.genString('Demo Art'),
            bf3d.genString('on the'),
            bf3d.genString('Open Web platform'),
          ];

          bfStrs[0].scale = [5, 5, 5];
          bfStrs[0].position = [-5, 5.5, 9];
          bfStrs[0].rotation[1] = 170;
          bfStrs[1].scale = [1, 1, 1];
          bfStrs[1].position = [0, 0, 10];
          bfStrs[1].rotation[1] = 180;
          bfStrs[2].scale = [4, 4, 4];
          bfStrs[2].position = [-11, -4.5, 11.5];
          bfStrs[2].rotation[1] = 190;

          var bfStr = bfStrs[0];
          var mot = bfStr.motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, START_TIME+35, bfStr.position[0]);
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, START_TIME+50, bfStr.position[0]+1);
          mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
          bfStr = bfStrs[1];
          mot = bfStr.motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, START_TIME+35, bfStr.position[1]);
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, START_TIME+50, bfStr.position[1]-1);
          mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);
          bfStr = bfStrs[2];
          mot = bfStr.motion = new CubicVR.Motion();
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Z, START_TIME+35, bfStr.position[2]);
          mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.Z, START_TIME+50, bfStr.position[2]+1);
          mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.Z, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);

          scene.bindSceneObject(bfStrs[0]);
          scene.bindSceneObject(bfStrs[1]);
          scene.bindSceneObject(bfStrs[2]);

          animkit.transition(START_TIME+47, 40, 3, bfStrs[0], "explode", "out");
          animkit.transition(START_TIME+47, 40, 3, bfStrs[1], "explode", "out");
          animkit.transition(START_TIME+47, 40, 3, bfStrs[2], "explode", "out");

          spotLight.lookat(bfStrs[1].position);
         
          options.bfStrs = bfStrs;
        },
        onEnd: function (options) {
          scene.removeSceneObject(options.bfStrs[0]);
          scene.removeSceneObject(options.bfStrs[1]);
          scene.removeSceneObject(options.bfStrs[2]);
        },
      });

      popcorn.code({
        start: START_TIME+50,
        end: START_TIME+53,
        onStart: function (options) {
          cameraTarget = [0, 0, 0];
          cameraPosition = [10, 10, 10];
        },
        onEnd: function (options) {
          boxRotation = 1;
        },
      });

      popcorn.code({
        start: START_TIME+57,
        end: START_TIME+60,
        onStart: function (options) {
          animkit.transition(START_TIME+57, 300, 3, boxObject, "explode", "out");
        },
      });

    },
    load: function () {
      shaders['ssao'].enabled = false;
      scene.bindLight(spotLight);
      scene.bindLight(pointLight);
      scene.bindSceneObject(boxObject);
    },
    unload: function () {
      scene.removeLight(spotLight);
      scene.removeLight(pointLight);
      scene.removeSceneObject(boxObject);
    },
    update: function (timer) {
      var seconds = timer.getSeconds();

      boxRotation *= 1.07;
      boxObject.rotation[1] += boxRotation;

      if (cameraMode === 0) {
        scene.camera.position[0] = 5 * Math.sin(seconds / 5) + Math.cos(seconds / 2) * 3.5;
        scene.camera.position[2] = 5 * Math.cos(seconds / 5) + Math.cos(seconds / 2) * 3.5;
      }
      else if (cameraMode === 1) {
        scene.camera.target[0] -= (scene.camera.target[0] - cameraTarget[0]) *.35;
        scene.camera.target[1] -= (scene.camera.target[1] - cameraTarget[1]) *.35;
        scene.camera.target[2] -= (scene.camera.target[2] - cameraTarget[2]) *.35;
        scene.camera.position[0] -= (scene.camera.position[0] - cameraPosition[0]) *.35;
        scene.camera.position[1] -= (scene.camera.position[1] - cameraPosition[1]) *.35;
        scene.camera.position[2] -= (scene.camera.position[2] - cameraPosition[2]) *.35;
      } //if
    },
  });

}());
 

</script>
    <script type="text/javascript">
SegmentList.addSegment(function () {
  var START_TIME = 126;

  var audioEngine;
  var audioBuffer, fft;
  var popcorn;
  var scene, animkit, bf3d;

  var logoObject, words, audioPlane, audioTexture;
  var canvas, links = [], mvc;
  var currentSeconds;
  var rootLinkObject;

  return new Segment({
    startTime: START_TIME,

    prepare: function (options) {
      audioEngine = options.audioEngine;
      popcorn = options.popcorn;
      scene = options.scene;
      canvas = options.canvas;
      animkit = new AnimationKit();

      bfMaterial = new CubicVR.Material({
        color: [0.8,0.3,0.2],
        specular: [1, 5, 0],
        shininess: 0.9,
        textures: {
          envsphere: new CubicVR.CanvasTexture(document.getElementById("img/fract_reflections.jpg"))
        }
      });
        
      var bfUV = new CubicVR.UVMapper({
        projectionMode: CubicVR.enums.uv.projection.CUBIC,
        scale: [1, 1, 1]
      });

      bf3d = new bitFont3D("box", bfMaterial, bfUV);
      bf3d.loadFont();

      audioTexture = new CubicVR.CanvasTexture({
        update: function (canvas, ctx) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
          ctx.fillRect(0, 0, 512, 512);
          ctx.strokeStyle = "rgb("+Math.floor(255*(Math.sin(currentSeconds/2)*.5+1))+", "+Math.floor(255*(Math.sin(currentSeconds/4)*.5+1))+", "+Math.floor(255*(Math.sin(currentSeconds/3)*.5+1))+")";
          ctx.moveTo(0, 128);
          ctx.lineWidth = 4;
          ctx.beginPath();
          for (var i=0; i<256 && i<audioBuffer.length; ++i) {
            ctx.lineTo(i, 128 + audioBuffer[i]*64);
          }//for
          ctx.stroke();
        },
        width: 256,
        height: 256,
      });

      var s = 50.0;
      audioPlane = new CubicVR.SceneObject(CubicVR.primitives.plane({
        size: s,
        material: new CubicVR.Material({
          textures: {
            color: audioTexture,
          }
        }),
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.PLANAR,
          projectionAxis: CubicVR.enums.uv.axis.Z,
          scale: [s, s, s],
        },
      }).triangulateQuads().compile().clean());

      function makeLinkObject(text, link, color, position, scale, rotation) {
        var linkObject = new CubicVR.SceneObject(CubicVR.primitives.plane({
          size: 1,
          material: new CubicVR.Material({
            textures: {
              color: new CubicVR.TextTexture(text, {font: '100pt Arial', color: color}),
            },
          }),
          uvmapper: {
            projectionMode: CubicVR.enums.uv.projection.PLANAR,
            projectionAxis: CubicVR.enums.uv.axis.Z,
            scale: [1, 1, 1],
          },
        }).triangulateQuads().compile().clean());

        linkObject.position = position;
        linkObject.rotation = rotation;
        linkObject.scale = scale;

        linkObject.href = link;

        links.push(linkObject);
      };

      makeLinkObject('mozillalabs.com/demoparty/helsinki', 'http://mozillalabs.com/demoparty/helsinki', '#ffaa00', [1, .4, 0], [.9, .2, 1], [0, 45, 10]);
      makeLinkObject('github.com/cjcliffe/CubicVR.js', 'http://github.com/cjcliffe/CubicVR.js', '#ffffff', [-1, .4, 0], [.8, .2, 1], [0, -45, -10]);
      makeLinkObject('github.com/BillyWM/jsmodplayer', 'http://github.com/BillyWM/jsmodplayer', '#ffffff', [-1, -.4, 0], [.8, .2, 1], [0, -45, 10]);
      makeLinkObject('github.com/webmademovies/popcorn-js', 'http://github.com/webmademovies/popcorn-js', '#ffffff', [1, -.4, 0], [.8, .2, 1], [0, 45, -10]);

      audioPlane.position = [0, 0, 6];

      var logoMaterial = new CubicVR.Material({
        textures: {
          color: new CubicVR.CanvasTexture(document.getElementById("img/logo.jpg")),
          alpha: new CubicVR.CanvasTexture(document.getElementById("img/logo-alpha.jpg")),
        },
      });

      var logoMesh = CubicVR.primitives.plane({
        size: 5.0,
        material: logoMaterial,
        uvmapper: {
          projectionMode: CubicVR.enums.uv.projection.PLANAR,
          projectionAxis: CubicVR.enums.uv.axis.Z,
          scale: [5, 5, 5],
        }
      });

      logoMesh.triangulateQuads().compile().clean();

      logoObject = new CubicVR.SceneObject(logoMesh);

      logoObject.position = [0, 0, 3.5];
      logoObject.rotation[1] = 90;

      var mot = logoObject.motion = new CubicVR.Motion();
      mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, START_TIME+1, 90).tension=1;
      mot.setKey(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, START_TIME+3, 0).tension=1;
      mot.setBehavior(CubicVR.enums.motion.ROT, CubicVR.enums.motion.Y, CubicVR.enums.envelope.behavior.CONSTANT, CubicVR.enums.envelope.behavior.CONSTANT);

      var str = 'Register now!! June 18th, Helsinki, Finland. Mozilla Labs, Alternative Party and DOT present: Demo Art on the Open Web Platform; THE FLAME PARTY!!   --   Thanks to jsmodplayer, popcorn.js, cubicvr.js, for driving this thing, and xtd/mystic & pulse for the tunes. #audio expects you to show your stuff at FlameParty. -- ';
      words = bf3d.genString(str);

      words.position = [0, -1.5, 2];
      words.rotation = [0, 180, 0];
      mot = words.motion = new CubicVR.Motion();
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, START_TIME, -str.length/2).tension=0;
      mot.setKey(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, START_TIME+90, str.length/2).tension=0;
      mot.setBehavior(CubicVR.enums.motion.POS, CubicVR.enums.motion.X, CubicVR.enums.envelope.behavior.REPEAT, CubicVR.enums.envelope.behavior.REPEAT);

      for (var i=0; i<links.length; ++i) {
        links[i].restingScale = [links[i].scale[0], links[i].scale[1], links[i].scale[2]];
        links[i].targetScale = [links[i].scale[0], links[i].scale[1], links[i].scale[2]];
        links[i].activeScale = [links[i].scale[0]*2, links[i].scale[1]*2, links[i].scale[2]*2];
      } //for

      rootLinkObject = new CubicVR.SceneObject(null);
      for (var i=0; i<links.length; ++i) {
        rootLinkObject.bindChild(links[i]);
      } //for

      animkit.transition(START_TIME+3, 20, 3, rootLinkObject, "spiral");

    },
    load: function () {
      shaders['ssao'].enabled = true;
      shaders['halfbloom'].enabled = true;
      scene.camera.position = [0, 0, -1.5];
      scene.camera.target = [0, 0, 0];
      scene.camera.setFOV(80);
      scene.bindSceneObject(audioPlane);
      scene.bindSceneObject(rootLinkObject, true);
      scene.bindSceneObject(logoObject);
      scene.bindSceneObject(words);
      var pLight = new CubicVR.Light({
        type: CubicVR.enums.light.type.POINT,
        specular: [1, 1, 1],
        diffuse: [1, 1, 1],
        intensity: .5,
        distance: 10,
       aposition: [0, 0, 2],
      });
      scene.bindLight(pLight);
      var spotLight = (new CubicVR.Light({
        type: CubicVR.enums.light.type.SPOT_SHADOW,
        specular: [1 ,1, 1],
        diffuse: [1, 1, 1],
        intensity: .4,
        distance: 15,
        cutoff: 200,
        map_res: 1024,
        position: [0, -2, -3],
      }));
      spotLight.lookat([0, 0, 0]);
      scene.bindLight(spotLight);

      mvc = new CubicVR.MouseViewController(canvas, scene.camera);
      canvas.addEventListener('click', function (e) {
        for (var i=0; i<links.length; ++i) {
          if (links[i].mouseOver) {
            window.open(links[i].href, '_blank');
          } //if
        } //for
      }, false);
    },
    unload: function () {
    },
    update: function (timer) {
      currentSeconds = timer.getSeconds();

      var rayTest = scene.bbRayTest(scene.camera.position, mvc.getMousePosition(), 3);
      if (rayTest.length > 0) {
        var objs = [];
        var cursor = 'default';
        for (var i=0; i<rayTest.length; ++i) {
          objs.push(rayTest[i].obj);
        } //for
        for (var i=0; i<links.length; ++i) {
          if (objs.indexOf(links[i]) > -1) {
            cursor = 'pointer';
            links[i].targetScale = links[i].activeScale;
            links[i].mouseOver = true;
          }
          else {
            links[i].targetScale = links[i].restingScale;
            links[i].mouseOver = false;
          } //if
        } //for
        document.body.style.cursor = cursor;
      }
      else {
        document.body.style.cursor = 'default';
        for (var i=0; i<links.length; ++i) {
          links[i].targetScale = links[i].restingScale;
          links[i].mouseOver = false;
        } //for
      } //if

      for (var i=0; i<links.length; ++i) {
        var scale = links[i].scale;
        var tScale = links[i].targetScale;
        scale[0] -= (scale[0] - tScale[0]) * .85;
        scale[1] -= (scale[1] - tScale[1]) * .85;
        scale[2] -= (scale[2] - tScale[2]) * .85;
        links[i].scale = scale;
      } //for

      audioBuffer = audioEngine.audioBuffer;
      if (audioBuffer) {
        audioTexture.update();
      } //if
    },
  });

}());
 

</script>
    <script id="cubicvr-core-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec3 aNormal;
  attribute vec2 aTextureCoord;
	varying vec2 vTextureCoord;

//  #if hasColorMap||hasBumpMap||hasNormalMap||hasAmbientMap||hasSpecularMap||hasAlphaMap
//  #endif

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform mat4 uOMatrix;
	uniform mat3 uNMatrix;

  vec3 mSpec;
  float mShine;

	varying vec3 vNormal;
	varying vec4 vPosition;
  varying vec3 camPos;

#if !depthPack

#if loopCount
  struct Light {
    vec3 lDir;
    vec3 lPos;
    vec3 lSpec;
    vec3 lDiff;
    float lInt;
    float lDist;
#ifdef lightSpot
    float lCut;
#endif
  };
 uniform Light lights[loopCount];
 varying vec3 lightDir[loopCount];
#endif

#if hasShadow
  varying vec4 shadowProj[loopCount];
  uniform mat4 spMatrix[loopCount];
#endif


#if lightPoint||lightSpot
  varying vec3 lightPos[loopCount];
#endif


#if hasEnvSphereMap
#if hasNormalMap
	varying vec3 u;
#else
	varying vec2 vEnvTextureCoord;
#endif
#endif


	
#if hasBumpMap||hasNormalMap
	varying vec3 eyeVec; 
#endif

#endif // !depthPack

void main(void) 
{
  mat4 uMVOMatrix = uMVMatrix * uOMatrix;
  mat4 uMVPMatrix = uPMatrix * uMVMatrix;

	vPosition = uMVOMatrix * vec4(aVertexPosition, 1.0);

	camPos.xyz = vec3(0.0,0.0,0.0);
	
	gl_Position = uMVPMatrix * uOMatrix * vec4(aVertexPosition, 1.0);

#if !depthPack
	
	vTextureCoord = aTextureCoord;

  vNormal = uNMatrix * normalize(uOMatrix*vec4(aNormal,0.0)).xyz;


#if hasBumpMap||hasNormalMap
	vec3 tangent;
	vec3 binormal;

	vec3 c1 = cross( aNormal, vec3(0.0, 0.0, 1.0) );
	vec3 c2 = cross( aNormal, vec3(0.0, 1.0, 0.0) );

	if ( length(c1) > length(c2) )	{
		tangent = c1;
	}	else {
		tangent = c2;
	}

	tangent = normalize(tangent);

	binormal = cross(aNormal, tangent);
	binormal = normalize(binormal);

	mat3 TBNMatrix = mat3( (vec3 (uMVOMatrix * vec4 (tangent, 0.0))), 
	                       (vec3 (uMVOMatrix * vec4 (binormal, 0.0))), 
	                       (vec3 (uMVOMatrix * vec4 (aNormal, 0.0)))
	                     );

	eyeVec = vec3(uMVOMatrix * vec4(aVertexPosition,1.0)) * TBNMatrix;
#endif


#if lightDirectional
    for (int i = 0; i < loopCount; i++)
    {
	    lightDir[i] = uNMatrix * lights[i].lDir;
    }
#endif

#if lightSpot
    for (int i = 0; i < loopCount; i++)
    {
	    lightDir[i] = uNMatrix * lights[i].lDir;
      lightPos[i] = (uMVMatrix*vec4(lights[i].lPos,1.0)).xyz;
#if hasShadow
      shadowProj[i] = spMatrix[i] * (uOMatrix * vec4(aVertexPosition, 1.0));
#endif      
    }
#endif

#if lightPoint
    for (int i = 0; i < loopCount; i++)
    {
      lightDir[i] = uNMatrix*normalize(lights[i].lPos-(uOMatrix * vec4(aVertexPosition, 1.0)).xyz);
      lightPos[i] = (uMVMatrix*vec4(lights[i].lPos,1.0)).xyz;
    }
#endif

#if hasEnvSphereMap
#if hasNormalMap
 	u = normalize( vPosition.xyz );
 #else
  vec3 ws = (uMVMatrix * vec4(aVertexPosition,1.0)).xyz;
	vec3 u = normalize( vPosition.xyz );
	vec3 r = reflect(ws  - camPos, vNormal );
	float m = 2.0 * sqrt( r.x*r.x + r.y*r.y + (r.z+1.0)*(r.z+1.0) );
	vEnvTextureCoord.s = r.x/m + 0.5;
	vEnvTextureCoord.t = r.y/m + 0.5;
#endif
#endif

#endif // !depthPack
}
</script>
    <script id="cubicvr-core-fs" type="x-shader/x-fragment">
#ifdef GL_ES
  precision highp float;
#endif

  uniform vec3 mDiff;
  uniform vec3 mColor;
  uniform vec3 mAmb;

  varying vec3 vNormal;

  varying vec2 vTextureCoord;

#if alphaDepth||depthPack||hasShadow
  uniform vec3 depthInfo;
  float ConvertDepth3(float d) { return (depthInfo.x*depthInfo.y)/(depthInfo.y-d*(depthInfo.y-depthInfo.x));  }
  // transform range in world-z to 0-1 for near-far
  float DepthRange( float d ) { return ( d - depthInfo.x ) / ( depthInfo.y - depthInfo.x ); }

  float ConvertDepth3A(float d, float near, float far) { return (near*far)/(far-d*(far-near));  }
  // transform range in world-z to 0-1 for near-far
  float DepthRangeA( float d, float near, float far ) { return ( d - near ) / ( far - near ); }
#endif

#if depthPack
  vec4 packFloatToVec4i(const float value)
  {
    const vec4 bitSh = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
    const vec4 bitMsk = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
    vec4 res = fract(value * bitSh);
    res -= res.xxyz * bitMsk;
    return res;
  }

#endif

#if hasShadow
float unpackFloatFromVec4i(const vec4 value)
{
  const vec4 bitSh = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
  return(dot(value, bitSh));
}

#if softShadow
float getShadowVal(sampler2D shadowTex,vec4 shadowCoord, float proj, float texel_size) {
  vec2 filterTaps[6]; 
	filterTaps[0] = vec2(-0.326212,-0.40581);
	filterTaps[1] = vec2(-0.840144,-0.07358);
	filterTaps[2] = vec2(-0.695914,0.457137);
	filterTaps[3] = vec2(-0.203345,0.620716);
	filterTaps[4] = vec2(0.96234,-0.194983);
	filterTaps[5] = vec2(0.473434,-0.480026); 
/*	filterTaps[6] = vec2(0.519456,0.767022);
	filterTaps[7] = vec2(0.185461,-0.893124); 
	filterTaps[8] = vec2(0.507431,0.064425);
	filterTaps[9] = vec2(0.89642,0.412458) ;
	filterTaps[10] =vec2(-0.32194,-0.932615);
	filterTaps[11] =vec2(-0.791559,-0.59771); */

 	float shadow = 0.0; 	
	
	for (int i = 0; i < 6; i++) {
    vec4 shadowSample = texture2D(shadowTex,shadowCoord.st+filterTaps[i]*(2.0*texel_size));

  	float distanceFromLight = unpackFloatFromVec4i(shadowSample)*0.999;
	
    if (proj > 0.0 && shadowCoord.s>=0.0 && shadowCoord.s<=1.0 && shadowCoord.t >= 0.0 && shadowCoord.t <= 1.0) {
      shadow += distanceFromLight < shadowCoord.z ? 0.0 : 1.0 ;
    }
	}

  shadow /= 6.0;
  
  return shadow;
}
#else
float getShadowVal(sampler2D shadowTex,vec4 shadowCoord, float proj, float texel_size) {
  vec4 shadowSample = texture2D(shadowTex,shadowCoord.st);

	float distanceFromLight = unpackFloatFromVec4i(shadowSample)*0.999;
	
 	float shadow = 1.0;
 	
  if (proj > 0.0 && shadowCoord.s>=0.0 && shadowCoord.s<=1.0 && shadowCoord.t >= 0.0 && shadowCoord.t <= 1.0) {
    shadow = distanceFromLight < shadowCoord.z ? 0.0 : 1.0 ;
  }
  
  return shadow;
}
#endif
#endif


#if hasShadow
  varying vec4 shadowProj[loopCount];
  uniform sampler2D lDepthTex[loopCount];
  uniform vec3 lDepth[loopCount];
#endif



#if hasColorMap
	uniform sampler2D colorMap;
#endif

#if hasBumpMap
	varying vec3 eyeVec; 
	uniform sampler2D bumpMap;
#endif


#if hasEnvSphereMap
	uniform sampler2D envSphereMap;
	uniform float envAmount;
#if hasNormalMap
 	varying vec3 u;
#else
	varying vec2 vEnvTextureCoord;
#endif
#endif

#if hasReflectMap
  uniform sampler2D reflectMap;
#endif

#if hasNormalMap
	uniform sampler2D normalMap;
#endif

	uniform float mAlpha;

#if hasAmbientMap
	uniform sampler2D ambientMap;
#endif

#if hasSpecularMap
	uniform sampler2D specularMap;
#endif

#if hasAlphaMap
	uniform sampler2D alphaMap;
#endif

#if lightPoint||lightDirectional||lightSpot||lightArea
  struct Light {
    vec3 lDir;
    vec3 lPos;
    vec3 lSpec;
    vec3 lDiff;
    float lInt;
    float lDist;
    #if lightSpot
        float lCut;
    #endif
  };
  uniform Light lights[loopCount];  
	varying vec3 lightDir[loopCount];
#endif

uniform vec3 mSpec;
uniform float mShine;
uniform vec3 lAmb;


#if lightPoint||lightSpot
  varying vec3 lightPos[loopCount];
#endif



varying vec3 camPos;
varying vec4 vPosition;

uniform mat4 uPMatrix;

void main(void) 
{
#if !depthPack

	vec3 n;
	vec4 color = vec4(0.0,0.0,0.0,0.0);
	
#if hasBumpMap
  float height = texture2D(bumpMap, vTextureCoord.xy).r;  
  float v = (height) * 0.05 - 0.04; // * scale and - bias 
  vec3 eye = normalize(eyeVec); 
  vec2 texCoord = vTextureCoord.xy + (eye.xy * v);
#else 
//#if hasColorMap||hasBumpMap||hasNormalMap||hasAmbientMap||hasSpecularMap||hasAlphaMap
	vec2 texCoord = vTextureCoord;
//#endif
#endif


#if hasNormalMap
 		vec3 bumpNorm = vec3(texture2D(normalMap, texCoord));

		n = (vec4(normalize(vNormal),1.0)).xyz;
    bumpNorm = (bumpNorm-0.5)*2.0;
    bumpNorm.y = -bumpNorm.y;
    n = normalize((n+bumpNorm)/2.0);
#else
		n = normalize(vNormal);
#endif


#if hasColorMap
#if !(lightPoint||lightDirectional||lightSpot||lightArea)
	color = texture2D(colorMap, vec2(texCoord.s, texCoord.t)).rgba;
	//vec4(lAmb,1.0)*
#else
  color = texture2D(colorMap, vec2(texCoord.s, texCoord.t)).rgba;
  color.rgb *= mColor;
#endif
  if (color.a<=0.9) discard;  
#else
	color = vec4(mColor,1.0);
#endif

#if hasAlphaMap
	color.a = texture2D(alphaMap, texCoord).r;
#if alphaDepth||depthPack
  if (color.a < 0.9) discard;
#else
  if (color.a==0.0) discard;
#endif
#else
#if hasAlpha
	color.a = mAlpha;
#endif
#endif


//float envAmount = 1.0;

vec3 accum = lAmb;


#if lightPoint
  float dist;
	float NdotL;

	float NdotHV = 0.0;
  float att = 0.0;

  vec3 halfVector;
  vec3 specTotal = vec3(0.0,0.0,0.0);

  for (int i = 0; i < loopCount; i++) {
  
	  halfVector = normalize(vec3(0.0,0.0,1.0)+lightDir[i]);

    dist = length(lightPos[i]-vPosition.xyz);

  	NdotL = max(dot(normalize(lightDir[i]),n),0.0);

  	if (NdotL > 0.0) {
  		// basic diffuse
      att = clamp(((lights[i].lDist-dist)/lights[i].lDist), 0.0, 1.0)*lights[i].lInt;

  		accum += att * NdotL * lights[i].lDiff * mDiff;

   		NdotHV = max(dot(n, halfVector),0.0);

	
	    #if hasSpecularMap
			  vec3 spec2 = lights[i].lSpec * texture2D(specularMap, vec2(texCoord.s, texCoord.t)).rgb * pow(NdotHV,mShine);
	    #else
			  vec3 spec2 = lights[i].lSpec * mSpec * pow(NdotHV,mShine);
	    #endif
  
        specTotal += spec2;
  	}
  	
  }
  
  color.rgb *= accum;
  color.rgb += specTotal;
#endif




#if lightDirectional
  float NdotL;
  float NdotHV = 0.0;
  vec3 specTotal = vec3(0.0,0.0,0.0);
  vec3 spec2 = vec3(0.0,0.0,0.0);

	vec3 halfVector;
  
  for (int i = 0; i < loopCount; i++) {

	  halfVector = normalize(vec3(0.0,0.0,1.0)-lightDir[i]);

  	NdotL = max(dot(normalize(-lightDir[i]),n),0.0);

  	if (NdotL > 0.0) 	{
  		accum += lights[i].lInt * mDiff * lights[i].lDiff * NdotL;		

   		NdotHV = max(dot(n, halfVector),0.0);

      #if hasSpecularMap
        spec2 = lights[i].lSpec * texture2D(specularMap, vec2(texCoord.s, texCoord.t)).rgb * pow(NdotHV,mShine);
      #else
        spec2 = lights[i].lSpec * mSpec * pow(NdotHV,mShine);
      #endif
      
      specTotal += spec2;
  	}
  }  
  
  color.rgb *= accum;
  color.rgb += specTotal;
#endif


#if lightSpot
  vec3 specTotal = vec3(0.0,0.0,0.0);
  vec3 spec2 = vec3(0.0,0.0,0.0);

	vec3 halfVector;
  
  for (int i = 0; i < loopCount; i++) {
    vec3 l = lightPos[i]-vPosition.xyz;
    
    float dist = length(l);

    float att = clamp(((lights[i].lDist-dist)/lights[i].lDist), 0.0, 1.0)*lights[i].lInt;

    att = clamp(att,0.0,1.0);

    float spotDot = dot(normalize(-l), normalize(lightDir[i]));

    float spotEffect = (spotDot < cos((lights[i].lCut/2.0)*(3.14159/180.0))) ? 0.0 : pow(spotDot, 1.0);

    att *= spotEffect;

    vec3 v = normalize(-vPosition.xyz);
    vec3 h = normalize(l + v);

    float NdotL = max(0.0, dot(n, normalize(l)));
    float NdotH = max(0.0, dot(n, h));

    float power = (NdotL > 0.0) ?  pow(NdotH, mShine) : 0.0;

#if hasShadow
    vec4 shadowCoord = shadowProj[i] / shadowProj[i].w;
		
    shadowCoord.z = DepthRangeA(ConvertDepth3A(shadowCoord.z,lDepth[i].x,lDepth[i].y),lDepth[i].x,lDepth[i].y);

    vec4 shadowSample;

    float shadow = 1.0;
// this seems to get around a shader crash ...		
		if (i == 0) { shadow = getShadowVal(lDepthTex[0],shadowCoord,shadowProj[i].w,lDepth[i].z);} 
#if loopCount>1		
		else if (i == 1) { shadow = getShadowVal(lDepthTex[1],shadowCoord,shadowProj[i].w,lDepth[i].z); }
#endif
#if loopCount>2		
		else if (i == 2) { shadow = getShadowVal(lDepthTex[2],shadowCoord,shadowProj[i].w,lDepth[i].z); }
#endif
#if loopCount>3
		else if (i == 3) { shadow = getShadowVal(lDepthTex[3],shadowCoord,shadowProj[i].w,lDepth[i].z);	}
#endif
#if loopCount>4		
		else if (i == 4) { shadow = getShadowVal(lDepthTex[4],shadowCoord,shadowProj[i].w,lDepth[i].z);	}
#endif
#if loopCount>5		
		else if (i == 5) { shadow = getShadowVal(lDepthTex[5],shadowCoord,shadowProj[i].w,lDepth[i].z);	}
#endif
#if loopCount>6		
		else if (i == 6) { shadow = getShadowVal(lDepthTex[6],shadowCoord,shadowProj[i].w,lDepth[i].z);	}
#endif
#if loopCount>7
		else if (i == 7) { shadow = getShadowVal(lDepthTex[7],shadowCoord,shadowProj[i].w,lDepth[i].z); }
#endif
	 		
     att = att * shadow;
#endif

		accum += att * lights[i].lDiff * mDiff * NdotL;		
    
    #if hasSpecularMap
      spec2 = lights[i].lSpec * texture2D(specularMap, vec2(texCoord.s, texCoord.t)).rgb * power;
    #else
      spec2 = lights[i].lSpec * mSpec * power;
    #endif

    specTotal += spec2;

  }  
  
  
  color.rgb *= accum;
  color.rgb += specTotal;

  #if hasShadow
  //  color = texture2D(lDepthTex[0], vec2(texCoord.s, texCoord.t)).rgba;

  #endif
#endif




#if hasReflectMap
  float environmentAmount = texture2D( reflectMap, texCoord).r;
#endif

#if hasEnvSphereMap
#if hasNormalMap
	vec3 r = reflect( u, n );
	float m = 2.0 * sqrt( r.x*r.x + r.y*r.y + (r.z+1.0)*(r.z+1.0) );

	vec3 coord;
	coord.s = r.x/m + 0.5;
	coord.t = r.y/m + 0.5;
	
  #if hasReflectMap
		color.rgb += mColor*accum*texture2D( envSphereMap, coord.st).rgb * environmentAmount;
	 #else
		color.rgb += mColor*accum*texture2D( envSphereMap, coord.st).rgb * envAmount;
	 #endif

#else
	#if hasReflectMap
 	  color.rgb += mColor*accum*texture2D( envSphereMap, vEnvTextureCoord).rgb * environmentAmount;
	#else
	 	color.rgb += mColor*accum*texture2D( envSphereMap, vEnvTextureCoord).rgb*envAmount;
	#endif
#endif

#endif



#if hasAmbientMap
#if lightPoint||lightDirectional||lightSpot||lightArea
  color.rgb += texture2D(ambientMap, texCoord).rgb*(vec3(1.0,1.0,1.0)+mColor*mAmb);
#else
  color.rgb = color.rgb*texture2D(ambientMap, texCoord).rgb;							
#endif
#else
#if !hasColorMap
	color.rgb += mColor*mAmb;
#else
  color.rgb += mAmb*texture2D(colorMap, texCoord).rgb;
#endif
#endif

#if alphaDepth
#if !hasAlpha
  float linear_depth = DepthRange( ConvertDepth3(gl_FragCoord.z) );

  color.a = linear_depth;
#endif
#endif


gl_FragColor = clamp(color,0.0,1.0);

#endif // !depthPack

#if depthPack
  gl_FragColor = packFloatToVec4i(DepthRange( ConvertDepth3(gl_FragCoord.z)));
#endif

}
</script>
    <script id="cubicvr-fx-general-vs" type="x-shader/x-vertex">
attribute vec3 aVertex;
attribute vec2 aTex;
varying vec2 vTex;

void main(void)
{
	vTex = aTex;
	vec4 vPos = vec4(aVertex.xyz,1.0);
	gl_Position = vPos;
}

</script>
    <script id="cubicvr-alpha-depth-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D srcTex;
varying vec2 vTex;

void main(void)
{
  float v = texture2D(srcTex,vTex).a+0.2;
                
  gl_FragColor = vec4(v,v,v,1.0);
}


</script>
    <script id="cubicvr-invert-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D srcTex;
varying vec2 vTex;

void main(void)
{
  vec4 c;

  c = vec4(vec3(1.0,1.0,1.0)-texture2D(srcTex,vTex).rgb,1.0);

  gl_FragColor = c;	  
}

</script>
    <script id="cubicvr-dof-6tap-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D srcTex;
uniform sampler2D captureTex;
varying vec2 vTex;
uniform vec3 texel;
uniform vec3 depthInfo;

vec2 filterTaps[6];

uniform float near_depth;
uniform float far_depth;

void main(void)
{
  filterTaps[0] = vec2(-0.326212, -0.405805);
  filterTaps[1] = vec2(-0.840144, -0.073580);
  filterTaps[2] = vec2(-0.695914,  0.457137);
  filterTaps[3] = vec2(-0.203345,  0.620716);
  filterTaps[4] = vec2( 0.962340, -0.194983);
  filterTaps[5] = vec2( 0.473434, -0.480026);

  float depth_test = texture2D(captureTex, vTex.xy).a;

  vec4 color = vec4(0.0,0.0,0.0,1.0);

  float depthSample = 1.0;

  vec2 radius = vec2(texel.x*2.0,texel.y*2.0);
  float effect = 0.0;
  vec2 ofsSample;

  //	  float colorDiv = 0.0;
  
  float dNear = near_depth;
  float dFar = far_depth;

  bool dln = depth_test < dNear;
  bool dgf = depth_test > dFar;
/*  
  if (dgf) color.rgb+=vec3(1.0,0.0,0.0);
  if (dln) color.rgb+=vec3(0.0,0.0,1.0);
  if (!dgf&&!dln) color.rgb+=vec3(0.0,1.0,0.0);
	*/
/* */
  for (int i = 0; i < 6; i++)
  {
	  depthSample = texture2D( captureTex, vec2(vTex.x+filterTaps[i].x*radius.x*effect,vTex.y+filterTaps[i].y*radius.y*effect)).a; 
	  effect = 0.0;

	  bool ds_gf = depthSample > dFar;
	  bool ds_ln = depthSample < dNear;

	  if (dln || ds_gf)
	  {
			effect = (depthSample > depth_test)?((depthSample-dFar)/(1.0-dFar))*2.0:((depth_test-dFar)/(1.0-dFar));	// far		  
	  }
	  else if (dln || ds_ln)
	  {
			effect = ((depthSample < depth_test)?(1.0-1.0/(dNear/depthSample)):(1.0-1.0/(dNear/depth_test))); // near
	  }
	  else if ((dln && ds_gf)||(dln && ds_ln))
	  {
		  effect = (dln && ds_gf)?(1.0-1.0/(dNear/depth_test)): //near
		  ((depth_test-dFar)/(1.0-dFar));	// far		  
	  }
    
    if (ds_ln) effect *= 8.0;
    
    effect *= 3.0;

	  ofsSample = vec2(vTex.x+filterTaps[i].x*radius.x*effect,vTex.y+filterTaps[i].y*radius.y*effect);

	  if (abs(ofsSample.x)>1.0 || abs(ofsSample.y)>1.0 || abs(ofsSample.x)<0.0 || abs(ofsSample.y)<0.0) ofsSample = vTex.xy;

	  color += texture2D( srcTex, ofsSample);   
  }
  color /= 6.0;
  /* */

  gl_FragColor = vec4(color.rgb,1.0);
}
</script>
    <script id="cubicvr-ssao-fs" type="x-shader/x-fragment">
#ifdef GL_ES
	precision highp float;
	#endif
  uniform sampler2D srcTex;
  uniform sampler2D captureTex;
	varying vec2 vTex;

	  uniform float near_depth;
	  uniform float far_depth;
	  uniform vec3 texel;

	  float compareDepths( in float depth1, in float depth2, float aoMultiplier ) 
	  {
	  float aoCap = 3.0;
	  float depthTolerance=0.015;
	  float aorange = 20.0;// units in space the AO effect extends to (this gets divided by the camera far range
	  float diff = sqrt( clamp(1.0-(depth1-depth2) / (aorange/(far_depth-near_depth)),0.0,1.0) );
	  float ao = min(aoCap,max(0.0,depth1-depth2-depthTolerance) * aoMultiplier) * diff;
	  return ao;
	  }

	  void main(void)
	  {	
	  vec2 texCoord = vTex.xy;
	  float depth = texture2D( captureTex, texCoord ).w;
	  float d;

	  float pw = texel.x;
	  float ph = texel.y;

	  float aoCap = 1.0;

	  float ao = 0.0;

	  float aoMultiplier=10000.0;

	  float aoscale=1.0;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;         
                                                               
	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;         
                                                               
	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;         
                                                               
	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  pw*=2.0;
	  ph*=2.0;
	  aoMultiplier/=2.0;
	  aoscale*=2.0;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  pw*=2.0;
	  ph*=2.0;
	  aoMultiplier/=2.0;
	  aoscale*=2.0;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  pw*=2.0;
	  ph*=2.0;
	  aoMultiplier/=2.0;
	  aoscale*=2.0;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y+ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x+pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

	  d=texture2D( captureTex,  vec2(texCoord.x-pw,texCoord.y-ph)).w;
	  ao+=compareDepths(depth, d, aoMultiplier)/aoscale;

    ao/=16.0;
	  // ao/=16.0;

    ao = clamp(1.0-ao,0.0,1.0);


	  gl_FragColor = vec4(ao * texture2D(srcTex,texCoord).rgb,1.0);
}
</script>
    <script id="cubicvr-bloom-6tap-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D srcTex;
uniform sampler2D captureTex;
varying vec2 vTex;
uniform vec3 texel;

vec2 radius;
#define colorCap 0.90

vec2 filterTaps[6];

vec3 rangeValHDR(vec3 src)
{
  return (src.r>colorCap||src.g>colorCap||src.b>colorCap)?(src):vec3(0.0,0.0,0.0);
}

vec3 hdrSample(float rad)
{
  vec3 accum = vec3(0.0,0.0,0.0);
  float c = 0.0;
  vec3 ctemp;
  
  for (int i = 0; i < 6; i++)
  {      		    
    accum += rangeValHDR(texture2D(srcTex, vec2(vTex.x+filterTaps[i].x*radius.x*rad,vTex.y+filterTaps[i].y*radius.y*rad)).rgb).rgb;      		    
  }

  accum /= 4.0;

  return accum.rgb;
}


void main(void)
{
  vec3 color;
  radius = vec2(texel.x,texel.y);

  filterTaps[0] = vec2(-0.326212, -0.405805);
  filterTaps[1] = vec2(-0.840144, -0.073580);
  filterTaps[2] = vec2(-0.695914,  0.457137);
  filterTaps[3] = vec2(-0.203345,  0.620716);
  filterTaps[4] = vec2( 0.962340, -0.194983);
  filterTaps[5] = vec2( 0.473434, -0.480026);    		  


  color = hdrSample(4.0);
  color += hdrSample(6.0);
  color += hdrSample(12.0);
  gl_FragColor.rgb = color/4.0;
  gl_FragColor.a = 1.0;
}
</script>
		<script>
      var shaderList = [];
      var fxChain;
      var shaders = {};
      var gl;
			var canvas_w, canvas_h, aspect;
			var canvas, scene;

			document.addEventListener('DOMContentLoaded', function (e) {
        canvas = document.createElement('canvas');
        
        canvas.style.position="absolute";
        
  			aspect = 1280/720;
  			canvas_w = window.innerWidth;
  			canvas_h = canvas_w*(1.0/aspect);
  			if (canvas_h>window.innerHeight) canvas_h = window.innerHeight;

  			var toppx = (window.innerHeight/2)-(canvas_h/2);

        canvas.width = canvas_w;
        canvas.height = canvas_h;
        canvas.style.top = toppx+"px";
        canvas.style.left = "0px";
        
        gl = CubicVR.GLCore.init(canvas, 'cubicvr-core-vs', 'cubicvr-core-fs');
        
        if (!gl) {
          return;
        }

        // expose the alphaDepth buffer
        var shaderDepth = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-alpha-depth-fs",
        });
        shaders['depth'] = shaderDepth;


        // simple color invert
        var shaderInvert = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-invert-fs"
        });
        shaders['invert'] = shaderInvert;

        var shaderDOF6 = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-dof-6tap-fs",
          init: function(shader) {
            shader.addFloat("near_depth");
            shader.addFloat("far_depth");
          },
          onupdate: function(shader) {
            // linear depth
            var d = CubicVR.vec3.length(scene.camera.position, scene.camera.target);

            shader.setFloat("near_depth", (d - 0.5 - scene.camera.nearclip) / scene.camera.farclip);
            shader.setFloat("far_depth", (d + 4 - scene.camera.nearclip) / scene.camera.farclip);
          }
        });
        shaders['dof'] = shaderDOF6;

        var shaderSSAO = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-ssao-fs",
        });
        shaders['ssao'] = shaderSSAO;


        // Bloom + 1/2 divisor + blend
        var shaderHalfBloom = new CubicVR.PostProcessShader({
          shader_vertex: "cubicvr-fx-general-vs",
          shader_fragment: "cubicvr-bloom-6tap-fs",
          outputMode: CubicVR.enums.post.output.ADD,
          outputDivisor: 2
        });
        shaders['halfbloom'] = shaderHalfBloom;


        // Bloom + 1/4 divisor + blend
        var shaderQuarterBloom = new CubicVR.PostProcessShader({
            shader_vertex: "cubicvr-fx-general-vs",
            shader_fragment: "cubicvr-bloom-6tap-fs",
            outputMode: CubicVR.enums.post.output.ADD,
            outputDivisor: 4
        });
        shaders['quarterbloom'] = shaderQuarterBloom;

        /*
        var i = 0;
        var shaderActive = 0;

        fxSelect = document.getElementById("shaderSelector");
        fxSelect.options[i] = new Option("Depth Buffer View", i++);
        fxSelect.options[i] = new Option("Invert Color", i++);
        fxSelect.options[i] = new Option("Screen-Space Ambient Occlusion", i++);
        fxSelect.options[shaderActive = i] = new Option("6-Tap Depth Of Field", i++);
        fxSelect.options[i] = new Option("6-Tap Bloom, 1/2 blend", i++);
        fxSelect.options[i] = new Option("6-Tap Bloom, 1/4 blend", i++);
        //fxSelect.selectedIndex = fxSelect.options.length-1;
        fxSelect.selectedIndex = shaderActive;
        */

        shaderList.push(shaderDepth);
        shaderList.push(shaderInvert);
        shaderList.push(shaderSSAO);
        shaderList.push(shaderDOF6);
        shaderList.push(shaderHalfBloom);
        shaderList.push(shaderQuarterBloom);

        fxChain = new CubicVR.PostProcessChain(canvas.width, canvas.height, true);
        fxChain.setBlurOpacity(0.75);
        fxChain.setBlurIntensity(1.0);

        for (var i = 0; i < shaderList.length; i++) {
          fxChain.addShader(shaderList[i]);
          shaderList[i].enabled = false;
        } //for

        //shaderList[fxSelect.selectedIndex].enabled = true;

        var fft;
        var audioBuffer;
        var signal = new Float32Array(4096);
        var audioEngine = new AudioEngine(function (data) {
          fft.forward(data);
          audioBuffer = data;
          audioEngine.audioBuffer = data;
          for (var i=0, l=4096; i<l; ++i) {
            if (fft.spectrum[i] > signal[i]) {
              signal[i] = fft.spectrum[i];
            }
            else {
              signal[i]*=0.45;
            } //if
          } //for
        });

        audioEngine.playMod('mod.mod');
        audioEngine.audioObject.volume = 1;

        var basePlayer = Popcorn.baseplayer();
        basePlayer.timeupdate = function () {
          //purposely empty
        };
        var popcorn = Popcorn(basePlayer);

        fft = new FFT(4096, 44100);
        audioEngine.fft = fft;

        scene = new CubicVR.Scene(canvas.width, canvas.height, 80);

        scene.camera.position = [0, 0.5, 2];
        scene.camera.target = [0, 0, 0];
        CubicVR.setGlobalDepthAlpha(true, scene.camera.nearclip, scene.camera.farclip);
       
        for (var i=0, s=SegmentList.segments, l=s.length; i<l; ++i) {
          var startTime = s[i].startTime;
          popcorn.code({
            start: startTime,
            end: startTime+1,
            onStart: function (options) {
              SegmentList.nextSegment();
            },
          });
        } //for      

        SegmentList.prepareSegments({
          popcorn: popcorn,
          audioEngine: audioEngine,
          scene: scene,
          canvas: canvas,
        });

        CubicVR.MainLoop(function(timer, gl) {
          var seconds = timer.getSeconds();

          SegmentList.updateSegments(timer);

          basePlayer.currentTime = seconds;
          basePlayer.dispatchEvent('timeupdate');

          scene.evaluate(seconds);

          scene.updateShadows();

          fxChain.begin();
          gl.clearColor(0.0, 0.0, 0.0, 1.0);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          scene.render();
          fxChain.end();
          fxChain.render();
        });

        document.body.appendChild(canvas);

        popcorn.play();
        basePlayer.readyState = 2;

			}, false);

      function selectShaderFX(elem) {
        fxSelect = document.getElementById("shaderSelector");

        for (var i = 0; i < fxSelect.length; i++) {
          shaderList[i].enabled = (fxSelect.options[i].selected) ? true : false;
        }
      }

      function setSize() {
          if (!gl) {
            return;
          }

          var width  = window.innerWidth,
              height = width / aspect;

          function resize(elem) {
            elem.width = width;
            elem.height = height;
            elem.style.top= ((window.innerHeight/2) - (elem.height/2)) + 'px';
          }

          resize(canvas);

          gl.viewport(0, 0, canvas.width, canvas.height);
          scene.camera.setDimensions(canvas.width, canvas.height);
          fxChain.resize(canvas.width, canvas.height);
        };


      window.addEventListener('resize',  function()  { setSize(); }, false);

		</script>
	</head>
	<body>
  <!--
        <div style='position:absolute; top:10px; left:10px; color:white; font-family:Arial; font-size:14px;'>
            &nbsp;&nbsp;Change FX (multi):
            <a href="javascript:void(0)" onclick="document.getElementById('fxDiv').style.display=(document.getElementById('fxDiv').style.display=='none')?'':'none';"
            style='text-decoration:none'>( toggle )</a>
            <div style='display:none' id='fxDiv'>
                <br />
                <select id="shaderSelector" onchange="selectShaderFX(this)" multiple size="15" style='vertical-align:top'>
                </select>
                <br/>
                Blur opac:
                <input type='text' onchange="fxChain.setBlurOpacity(parseFloat(this.value))" size='4'
                value="1">
                intens:
                <input type='text' onchange="fxChain.setBlurIntensity(parseFloat(this.value))" size='4'
                value="0">
                <br/>
            </div>
        </div>
  -->
    <img class="data-image" id="img/fract_reflections.jpg" src="data:image/jpeg;base64,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%3D
"/>
    <img class="data-image" id="img/logo.jpg" src="data:image/jpeg;base64,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%3D
"/>
    <img class="data-image" id="img/logo-alpha.jpg" src="data:image/jpeg;base64,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QXBwbGllZD0iVHJ1ZSIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMSIgeG1wOkNyZWF0ZURhdGU9IjIwMTEtMDUtMTVUMDE6NDQtMDQ6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDExLTA1LTE2VDIwOjIwOjQ2LTA0OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDExLTA1LTE2VDIwOjIwOjQ2LTA0OjAwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgTWFjaW50b3NoIiBkYzpmb3JtYXQ9ImltYWdlL2pwZWciIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MDc4MDExNzQwNzIwNjgxMThFMjRERkJGMzVBQzI1MjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MDI4MDExNzQwNzIwNjgxMThFMjRERkJGMzVBQzI1MjQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDowMjgwMTE3NDA3MjA2ODExOEUyNERGQkYzNUFDMjUyNCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjAyODAxMTc0MDcyMDY4MTE4RTI0REZCRjM1QUMyNTI0IiBzdEV2dDp3aGVuPSIyMDExLTA1LTE2VDIwOjE3OjQ1LTA0OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDc4MDExNzQwNzIwNjgxMThFMjRERkJGMzVBQzI1MjQiIHN0RXZ0OndoZW49IjIwMTEtMDUtMTZUMjA6MjA6NDYtMDQ6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDUzUgTWFjaW50b3NoIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8P3hwYWNrZXQgZW5kPSJ3Ij8+/+4ADkFkb2JlAGQAAAAAAP/bAEMAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQICAgICAgICAgICAwMDAwMDAwMDA//AAAsIAbQCAAEBEQD/3QAEAED/xABYAAEAAgIDAQEBAQAAAAAAAAAACgsICQUGBwQCAQMQAAAGAwABBAIBAgQDBgcBAAACAwQFBgEHCAkREhMKIRQVMRYiMiMXQWEkUaFCMyUYcZHBkmUmJxn/2gAIAQEAAD8Ar/wAAAAAAAAAAAAAAAAAAAAAAAAAc1Xa3YLfNxtaqsJKWKwTDpNlFQsKxcyUnIOlc+hEGjJomq4XUz/X0KXPpjGc5/GMiWFw79PjyGdBryct1rYaxwxT2eGWYlOcTqe9dj2ortAzgy8bTNcbKawcCxaez4nGZmcj36apy+xksXBjFyh60+lR0LQKpK2nj3qSq9CTLBNkZrqzY9Kbacs0vlZ82auyxFzPdrHS1lWbZczkxX/8WTKSBykUOqZNM0UbsPx/9j8BXKPofX2hbdpWwzDc7uEzMOa9YK9Ptk1FElF6/cqXNWWnTyRFUTlyZm/WxgyZsf1Kb0w7AAAAAAAAAAAAAB//0K/8AAAAAAAAAAAAAAAAAAAAAAAAZ38aeMvufv8AkF23J/Ol82vFRstGw0/b49CNhaPWncqosm0xP3OzyMHWIvCmGqxsfM7J/hRUzn0wQ+SzION/pQJQtmibT3Z1XX7bBxko3Wfah56r1lRjrNHJqEO4byO27ctVJ+JI5SwZP42deKqU2cKYc/4cpmmZ8kcJ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%3D%3D
"/>
	</body>
</html>
